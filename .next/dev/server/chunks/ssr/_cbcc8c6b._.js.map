{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":["file:///D:/BeadsLine/lib/queryClient.ts"],"sourcesContent":["import { QueryClient, QueryFunction } from \"@tanstack/react-query\";\n\n// App version for cache busting\nexport const APP_VERSION = \"1.2.3\";\n\n// Check and clear cache if version changed - только в браузере\nif (typeof window !== 'undefined') {\n  const STORAGE_VERSION_KEY = \"beadsline_app_version\";\n  const storedVersion = localStorage.getItem(STORAGE_VERSION_KEY);\n  if (storedVersion && storedVersion !== APP_VERSION) {\n    // Version changed - clear caches\n    localStorage.clear();\n    sessionStorage.clear();\n    if ('caches' in window) {\n      caches.keys().then(names => names.forEach(name => caches.delete(name)));\n    }\n    console.log(`App updated: ${storedVersion} -> ${APP_VERSION}`);\n  }\n  localStorage.setItem(STORAGE_VERSION_KEY, APP_VERSION);\n}\n\nasync function throwIfResNotOk(res: Response) {\n  if (!res.ok) {\n    const text = (await res.text()) || res.statusText;\n    throw new Error(`${res.status}: ${text}`);\n  }\n}\n\nexport async function apiRequest(\n  method: string,\n  url: string,\n  data?: unknown | undefined,\n): Promise<Response> {\n  const res = await fetch(url, {\n    method,\n    headers: data ? { \"Content-Type\": \"application/json\" } : {},\n    body: data ? JSON.stringify(data) : undefined,\n    credentials: \"include\",\n  });\n\n  await throwIfResNotOk(res);\n  return res;\n}\n\ntype UnauthorizedBehavior = \"returnNull\" | \"throw\";\nexport const getQueryFn: <T>(options: {\n  on401: UnauthorizedBehavior;\n}) => QueryFunction<T> =\n  ({ on401: unauthorizedBehavior }) =>\n  async ({ queryKey }) => {\n    const res = await fetch(queryKey.join(\"/\") as string, {\n      credentials: \"include\",\n    });\n\n    if (unauthorizedBehavior === \"returnNull\" && res.status === 401) {\n      return null;\n    }\n\n    await throwIfResNotOk(res);\n    return await res.json();\n  };\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      queryFn: getQueryFn({ on401: \"throw\" }),\n      refetchInterval: false,\n      refetchOnWindowFocus: false,\n      staleTime: Infinity,\n      retry: false,\n    },\n    mutations: {\n      retry: false,\n    },\n  },\n});\n"],"names":[],"mappings":";;;;;;;;;;AAAA;;;;;;AAGO,MAAM,cAAc;AAE3B,+DAA+D;AAC/D;;AAeA,eAAe,gBAAgB,GAAa;IAC1C,IAAI,CAAC,IAAI,EAAE,EAAE;QACX,MAAM,OAAO,AAAC,MAAM,IAAI,IAAI,MAAO,IAAI,UAAU;QACjD,MAAM,IAAI,MAAM,GAAG,IAAI,MAAM,CAAC,EAAE,EAAE,MAAM;IAC1C;AACF;AAEO,eAAe,WACpB,MAAc,EACd,GAAW,EACX,IAA0B;IAE1B,MAAM,MAAM,MAAM,MAAM,KAAK;QAC3B;QACA,SAAS,OAAO;YAAE,gBAAgB;QAAmB,IAAI,CAAC;QAC1D,MAAM,OAAO,KAAK,SAAS,CAAC,QAAQ;QACpC,aAAa;IACf;IAEA,MAAM,gBAAgB;IACtB,OAAO;AACT;AAGO,MAAM,aAGX,CAAC,EAAE,OAAO,oBAAoB,EAAE,GAChC,OAAO,EAAE,QAAQ,EAAE;QACjB,MAAM,MAAM,MAAM,MAAM,SAAS,IAAI,CAAC,MAAgB;YACpD,aAAa;QACf;QAEA,IAAI,yBAAyB,gBAAgB,IAAI,MAAM,KAAK,KAAK;YAC/D,OAAO;QACT;QAEA,MAAM,gBAAgB;QACtB,OAAO,MAAM,IAAI,IAAI;IACvB;AAEK,MAAM,cAAc,IAAI,0OAAW,CAAC;IACzC,gBAAgB;QACd,SAAS;YACP,SAAS,WAAW;gBAAE,OAAO;YAAQ;YACrC,iBAAiB;YACjB,sBAAsB;YACtB,WAAW;YACX,OAAO;QACT;QACA,WAAW;YACT,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 77, "column": 0}, "map": {"version":3,"sources":["file:///D:/BeadsLine/lib/utils.ts"],"sourcesContent":["import { clsx, type ClassValue } from \"clsx\"\r\nimport { twMerge } from \"tailwind-merge\"\r\n\r\nexport function cn(...inputs: ClassValue[]) {\r\n  return twMerge(clsx(inputs))\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;;;;;;AAEO,SAAS,GAAG,GAAG,MAAoB;IACxC,OAAO,IAAA,qMAAO,EAAC,IAAA,2JAAI,EAAC;AACtB"}},
    {"offset": {"line": 98, "column": 0}, "map": {"version":3,"sources":["file:///D:/BeadsLine/lib/telegram.ts"],"sourcesContent":["declare global {\r\n  interface Window {\r\n    Telegram?: {\r\n      WebApp?: TelegramWebApp;\r\n    };\r\n  }\r\n}\r\n\r\ninterface TelegramUser {\r\n  id: number;\r\n  first_name: string;\r\n  last_name?: string;\r\n  username?: string;\r\n  language_code?: string;\r\n  photo_url?: string;\r\n}\r\n\r\ntype InvoiceStatus = 'paid' | 'cancelled' | 'failed' | 'pending';\r\n\r\ninterface TelegramWebApp {\r\n  initData: string;\r\n  initDataUnsafe: {\r\n    user?: TelegramUser;\r\n    query_id?: string;\r\n    auth_date?: number;\r\n    hash?: string;\r\n    start_param?: string;\r\n  };\r\n  version: string;\r\n  platform: string;\r\n  colorScheme: 'light' | 'dark';\r\n  themeParams: Record<string, string>;\r\n  isExpanded: boolean;\r\n  viewportHeight: number;\r\n  viewportStableHeight: number;\r\n  MainButton: {\r\n    text: string;\r\n    color: string;\r\n    textColor: string;\r\n    isVisible: boolean;\r\n    isActive: boolean;\r\n    setText: (text: string) => void;\r\n    onClick: (callback: () => void) => void;\r\n    offClick: (callback: () => void) => void;\r\n    show: () => void;\r\n    hide: () => void;\r\n    enable: () => void;\r\n    disable: () => void;\r\n  };\r\n  BackButton: {\r\n    isVisible: boolean;\r\n    onClick: (callback: () => void) => void;\r\n    offClick: (callback: () => void) => void;\r\n    show: () => void;\r\n    hide: () => void;\r\n  };\r\n  HapticFeedback: {\r\n    impactOccurred: (style: 'light' | 'medium' | 'heavy' | 'rigid' | 'soft') => void;\r\n    notificationOccurred: (type: 'error' | 'success' | 'warning') => void;\r\n    selectionChanged: () => void;\r\n  };\r\n  openInvoice: (url: string, callback?: (status: InvoiceStatus) => void) => void;\r\n  showAlert: (message: string, callback?: () => void) => void;\r\n  showConfirm: (message: string, callback?: (confirmed: boolean) => void) => void;\r\n  ready: () => void;\r\n  expand: () => void;\r\n  close: () => void;\r\n}\r\n\r\nexport function getTelegramWebApp(): TelegramWebApp | null {\r\n  if (typeof window !== 'undefined' && window.Telegram?.WebApp) {\r\n    return window.Telegram.WebApp;\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function getTelegramUser(): TelegramUser | null {\r\n  const webApp = getTelegramWebApp();\r\n  if (webApp?.initDataUnsafe?.user) {\r\n    return webApp.initDataUnsafe.user;\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function initTelegramApp(): void {\r\n  const webApp = getTelegramWebApp();\r\n  if (webApp) {\r\n    webApp.ready();\r\n    webApp.expand();\r\n  }\r\n}\r\n\r\nexport function hapticFeedback(type: 'light' | 'medium' | 'heavy' | 'success' | 'error' | 'warning' | 'selection'): void {\r\n  const webApp = getTelegramWebApp();\r\n  if (webApp?.HapticFeedback) {\r\n    if (type === 'selection') {\r\n      webApp.HapticFeedback.selectionChanged();\r\n    } else if (['success', 'error', 'warning'].includes(type)) {\r\n      webApp.HapticFeedback.notificationOccurred(type as 'success' | 'error' | 'warning');\r\n    } else {\r\n      webApp.HapticFeedback.impactOccurred(type as 'light' | 'medium' | 'heavy');\r\n    }\r\n  }\r\n}\r\n\r\nexport function isTelegramWebApp(): boolean {\r\n  return getTelegramWebApp() !== null;\r\n}\r\n\r\nexport function openTelegramInvoice(\r\n  invoiceUrl: string, \r\n  callback?: (status: InvoiceStatus) => void\r\n): boolean {\r\n  const webApp = getTelegramWebApp();\r\n  if (webApp?.openInvoice) {\r\n    webApp.openInvoice(invoiceUrl, callback);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function showTelegramAlert(message: string, callback?: () => void): boolean {\r\n  const webApp = getTelegramWebApp();\r\n  if (webApp?.showAlert) {\r\n    webApp.showAlert(message, callback);\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport type { InvoiceStatus };\r\n\r\nexport function getStartParam(): string | null {\r\n  // First try Telegram's native start_param (works for direct Mini App links)\r\n  const webApp = getTelegramWebApp();\r\n  if (webApp?.initDataUnsafe?.start_param) {\r\n    return webApp.initDataUnsafe.start_param;\r\n  }\r\n  \r\n  // Fallback: check URL hash for referral code (works for web_app button)\r\n  // Format: #ref=REFERRAL_CODE\r\n  if (typeof window !== 'undefined' && window.location.hash) {\r\n    const hash = window.location.hash.substring(1); // Remove #\r\n    const params = new URLSearchParams(hash);\r\n    const refCode = params.get('ref');\r\n    if (refCode) {\r\n      return refCode;\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAqEO,SAAS;IACd,IAAI,kDAAkB,eAAe,OAAO,QAAQ,EAAE;;IAGtD,OAAO;AACT;AAEO,SAAS;IACd,MAAM,SAAS;IACf,IAAI,QAAQ,gBAAgB,MAAM;QAChC,OAAO,OAAO,cAAc,CAAC,IAAI;IACnC;IACA,OAAO;AACT;AAEO,SAAS;IACd,MAAM,SAAS;IACf,IAAI,QAAQ;QACV,OAAO,KAAK;QACZ,OAAO,MAAM;IACf;AACF;AAEO,SAAS,eAAe,IAAkF;IAC/G,MAAM,SAAS;IACf,IAAI,QAAQ,gBAAgB;QAC1B,IAAI,SAAS,aAAa;YACxB,OAAO,cAAc,CAAC,gBAAgB;QACxC,OAAO,IAAI;YAAC;YAAW;YAAS;SAAU,CAAC,QAAQ,CAAC,OAAO;YACzD,OAAO,cAAc,CAAC,oBAAoB,CAAC;QAC7C,OAAO;YACL,OAAO,cAAc,CAAC,cAAc,CAAC;QACvC;IACF;AACF;AAEO,SAAS;IACd,OAAO,wBAAwB;AACjC;AAEO,SAAS,oBACd,UAAkB,EAClB,QAA0C;IAE1C,MAAM,SAAS;IACf,IAAI,QAAQ,aAAa;QACvB,OAAO,WAAW,CAAC,YAAY;QAC/B,OAAO;IACT;IACA,OAAO;AACT;AAEO,SAAS,kBAAkB,OAAe,EAAE,QAAqB;IACtE,MAAM,SAAS;IACf,IAAI,QAAQ,WAAW;QACrB,OAAO,SAAS,CAAC,SAAS;QAC1B,OAAO;IACT;IACA,OAAO;AACT;AAIO,SAAS;IACd,4EAA4E;IAC5E,MAAM,SAAS;IACf,IAAI,QAAQ,gBAAgB,aAAa;QACvC,OAAO,OAAO,cAAc,CAAC,WAAW;IAC1C;IAEA,wEAAwE;IACxE,6BAA6B;IAC7B;;IASA,OAAO;AACT"}},
    {"offset": {"line": 186, "column": 0}, "map": {"version":3,"sources":["file:///D:/BeadsLine/lib/sounds.ts"],"sourcesContent":["// Звуковые эффекты для игры Beads Line\r\n// Используем Web Audio API для генерации звуков без внешних файлов\r\n\r\nlet audioContext: AudioContext | null = null;\r\nlet soundEnabled: boolean | null = null;\r\n\r\nfunction getAudioContext(): AudioContext | null {\r\n  if (!audioContext) {\r\n    try {\r\n      audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n    } catch (e) {\r\n      console.warn('Web Audio API not supported');\r\n      return null;\r\n    }\r\n  }\r\n  if (audioContext && audioContext.state === 'suspended') {\r\n    audioContext.resume().catch(() => {});\r\n  }\r\n  return audioContext;\r\n}\r\n\r\n// Включить/выключить звуки\r\nexport function setSoundEnabled(enabled: boolean) {\r\n  soundEnabled = enabled;\r\n  if (typeof localStorage !== 'undefined') {\r\n    localStorage.setItem('beads_sound_enabled', String(enabled));\r\n  }\r\n}\r\n\r\nexport function isSoundEnabled(): boolean {\r\n  if (soundEnabled === null) {\r\n    if (typeof localStorage !== 'undefined') {\r\n      const saved = localStorage.getItem('beads_sound_enabled');\r\n      soundEnabled = saved !== null ? saved === 'true' : true;\r\n    } else {\r\n      soundEnabled = true;\r\n    }\r\n  }\r\n  return soundEnabled;\r\n}\r\n\r\n// Генерация звука выстрела\r\nexport function playShootSound() {\r\n  if (!soundEnabled) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  const oscillator = ctx.createOscillator();\r\n  const gainNode = ctx.createGain();\r\n  \r\n  oscillator.connect(gainNode);\r\n  gainNode.connect(ctx.destination);\r\n  \r\n  oscillator.frequency.setValueAtTime(400, ctx.currentTime);\r\n  oscillator.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.1);\r\n  oscillator.type = 'sine';\r\n  \r\n  gainNode.gain.setValueAtTime(0.15, ctx.currentTime);\r\n  gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);\r\n  \r\n  oscillator.start(ctx.currentTime);\r\n  oscillator.stop(ctx.currentTime + 0.1);\r\n}\r\n\r\n// Генерация звука попадания/вставки\r\nexport function playInsertSound() {\r\n  if (!soundEnabled) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  const oscillator = ctx.createOscillator();\r\n  const gainNode = ctx.createGain();\r\n  \r\n  oscillator.connect(gainNode);\r\n  gainNode.connect(ctx.destination);\r\n  \r\n  oscillator.frequency.setValueAtTime(600, ctx.currentTime);\r\n  oscillator.type = 'sine';\r\n  \r\n  gainNode.gain.setValueAtTime(0.1, ctx.currentTime);\r\n  gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);\r\n  \r\n  oscillator.start(ctx.currentTime);\r\n  oscillator.stop(ctx.currentTime + 0.05);\r\n}\r\n\r\n// Генерация звука уничтожения шариков (match)\r\nexport function playMatchSound(comboLevel: number = 1) {\r\n  if (!soundEnabled) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  const baseFreq = 500 + (comboLevel * 100);\r\n  \r\n  const oscillator = ctx.createOscillator();\r\n  const gainNode = ctx.createGain();\r\n  \r\n  oscillator.connect(gainNode);\r\n  gainNode.connect(ctx.destination);\r\n  \r\n  oscillator.frequency.setValueAtTime(baseFreq, ctx.currentTime);\r\n  oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 1.5, ctx.currentTime + 0.15);\r\n  oscillator.type = 'triangle';\r\n  \r\n  gainNode.gain.setValueAtTime(0.2, ctx.currentTime);\r\n  gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);\r\n  \r\n  oscillator.start(ctx.currentTime);\r\n  oscillator.stop(ctx.currentTime + 0.2);\r\n}\r\n\r\n// Генерация звука крипто-шарика\r\nexport function playCryptoMatchSound() {\r\n  if (!soundEnabled) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  // Более яркий звук для крипто\r\n  const osc1 = ctx.createOscillator();\r\n  const osc2 = ctx.createOscillator();\r\n  const gainNode = ctx.createGain();\r\n  \r\n  osc1.connect(gainNode);\r\n  osc2.connect(gainNode);\r\n  gainNode.connect(ctx.destination);\r\n  \r\n  osc1.frequency.setValueAtTime(800, ctx.currentTime);\r\n  osc1.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.2);\r\n  osc1.type = 'sine';\r\n  \r\n  osc2.frequency.setValueAtTime(1000, ctx.currentTime);\r\n  osc2.frequency.exponentialRampToValueAtTime(1500, ctx.currentTime + 0.2);\r\n  osc2.type = 'sine';\r\n  \r\n  gainNode.gain.setValueAtTime(0.15, ctx.currentTime);\r\n  gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);\r\n  \r\n  osc1.start(ctx.currentTime);\r\n  osc2.start(ctx.currentTime);\r\n  osc1.stop(ctx.currentTime + 0.3);\r\n  osc2.stop(ctx.currentTime + 0.3);\r\n}\r\n\r\n// Генерация звука комбо\r\nexport function playComboSound(comboLevel: number) {\r\n  if (!soundEnabled) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  const frequencies = [523.25, 659.25, 783.99, 1046.5]; // C5, E5, G5, C6\r\n  const numNotes = Math.min(comboLevel, frequencies.length);\r\n  \r\n  for (let i = 0; i < numNotes; i++) {\r\n    const oscillator = ctx.createOscillator();\r\n    const gainNode = ctx.createGain();\r\n    \r\n    oscillator.connect(gainNode);\r\n    gainNode.connect(ctx.destination);\r\n    \r\n    const startTime = ctx.currentTime + (i * 0.08);\r\n    oscillator.frequency.setValueAtTime(frequencies[i], startTime);\r\n    oscillator.type = 'sine';\r\n    \r\n    gainNode.gain.setValueAtTime(0.12, startTime);\r\n    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + 0.15);\r\n    \r\n    oscillator.start(startTime);\r\n    oscillator.stop(startTime + 0.15);\r\n  }\r\n}\r\n\r\n// Генерация звука потери жизни\r\nexport function playLifeLostSound() {\r\n  if (!soundEnabled) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  const oscillator = ctx.createOscillator();\r\n  const gainNode = ctx.createGain();\r\n  \r\n  oscillator.connect(gainNode);\r\n  gainNode.connect(ctx.destination);\r\n  \r\n  oscillator.frequency.setValueAtTime(300, ctx.currentTime);\r\n  oscillator.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.3);\r\n  oscillator.type = 'sawtooth';\r\n  \r\n  gainNode.gain.setValueAtTime(0.2, ctx.currentTime);\r\n  gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);\r\n  \r\n  oscillator.start(ctx.currentTime);\r\n  oscillator.stop(ctx.currentTime + 0.4);\r\n}\r\n\r\n// Генерация звука победы (фанфары)\r\nexport function playWinSound() {\r\n  if (!soundEnabled) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  // Fanfare melody - triumphant brass-like sound\r\n  const fanfare = [\r\n    { freq: 523.25, delay: 0, duration: 0.15 },      // C5\r\n    { freq: 523.25, delay: 0.15, duration: 0.15 },   // C5\r\n    { freq: 523.25, delay: 0.3, duration: 0.15 },    // C5\r\n    { freq: 659.25, delay: 0.5, duration: 0.3 },     // E5\r\n    { freq: 523.25, delay: 0.85, duration: 0.15 },   // C5\r\n    { freq: 659.25, delay: 1.05, duration: 0.15 },   // E5\r\n    { freq: 783.99, delay: 1.25, duration: 0.6 },    // G5 (long)\r\n  ];\r\n  \r\n  fanfare.forEach(({ freq, delay, duration }) => {\r\n    // Main tone\r\n    const osc1 = ctx.createOscillator();\r\n    const gain1 = ctx.createGain();\r\n    osc1.connect(gain1);\r\n    gain1.connect(ctx.destination);\r\n    \r\n    const startTime = ctx.currentTime + delay;\r\n    osc1.frequency.setValueAtTime(freq, startTime);\r\n    osc1.type = 'triangle';\r\n    \r\n    gain1.gain.setValueAtTime(0.25, startTime);\r\n    gain1.gain.exponentialRampToValueAtTime(0.01, startTime + duration);\r\n    \r\n    osc1.start(startTime);\r\n    osc1.stop(startTime + duration);\r\n    \r\n    // Harmonic for brass-like sound\r\n    const osc2 = ctx.createOscillator();\r\n    const gain2 = ctx.createGain();\r\n    osc2.connect(gain2);\r\n    gain2.connect(ctx.destination);\r\n    \r\n    osc2.frequency.setValueAtTime(freq * 2, startTime);\r\n    osc2.type = 'sine';\r\n    \r\n    gain2.gain.setValueAtTime(0.1, startTime);\r\n    gain2.gain.exponentialRampToValueAtTime(0.01, startTime + duration * 0.8);\r\n    \r\n    osc2.start(startTime);\r\n    osc2.stop(startTime + duration);\r\n  });\r\n  \r\n  // Final chord flourish\r\n  const chordNotes = [523.25, 659.25, 783.99, 1046.5]; // C major chord\r\n  chordNotes.forEach((freq) => {\r\n    const osc = ctx.createOscillator();\r\n    const gain = ctx.createGain();\r\n    osc.connect(gain);\r\n    gain.connect(ctx.destination);\r\n    \r\n    const startTime = ctx.currentTime + 1.9;\r\n    osc.frequency.setValueAtTime(freq, startTime);\r\n    osc.type = 'sine';\r\n    \r\n    gain.gain.setValueAtTime(0.15, startTime);\r\n    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.8);\r\n    \r\n    osc.start(startTime);\r\n    osc.stop(startTime + 0.8);\r\n  });\r\n}\r\n\r\n// Генерация звука проигрыша\r\nexport function playGameOverSound() {\r\n  if (!soundEnabled) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  const oscillator = ctx.createOscillator();\r\n  const gainNode = ctx.createGain();\r\n  \r\n  oscillator.connect(gainNode);\r\n  gainNode.connect(ctx.destination);\r\n  \r\n  oscillator.frequency.setValueAtTime(200, ctx.currentTime);\r\n  oscillator.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.6);\r\n  oscillator.type = 'sawtooth';\r\n  \r\n  gainNode.gain.setValueAtTime(0.2, ctx.currentTime);\r\n  gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.6);\r\n  \r\n  oscillator.start(ctx.currentTime);\r\n  oscillator.stop(ctx.currentTime + 0.6);\r\n}\r\n\r\n// Звук активации замедления (плавное понижение тона)\r\nexport function playSlowdownSound() {\r\n  if (!isSoundEnabled()) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  const osc = ctx.createOscillator();\r\n  const gain = ctx.createGain();\r\n  osc.connect(gain);\r\n  gain.connect(ctx.destination);\r\n  \r\n  osc.frequency.setValueAtTime(800, ctx.currentTime);\r\n  osc.frequency.exponentialRampToValueAtTime(200, ctx.currentTime + 0.4);\r\n  osc.type = 'sine';\r\n  \r\n  gain.gain.setValueAtTime(0.2, ctx.currentTime);\r\n  gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);\r\n  \r\n  osc.start(ctx.currentTime);\r\n  osc.stop(ctx.currentTime + 0.5);\r\n}\r\n\r\n// Звук активации бомбы (глухой взрыв)\r\nexport function playBombSound() {\r\n  if (!isSoundEnabled()) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  const osc = ctx.createOscillator();\r\n  const gain = ctx.createGain();\r\n  osc.connect(gain);\r\n  gain.connect(ctx.destination);\r\n  \r\n  osc.frequency.setValueAtTime(150, ctx.currentTime);\r\n  osc.frequency.exponentialRampToValueAtTime(40, ctx.currentTime + 0.3);\r\n  osc.type = 'sawtooth';\r\n  \r\n  gain.gain.setValueAtTime(0.3, ctx.currentTime);\r\n  gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.35);\r\n  \r\n  osc.start(ctx.currentTime);\r\n  osc.stop(ctx.currentTime + 0.35);\r\n\r\n  const noise = ctx.createOscillator();\r\n  const noiseGain = ctx.createGain();\r\n  noise.connect(noiseGain);\r\n  noiseGain.connect(ctx.destination);\r\n  noise.frequency.setValueAtTime(80, ctx.currentTime);\r\n  noise.type = 'square';\r\n  noiseGain.gain.setValueAtTime(0.15, ctx.currentTime);\r\n  noiseGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);\r\n  noise.start(ctx.currentTime);\r\n  noise.stop(ctx.currentTime + 0.2);\r\n}\r\n\r\n// Звук активации радуги (переливающаяся арпеджио)\r\nexport function playRainbowSound() {\r\n  if (!isSoundEnabled()) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  const notes = [523.25, 587.33, 659.25, 783.99, 880]; // C5-A5\r\n  notes.forEach((freq, i) => {\r\n    const osc = ctx.createOscillator();\r\n    const gain = ctx.createGain();\r\n    osc.connect(gain);\r\n    gain.connect(ctx.destination);\r\n    \r\n    const startTime = ctx.currentTime + i * 0.05;\r\n    osc.frequency.setValueAtTime(freq, startTime);\r\n    osc.type = 'sine';\r\n    \r\n    gain.gain.setValueAtTime(0.12, startTime);\r\n    gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);\r\n    \r\n    osc.start(startTime);\r\n    osc.stop(startTime + 0.2);\r\n  });\r\n}\r\n\r\n// Звук активации отката (обратный свист)\r\nexport function playRewindSound() {\r\n  if (!isSoundEnabled()) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  const osc = ctx.createOscillator();\r\n  const gain = ctx.createGain();\r\n  osc.connect(gain);\r\n  gain.connect(ctx.destination);\r\n  \r\n  osc.frequency.setValueAtTime(300, ctx.currentTime);\r\n  osc.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.25);\r\n  osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.4);\r\n  osc.type = 'triangle';\r\n  \r\n  gain.gain.setValueAtTime(0.2, ctx.currentTime);\r\n  gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.45);\r\n  \r\n  osc.start(ctx.currentTime);\r\n  osc.stop(ctx.currentTime + 0.45);\r\n}\r\n\r\n// Звук активации щита (металлический звон)\r\nexport function playShieldSound() {\r\n  if (!isSoundEnabled()) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  const osc1 = ctx.createOscillator();\r\n  const osc2 = ctx.createOscillator();\r\n  const gain = ctx.createGain();\r\n  osc1.connect(gain);\r\n  osc2.connect(gain);\r\n  gain.connect(ctx.destination);\r\n  \r\n  osc1.frequency.setValueAtTime(1200, ctx.currentTime);\r\n  osc1.type = 'sine';\r\n  osc2.frequency.setValueAtTime(1800, ctx.currentTime);\r\n  osc2.type = 'sine';\r\n  \r\n  gain.gain.setValueAtTime(0.15, ctx.currentTime);\r\n  gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);\r\n  \r\n  osc1.start(ctx.currentTime);\r\n  osc2.start(ctx.currentTime);\r\n  osc1.stop(ctx.currentTime + 0.4);\r\n  osc2.stop(ctx.currentTime + 0.4);\r\n}\r\n\r\n// Звук активации магнита (притягивающий гул)\r\nexport function playMagnetSound() {\r\n  if (!isSoundEnabled()) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  const osc = ctx.createOscillator();\r\n  const gain = ctx.createGain();\r\n  osc.connect(gain);\r\n  gain.connect(ctx.destination);\r\n  \r\n  osc.frequency.setValueAtTime(100, ctx.currentTime);\r\n  osc.frequency.linearRampToValueAtTime(400, ctx.currentTime + 0.3);\r\n  osc.type = 'sawtooth';\r\n  \r\n  gain.gain.setValueAtTime(0.15, ctx.currentTime);\r\n  gain.gain.setValueAtTime(0.2, ctx.currentTime + 0.15);\r\n  gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);\r\n  \r\n  osc.start(ctx.currentTime);\r\n  osc.stop(ctx.currentTime + 0.4);\r\n}\r\n\r\n// Звук активации лазера (высокочастотный луч)\r\nexport function playLaserSound() {\r\n  if (!isSoundEnabled()) return;\r\n  const ctx = getAudioContext();\r\n  if (!ctx) return;\r\n\r\n  const osc = ctx.createOscillator();\r\n  const gain = ctx.createGain();\r\n  osc.connect(gain);\r\n  gain.connect(ctx.destination);\r\n  \r\n  osc.frequency.setValueAtTime(2000, ctx.currentTime);\r\n  osc.frequency.exponentialRampToValueAtTime(500, ctx.currentTime + 0.15);\r\n  osc.type = 'square';\r\n  \r\n  gain.gain.setValueAtTime(0.12, ctx.currentTime);\r\n  gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);\r\n  \r\n  osc.start(ctx.currentTime);\r\n  osc.stop(ctx.currentTime + 0.2);\r\n}\r\n\r\n// Инициализация звуков (вызывать при первом взаимодействии пользователя)\r\nlet initialized = false;\r\nexport function initSounds() {\r\n  if (initialized) return;\r\n  initialized = true;\r\n  isSoundEnabled();\r\n  getAudioContext();\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 626, "column": 0}, "map": {"version":3,"sources":["file:///D:/BeadsLine/lib/gameConfig.ts"],"sourcesContent":["export const GAME_CONFIG = {\r\n  path: {\r\n    type: 'spiral' as const,\r\n    segments: 600,\r\n    spiralTurns: 3.0,\r\n    outerRadius: 0.42,\r\n    innerRadius: 0.15,\r\n  },\r\n  \r\n  balls: {\r\n    radius: 14,\r\n    spacing: 0.024,\r\n    initialCount: 5,\r\n    targetCount: 50,\r\n    shooterSpeed: 18,\r\n    collisionRadius: 2.2,\r\n  },\r\n  \r\n  spawn: {\r\n    period: 1800,\r\n    buffer: 0.012,\r\n    resumeThreshold: 35,\r\n  },\r\n  \r\n  speed: {\r\n    base: 0.010,\r\n    max: 0.016,\r\n    accelerationStart: 0.8,\r\n  },\r\n  \r\n  gameplay: {\r\n    maxTotalBalls: 60,\r\n    addBallsInterval: 4000,\r\n    addBallsCount: 3,\r\n  },\r\n  \r\n  crypto: {\r\n    dropRate: 0.08,\r\n    points: {\r\n      btc: 500,\r\n      eth: 300,\r\n      usdt: 200,\r\n    },\r\n  },\r\n  \r\n  scoring: {\r\n    basePoints: 100,\r\n    comboMultiplier: 1.5,\r\n    maxComboStack: 10,\r\n  },\r\n};\r\n\r\nexport function calculateDynamicSpeed(pathProgress: number): number {\r\n  const { base, max, accelerationStart } = GAME_CONFIG.speed;\r\n  \r\n  const clampedProgress = Math.max(0, Math.min(1, pathProgress));\r\n  \r\n  if (clampedProgress < accelerationStart) {\r\n    return base;\r\n  }\r\n  \r\n  const accelerationProgress = (clampedProgress - accelerationStart) / (1 - accelerationStart);\r\n  const speed = base + (max - base) * accelerationProgress;\r\n  \r\n  return Math.min(speed, max);\r\n}\r\n\r\nexport type GameConfig = typeof GAME_CONFIG;\r\n"],"names":[],"mappings":";;;;;;AAAO,MAAM,cAAc;IACzB,MAAM;QACJ,MAAM;QACN,UAAU;QACV,aAAa;QACb,aAAa;QACb,aAAa;IACf;IAEA,OAAO;QACL,QAAQ;QACR,SAAS;QACT,cAAc;QACd,aAAa;QACb,cAAc;QACd,iBAAiB;IACnB;IAEA,OAAO;QACL,QAAQ;QACR,QAAQ;QACR,iBAAiB;IACnB;IAEA,OAAO;QACL,MAAM;QACN,KAAK;QACL,mBAAmB;IACrB;IAEA,UAAU;QACR,eAAe;QACf,kBAAkB;QAClB,eAAe;IACjB;IAEA,QAAQ;QACN,UAAU;QACV,QAAQ;YACN,KAAK;YACL,KAAK;YACL,MAAM;QACR;IACF;IAEA,SAAS;QACP,YAAY;QACZ,iBAAiB;QACjB,eAAe;IACjB;AACF;AAEO,SAAS,sBAAsB,YAAoB;IACxD,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,iBAAiB,EAAE,GAAG,YAAY,KAAK;IAE1D,MAAM,kBAAkB,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,CAAC,GAAG;IAEhD,IAAI,kBAAkB,mBAAmB;QACvC,OAAO;IACT;IAEA,MAAM,uBAAuB,CAAC,kBAAkB,iBAAiB,IAAI,CAAC,IAAI,iBAAiB;IAC3F,MAAM,QAAQ,OAAO,CAAC,MAAM,IAAI,IAAI;IAEpC,OAAO,KAAK,GAAG,CAAC,OAAO;AACzB"}},
    {"offset": {"line": 691, "column": 0}, "map": {"version":3,"sources":["file:///D:/BeadsLine/lib/gameEngine.ts"],"sourcesContent":["import type { Ball, BallColor, CryptoType, GameState, GameEconomyConfig, GameplayConfig } from \"@shared/schema\";\r\nimport { GAME_CONFIG, calculateDynamicSpeed } from \"./gameConfig\";\r\nimport type { LevelConfig, LevelPath } from \"./levelConfig\";\r\n\r\nexport const DEBUG_GAME_LOGIC = true;\r\nconst MAX_DEBUG_LOGS = 200;\r\n\r\nexport const debugLogs: string[] = [];\r\nlet pendingLogs: string[] = [];\r\nlet operationCounter = 0;\r\n\r\nexport function getNextOperationId(): number {\r\n  return ++operationCounter;\r\n}\r\nlet flushTimeout: ReturnType<typeof setTimeout> | null = null;\r\n\r\nfunction flushLogsToServer() {\r\n  if (pendingLogs.length === 0) return;\r\n  \r\n  const logsToSend = [...pendingLogs];\r\n  pendingLogs = [];\r\n  \r\n  fetch('/api/debug-logs', {\r\n    method: 'POST',\r\n    headers: { 'Content-Type': 'application/json' },\r\n    body: JSON.stringify({ logs: logsToSend }),\r\n  }).catch(() => {});\r\n}\r\n\r\nexport function debugLog(...args: unknown[]) {\r\n  if (DEBUG_GAME_LOGIC) {\r\n    const msg = `[${new Date().toLocaleTimeString()}] ` + args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');\r\n    debugLogs.push(msg);\r\n    if (debugLogs.length > MAX_DEBUG_LOGS) {\r\n      debugLogs.shift();\r\n    }\r\n    \r\n    pendingLogs.push(msg);\r\n    \r\n    if (flushTimeout) clearTimeout(flushTimeout);\r\n    flushTimeout = setTimeout(flushLogsToServer, 100);\r\n    \r\n    console.log('[GAME]', ...args);\r\n  }\r\n}\r\n\r\nexport function clearDebugLogs() {\r\n  debugLogs.length = 0;\r\n}\r\n\r\nexport function getDebugLogs(): string[] {\r\n  return [...debugLogs];\r\n}\r\n\r\nconst BALL_RADIUS = GAME_CONFIG.balls.radius;\r\nconst SHOOTER_BALL_SPEED = GAME_CONFIG.balls.shooterSpeed;\r\nconst COLLISION_RADIUS_MULTIPLIER = GAME_CONFIG.balls.collisionRadius;\r\n\r\nconst ALL_BALL_COLORS: BallColor[] = ['red', 'blue', 'green', 'yellow', 'purple', 'cyan', 'magenta', 'amber', 'lime', 'violet'];\r\nconst CRYPTO_TYPES: CryptoType[] = ['btc', 'eth', 'usdt'];\r\n\r\nconst DEFAULT_GAMEPLAY: GameplayConfig = {\r\n  balls: { initialCount: 5, targetCount: 50, maxTotalBalls: 60 },\r\n  spawn: { period: 1800, resumeThreshold: 35 },\r\n  speed: { base: 0.010, max: 0.016, accelerationStart: 0.8 },\r\n  colors: { count: 5 },\r\n};\r\n\r\nlet currentGameplay: GameplayConfig = DEFAULT_GAMEPLAY;\r\n\r\nexport function setGameplayConfig(config: Partial<GameplayConfig>) {\r\n  const defaults = DEFAULT_GAMEPLAY;\r\n  currentGameplay = {\r\n    balls: {\r\n      initialCount: config.balls?.initialCount ?? defaults.balls.initialCount,\r\n      targetCount: config.balls?.targetCount ?? defaults.balls.targetCount,\r\n      maxTotalBalls: config.balls?.maxTotalBalls ?? defaults.balls.maxTotalBalls,\r\n    },\r\n    spawn: {\r\n      period: config.spawn?.period ?? defaults.spawn.period,\r\n      resumeThreshold: config.spawn?.resumeThreshold ?? defaults.spawn.resumeThreshold,\r\n    },\r\n    speed: {\r\n      base: config.speed?.base ?? defaults.speed.base,\r\n      max: config.speed?.max ?? defaults.speed.max,\r\n      accelerationStart: config.speed?.accelerationStart ?? defaults.speed.accelerationStart,\r\n    },\r\n    colors: {\r\n      count: config.colors?.count ?? defaults.colors.count,\r\n      activeColors: config.colors?.activeColors,\r\n    },\r\n  };\r\n}\r\n\r\nexport function getGameplayConfig(): GameplayConfig {\r\n  return currentGameplay;\r\n}\r\n\r\nfunction getActiveBallColors(): BallColor[] {\r\n  if (currentGameplay.colors.activeColors && currentGameplay.colors.activeColors.length >= 2) {\r\n    const filtered = currentGameplay.colors.activeColors.filter(c => \r\n      ALL_BALL_COLORS.includes(c as BallColor)\r\n    ) as BallColor[];\r\n    if (filtered.length >= 2) {\r\n      return filtered;\r\n    }\r\n  }\r\n  const count = Math.max(2, Math.min(10, currentGameplay.colors.count));\r\n  return ALL_BALL_COLORS.slice(0, count);\r\n}\r\n\r\nconst DEFAULT_ECONOMY: GameEconomyConfig = {\r\n  points: { normal: 5, btc: 500, eth: 300, usdt: 200 },\r\n  combo: { multiplier: 1.5, maxChain: 10 },\r\n  crypto: { spawnChance: 0.08 },\r\n  cryptoRewards: { btcPerBall: 0.00000005, ethPerBall: 0.0000001, usdtPerBall: 0.01 },\r\n  dailyLimits: { btcMaxSatsPerDay: 300, ethMaxWeiPerDay: 3000000000000000, usdtMaxPerDay: 3.0 },\r\n  pools: { btcBalanceSats: 100000, ethBalanceWei: 1000000000000000, usdtBalance: 100 },\r\n  perGameLimits: { btcMaxBeadsPerGame: 15, ethMaxBeadsPerGame: 15, usdtMaxBeadsPerGame: 15 },\r\n};\r\n\r\nlet currentEconomy: GameEconomyConfig = DEFAULT_ECONOMY;\r\n\r\nfunction toNumber(val: string | number | undefined, fallback: number): number {\r\n  if (val === undefined || val === null) return fallback;\r\n  const num = typeof val === 'string' ? parseFloat(val) : val;\r\n  return isNaN(num) ? fallback : num;\r\n}\r\n\r\nexport function setEconomyConfig(config: Partial<GameEconomyConfig>) {\r\n  const defaults = DEFAULT_ECONOMY;\r\n  currentEconomy = {\r\n    points: {\r\n      normal: toNumber(config.points?.normal, defaults.points.normal),\r\n      btc: toNumber(config.points?.btc, defaults.points.btc),\r\n      eth: toNumber(config.points?.eth, defaults.points.eth),\r\n      usdt: toNumber(config.points?.usdt, defaults.points.usdt),\r\n    },\r\n    combo: {\r\n      multiplier: toNumber(config.combo?.multiplier, defaults.combo.multiplier),\r\n      maxChain: toNumber(config.combo?.maxChain, defaults.combo.maxChain),\r\n    },\r\n    crypto: {\r\n      spawnChance: toNumber(config.crypto?.spawnChance, defaults.crypto.spawnChance),\r\n    },\r\n    cryptoRewards: {\r\n      btcPerBall: toNumber(config.cryptoRewards?.btcPerBall, defaults.cryptoRewards.btcPerBall),\r\n      ethPerBall: toNumber(config.cryptoRewards?.ethPerBall, defaults.cryptoRewards.ethPerBall),\r\n      usdtPerBall: toNumber(config.cryptoRewards?.usdtPerBall, defaults.cryptoRewards.usdtPerBall),\r\n    },\r\n    dailyLimits: {\r\n      btcMaxSatsPerDay: toNumber(config.dailyLimits?.btcMaxSatsPerDay, defaults.dailyLimits.btcMaxSatsPerDay),\r\n      ethMaxWeiPerDay: toNumber(config.dailyLimits?.ethMaxWeiPerDay, defaults.dailyLimits.ethMaxWeiPerDay),\r\n      usdtMaxPerDay: toNumber(config.dailyLimits?.usdtMaxPerDay, defaults.dailyLimits.usdtMaxPerDay),\r\n    },\r\n    pools: {\r\n      btcBalanceSats: toNumber(config.pools?.btcBalanceSats, defaults.pools.btcBalanceSats),\r\n      ethBalanceWei: toNumber(config.pools?.ethBalanceWei, defaults.pools.ethBalanceWei),\r\n      usdtBalance: toNumber(config.pools?.usdtBalance, defaults.pools.usdtBalance),\r\n    },\r\n    perGameLimits: {\r\n      btcMaxBeadsPerGame: toNumber(config.perGameLimits?.btcMaxBeadsPerGame, defaults.perGameLimits.btcMaxBeadsPerGame),\r\n      ethMaxBeadsPerGame: toNumber(config.perGameLimits?.ethMaxBeadsPerGame, defaults.perGameLimits.ethMaxBeadsPerGame),\r\n      usdtMaxBeadsPerGame: toNumber(config.perGameLimits?.usdtMaxBeadsPerGame, defaults.perGameLimits.usdtMaxBeadsPerGame),\r\n    },\r\n  };\r\n}\r\n\r\nexport function getEconomyConfig(): GameEconomyConfig {\r\n  return currentEconomy;\r\n}\r\n\r\n// ========== BOOST SYSTEM ==========\r\nexport type BoostType = 'slowdown' | 'bomb' | 'rainbow' | 'rewind' | 'shield' | 'magnet' | 'laser';\r\n\r\ninterface ActiveBoostState {\r\n  slowdownActive: boolean;\r\n  slowdownEndTime: number;\r\n  slowdownMultiplier: number;\r\n  rainbowActive: boolean;\r\n  pendingBomb: boolean;\r\n  pendingRewind: boolean;\r\n  shieldActive: boolean;\r\n  magnetActive: boolean;\r\n  magnetRadius: number;\r\n  pendingLaser: boolean;\r\n  laserPierceCount: number;\r\n}\r\n\r\nlet boostState: ActiveBoostState = {\r\n  slowdownActive: false,\r\n  slowdownEndTime: 0,\r\n  slowdownMultiplier: 1.0,\r\n  rainbowActive: false,\r\n  pendingBomb: false,\r\n  pendingRewind: false,\r\n  shieldActive: false,\r\n  magnetActive: false,\r\n  magnetRadius: 0,\r\n  pendingLaser: false,\r\n  laserPierceCount: 0,\r\n};\r\n\r\nexport function resetBoostState() {\r\n  boostState = {\r\n    slowdownActive: false,\r\n    slowdownEndTime: 0,\r\n    slowdownMultiplier: 1.0,\r\n    rainbowActive: false,\r\n    pendingBomb: false,\r\n    pendingRewind: false,\r\n    shieldActive: false,\r\n    magnetActive: false,\r\n    magnetRadius: 0,\r\n    pendingLaser: false,\r\n    laserPierceCount: 0,\r\n  };\r\n  debugLog('[BOOST] State reset');\r\n}\r\n\r\nexport function getBoostState(): ActiveBoostState {\r\n  return { ...boostState };\r\n}\r\n\r\nexport function activateSlowdown(durationMs: number, multiplier: number = 0.5) {\r\n  boostState.slowdownActive = true;\r\n  boostState.slowdownEndTime = Date.now() + durationMs;\r\n  boostState.slowdownMultiplier = multiplier;\r\n  debugLog(`[BOOST] Slowdown activated: ${durationMs}ms, multiplier=${multiplier}`);\r\n}\r\n\r\nexport function activateRainbow() {\r\n  boostState.rainbowActive = true;\r\n  debugLog('[BOOST] Rainbow activated - next ball is wild');\r\n}\r\n\r\nexport function consumeRainbow(): boolean {\r\n  if (boostState.rainbowActive) {\r\n    boostState.rainbowActive = false;\r\n    debugLog('[BOOST] Rainbow consumed');\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function activateBomb() {\r\n  boostState.pendingBomb = true;\r\n  debugLog('[BOOST] Bomb activated - next hit will explode');\r\n}\r\n\r\nexport function consumeBomb(): boolean {\r\n  if (boostState.pendingBomb) {\r\n    boostState.pendingBomb = false;\r\n    debugLog('[BOOST] Bomb consumed');\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function activateRewind() {\r\n  boostState.pendingRewind = true;\r\n  debugLog('[BOOST] Rewind activated - chain will move back');\r\n}\r\n\r\nexport function consumeRewind(): boolean {\r\n  if (boostState.pendingRewind) {\r\n    boostState.pendingRewind = false;\r\n    debugLog('[BOOST] Rewind consumed');\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function activateShield() {\r\n  boostState.shieldActive = true;\r\n  debugLog('[BOOST] Shield activated - protects from one life loss');\r\n}\r\n\r\nexport function consumeShield(): boolean {\r\n  if (boostState.shieldActive) {\r\n    boostState.shieldActive = false;\r\n    debugLog('[BOOST] Shield consumed - blocked life loss');\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function activateMagnet(radius: number = 3) {\r\n  boostState.magnetActive = true;\r\n  boostState.magnetRadius = radius;\r\n  debugLog(`[BOOST] Magnet activated - attracts same color balls within ${radius} positions`);\r\n}\r\n\r\nexport function consumeMagnet(): { active: boolean; radius: number } {\r\n  if (boostState.magnetActive) {\r\n    const radius = boostState.magnetRadius;\r\n    boostState.magnetActive = false;\r\n    boostState.magnetRadius = 0;\r\n    debugLog('[BOOST] Magnet consumed');\r\n    return { active: true, radius };\r\n  }\r\n  return { active: false, radius: 0 };\r\n}\r\n\r\nexport function activateLaser(pierceCount: number = 3) {\r\n  boostState.pendingLaser = true;\r\n  boostState.laserPierceCount = pierceCount;\r\n  debugLog(`[BOOST] Laser activated - next shot pierces ${pierceCount} balls`);\r\n}\r\n\r\nexport function consumeLaser(): { active: boolean; pierceCount: number } {\r\n  if (boostState.pendingLaser) {\r\n    const count = boostState.laserPierceCount;\r\n    boostState.pendingLaser = false;\r\n    boostState.laserPierceCount = 0;\r\n    debugLog('[BOOST] Laser consumed');\r\n    return { active: true, pierceCount: count };\r\n  }\r\n  return { active: false, pierceCount: 0 };\r\n}\r\n\r\nexport function applyMagnetEffect(balls: Ball[], insertIndex: number, radius: number): Ball[] {\r\n  const insertedBall = balls[insertIndex];\r\n  if (!insertedBall) return balls;\r\n  \r\n  const targetColor = insertedBall.color;\r\n  const targetProgress = insertedBall.pathProgress;\r\n  const newBalls = [...balls];\r\n  const spacing = 0.02;\r\n  \r\n  let movedCount = 0;\r\n  for (let i = Math.max(0, insertIndex - radius); i <= Math.min(balls.length - 1, insertIndex + radius); i++) {\r\n    if (i !== insertIndex && newBalls[i].color === targetColor) {\r\n      const distance = Math.abs(i - insertIndex);\r\n      const newProgress = i < insertIndex \r\n        ? targetProgress - (distance * spacing)\r\n        : targetProgress + (distance * spacing);\r\n      \r\n      newBalls[i] = {\r\n        ...newBalls[i],\r\n        pathProgress: Math.max(0, Math.min(1, newProgress)),\r\n      };\r\n      movedCount++;\r\n    }\r\n  }\r\n  \r\n  debugLog(`[BOOST] Magnet pulled ${movedCount} same-color balls toward index ${insertIndex}`);\r\n  return newBalls;\r\n}\r\n\r\nexport function applyLaserEffect(balls: Ball[], hitIndices: number[]): {\r\n  newBalls: Ball[];\r\n  removedBalls: Ball[];\r\n  removedIndices: number[];\r\n} {\r\n  const removedBalls = hitIndices.map(i => balls[i]).filter(Boolean);\r\n  const newBalls = balls.filter((_, i) => !hitIndices.includes(i));\r\n  \r\n  debugLog(`[BOOST] Laser pierced through ${hitIndices.length} balls`);\r\n  return { newBalls, removedBalls, removedIndices: hitIndices };\r\n}\r\n\r\nexport function updateBoostTimers() {\r\n  if (boostState.slowdownActive && Date.now() >= boostState.slowdownEndTime) {\r\n    boostState.slowdownActive = false;\r\n    boostState.slowdownMultiplier = 1.0;\r\n    debugLog('[BOOST] Slowdown expired');\r\n  }\r\n}\r\n\r\nexport function getSpeedMultiplier(): number {\r\n  return boostState.slowdownActive ? boostState.slowdownMultiplier : 1.0;\r\n}\r\n\r\nexport function applyBombEffect(balls: Ball[], hitIndex: number, radius: number = 5): { \r\n  newBalls: Ball[]; \r\n  removedBalls: Ball[];\r\n  removedIndices: number[];\r\n} {\r\n  const toRemove: number[] = [];\r\n  const hitBall = balls[hitIndex];\r\n  if (!hitBall) {\r\n    return { newBalls: balls, removedBalls: [], removedIndices: [] };\r\n  }\r\n  \r\n  for (let i = Math.max(0, hitIndex - radius); i <= Math.min(balls.length - 1, hitIndex + radius); i++) {\r\n    toRemove.push(i);\r\n  }\r\n  \r\n  const removedBalls = toRemove.map(i => balls[i]);\r\n  const newBalls = balls.filter((_, i) => !toRemove.includes(i));\r\n  \r\n  debugLog(`[BOOST] Bomb exploded at index ${hitIndex}: removed ${toRemove.length} balls`);\r\n  return { newBalls, removedBalls, removedIndices: toRemove };\r\n}\r\n\r\nexport function applyRewindEffect(balls: Ball[], rewindPercent: number = 0.15): Ball[] {\r\n  const rewindAmount = rewindPercent;\r\n  const newBalls = balls.map(ball => ({\r\n    ...ball,\r\n    pathProgress: Math.max(0, ball.pathProgress - rewindAmount),\r\n  }));\r\n  debugLog(`[BOOST] Rewind applied: moved balls back by ${rewindPercent * 100}%`);\r\n  return newBalls;\r\n}\r\n\r\nexport function createRainbowBall(id: string, baseBall?: Ball): Ball {\r\n  const activeColors = getActiveBallColors();\r\n  const randomColor = activeColors[Math.floor(Math.random() * activeColors.length)];\r\n  \r\n  return {\r\n    id,\r\n    x: baseBall?.x ?? 0,\r\n    y: baseBall?.y ?? 0,\r\n    color: randomColor,\r\n    radius: BALL_RADIUS,\r\n    pathProgress: baseBall?.pathProgress ?? 0,\r\n    isRainbow: true,\r\n  };\r\n}\r\n\r\n// ========== END BOOST SYSTEM ==========\r\n\r\nexport interface PathPoint {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\nlet currentLevelConfig: LevelConfig | null = null;\r\n\r\nexport function setCurrentLevel(level: LevelConfig | null) {\r\n  currentLevelConfig = level;\r\n}\r\n\r\nexport function getCurrentLevel(): LevelConfig | null {\r\n  return currentLevelConfig;\r\n}\r\n\r\nexport function getBallSpacing(): number {\r\n  return currentLevelConfig?.ballSpacing ?? GAME_CONFIG.balls.spacing;\r\n}\r\n\r\nfunction generateSpiralPath(width: number, height: number, pathConfig: LevelPath): PathPoint[] {\r\n  const segments = pathConfig.segments || 600;\r\n  const spiralTurns = pathConfig.spiralTurns || 3.0;\r\n  const outerRadius = pathConfig.outerRadius || 0.42;\r\n  const innerRadius = pathConfig.innerRadius || 0.15;\r\n  \r\n  const centerX = width / 2;\r\n  const centerY = height * 0.48;\r\n  const maxRadius = Math.min(width, height) * outerRadius;\r\n  const minRadius = Math.min(width, height) * innerRadius;\r\n  \r\n  // Generate high-resolution raw spiral points\r\n  const rawSegments = segments * 4;\r\n  const rawPoints: PathPoint[] = [];\r\n  \r\n  for (let i = 0; i <= rawSegments; i++) {\r\n    const t = i / rawSegments;\r\n    const angle = t * Math.PI * 2 * spiralTurns;\r\n    const radius = maxRadius - (maxRadius - minRadius) * t;\r\n    \r\n    const x = centerX + radius * Math.cos(angle - Math.PI / 2);\r\n    const y = centerY + radius * Math.sin(angle - Math.PI / 2);\r\n    rawPoints.push({ x, y });\r\n  }\r\n  \r\n  // Calculate cumulative arc lengths\r\n  const arcLengths: number[] = [0];\r\n  for (let i = 1; i < rawPoints.length; i++) {\r\n    const dx = rawPoints[i].x - rawPoints[i - 1].x;\r\n    const dy = rawPoints[i].y - rawPoints[i - 1].y;\r\n    arcLengths.push(arcLengths[i - 1] + Math.sqrt(dx * dx + dy * dy));\r\n  }\r\n  \r\n  const totalLength = arcLengths[arcLengths.length - 1];\r\n  \r\n  // Resample by arc length for uniform speed\r\n  const points: PathPoint[] = [];\r\n  for (let i = 0; i <= segments; i++) {\r\n    const targetLength = (i / segments) * totalLength;\r\n    \r\n    // Binary search for the segment containing targetLength\r\n    let low = 0;\r\n    let high = arcLengths.length - 1;\r\n    while (low < high - 1) {\r\n      const mid = Math.floor((low + high) / 2);\r\n      if (arcLengths[mid] <= targetLength) {\r\n        low = mid;\r\n      } else {\r\n        high = mid;\r\n      }\r\n    }\r\n    \r\n    // Interpolate between rawPoints[low] and rawPoints[high]\r\n    const segmentLength = arcLengths[high] - arcLengths[low];\r\n    const t = segmentLength > 0 ? (targetLength - arcLengths[low]) / segmentLength : 0;\r\n    \r\n    const x = rawPoints[low].x + t * (rawPoints[high].x - rawPoints[low].x);\r\n    const y = rawPoints[low].y + t * (rawPoints[high].y - rawPoints[low].y);\r\n    points.push({ x, y });\r\n  }\r\n  \r\n  return points;\r\n}\r\n\r\nfunction generateZigzagPath(width: number, height: number, pathConfig: LevelPath): PathPoint[] {\r\n  const points: PathPoint[] = [];\r\n  const segments = pathConfig.segments || 500;\r\n  const amplitude = pathConfig.amplitude || 0.25;\r\n  const frequency = pathConfig.frequency || 6;\r\n  \r\n  const margin = width * 0.1;\r\n  const pathWidth = width - margin * 2;\r\n  const pathHeight = height * 0.7;\r\n  const startY = height * 0.1;\r\n  \r\n  for (let i = 0; i <= segments; i++) {\r\n    const t = i / segments;\r\n    const y = startY + t * pathHeight;\r\n    const zigzagPhase = t * frequency * Math.PI;\r\n    const zigzagOffset = Math.sin(zigzagPhase) * pathWidth * amplitude;\r\n    const x = width / 2 + zigzagOffset;\r\n    points.push({ x, y });\r\n  }\r\n  \r\n  return points;\r\n}\r\n\r\nfunction generateWavePath(width: number, height: number, pathConfig: LevelPath): PathPoint[] {\r\n  const points: PathPoint[] = [];\r\n  const segments = pathConfig.segments || 550;\r\n  const amplitude = pathConfig.amplitude || 0.18;\r\n  const frequency = pathConfig.frequency || 3;\r\n  \r\n  const margin = width * 0.1;\r\n  const pathHeight = height * 0.75;\r\n  const startY = height * 0.1;\r\n  \r\n  for (let i = 0; i <= segments; i++) {\r\n    const t = i / segments;\r\n    const y = startY + t * pathHeight;\r\n    const waveOffset = Math.sin(t * frequency * Math.PI * 2) * width * amplitude;\r\n    const x = width / 2 + waveOffset;\r\n    points.push({ x, y });\r\n  }\r\n  \r\n  return points;\r\n}\r\n\r\nfunction generateSShapePath(width: number, height: number, pathConfig: LevelPath): PathPoint[] {\r\n  const points: PathPoint[] = [];\r\n  const segments = pathConfig.segments || 500;\r\n  const amplitude = pathConfig.amplitude || 0.30;\r\n  \r\n  const pathHeight = height * 0.75;\r\n  const startY = height * 0.1;\r\n  \r\n  for (let i = 0; i <= segments; i++) {\r\n    const t = i / segments;\r\n    const y = startY + t * pathHeight;\r\n    const sOffset = Math.sin(t * Math.PI * 2) * width * amplitude;\r\n    const x = width / 2 + sOffset;\r\n    points.push({ x, y });\r\n  }\r\n  \r\n  return points;\r\n}\r\n\r\nfunction generateHeartPath(width: number, height: number, pathConfig: LevelPath): PathPoint[] {\r\n  const points: PathPoint[] = [];\r\n  const segments = pathConfig.segments || 600;\r\n  \r\n  const centerX = width / 2;\r\n  const centerY = height * 0.5;\r\n  const scale = Math.min(width, height) * 0.38;\r\n  \r\n  for (let i = 0; i <= segments; i++) {\r\n    const t = i / segments;\r\n    const angle = t * Math.PI * 2 - Math.PI / 2;\r\n    const heartX = 16 * Math.pow(Math.sin(angle), 3);\r\n    const heartY = -(13 * Math.cos(angle) - 5 * Math.cos(2 * angle) - 2 * Math.cos(3 * angle) - Math.cos(4 * angle));\r\n    \r\n    const x = centerX + heartX * scale / 16;\r\n    const y = centerY + heartY * scale / 16;\r\n    points.push({ x, y });\r\n  }\r\n  \r\n  return points;\r\n}\r\n\r\nfunction generateInfinityPath(width: number, height: number, pathConfig: LevelPath): PathPoint[] {\r\n  const points: PathPoint[] = [];\r\n  const segments = pathConfig.segments || 650;\r\n  \r\n  const centerX = width / 2;\r\n  const centerY = height * 0.5;\r\n  const scaleX = width * 0.35;\r\n  const scaleY = height * 0.2;\r\n  \r\n  for (let i = 0; i <= segments; i++) {\r\n    const t = i / segments;\r\n    const angle = t * Math.PI * 2;\r\n    const x = centerX + scaleX * Math.sin(angle);\r\n    const y = centerY + scaleY * Math.sin(angle * 2);\r\n    points.push({ x, y });\r\n  }\r\n  \r\n  return points;\r\n}\r\n\r\nexport function generatePathForLevel(width: number, height: number, levelConfig?: LevelConfig): PathPoint[] {\r\n  const level = levelConfig || currentLevelConfig;\r\n  \r\n  if (!level) {\r\n    return generateSpiralPath(width, height, GAME_CONFIG.path as LevelPath);\r\n  }\r\n  \r\n  switch (level.path.type) {\r\n    case 'spiral':\r\n      return generateSpiralPath(width, height, level.path);\r\n    case 'zigzag':\r\n      return generateZigzagPath(width, height, level.path);\r\n    case 'wave':\r\n      return generateWavePath(width, height, level.path);\r\n    case 'sShape':\r\n      return generateSShapePath(width, height, level.path);\r\n    case 'heart':\r\n      return generateHeartPath(width, height, level.path);\r\n    case 'infinity':\r\n      return generateInfinityPath(width, height, level.path);\r\n    default:\r\n      return generateSpiralPath(width, height, level.path);\r\n  }\r\n}\r\n\r\nexport function generatePath(width: number, height: number): PathPoint[] {\r\n  return generatePathForLevel(width, height);\r\n}\r\n\r\nexport function getShooterPosition(width: number, height: number): { x: number; y: number } {\r\n  const level = currentLevelConfig;\r\n  \r\n  if (!level) {\r\n    return { x: width / 2, y: height * 0.48 };\r\n  }\r\n  \r\n  switch (level.path.type) {\r\n    case 'spiral':\r\n      return { x: width / 2, y: height * 0.48 };\r\n    case 'zigzag':\r\n    case 'wave':\r\n    case 'sShape':\r\n      return { x: width / 2, y: height * 0.92 };\r\n    case 'heart':\r\n      return { x: width / 2, y: height * 0.55 };\r\n    case 'infinity':\r\n      return { x: width / 2, y: height * 0.75 };\r\n    default:\r\n      return { x: width / 2, y: height * 0.48 };\r\n  }\r\n}\r\n\r\nexport function getPositionOnPath(path: PathPoint[], progress: number): { x: number; y: number } {\r\n  if (progress < 0) {\r\n    return path[0] || { x: 0, y: 0 };\r\n  }\r\n  \r\n  const clampedProgress = Math.min(1, progress);\r\n  const index = clampedProgress * (path.length - 1);\r\n  const lowerIndex = Math.floor(index);\r\n  const upperIndex = Math.ceil(index);\r\n  \r\n  if (lowerIndex === upperIndex || upperIndex >= path.length) {\r\n    return path[lowerIndex] || path[path.length - 1];\r\n  }\r\n  \r\n  const fraction = index - lowerIndex;\r\n  const lower = path[lowerIndex];\r\n  const upper = path[upperIndex];\r\n  \r\n  return {\r\n    x: lower.x + (upper.x - lower.x) * fraction,\r\n    y: lower.y + (upper.y - lower.y) * fraction,\r\n  };\r\n}\r\n\r\nexport interface AvailableCrypto {\r\n  btc: boolean;\r\n  eth: boolean;\r\n  usdt: boolean;\r\n}\r\n\r\nexport interface FundSettings {\r\n  cryptoAvailable: AvailableCrypto;\r\n  usdtFundEnabled: boolean;\r\n}\r\n\r\n// Default to disabled for safety - will be set by API response\r\nlet availableCrypto: AvailableCrypto = { btc: false, eth: false, usdt: false };\r\nlet usdtFundEnabled: boolean = false;\r\nlet cryptoSpawnedThisGame: { btc: number; eth: number; usdt: number } = { btc: 0, eth: 0, usdt: 0 };\r\n\r\n// Flag to disable crypto balls on completed levels (motivate playing new levels)\r\nlet isLevelCompleted: boolean = false;\r\n\r\nexport function setLevelCompleted(completed: boolean) {\r\n  isLevelCompleted = completed;\r\n  debugLog(`[CRYPTO] Level completed flag set to: ${completed} - crypto balls ${completed ? 'DISABLED' : 'ENABLED'}`);\r\n}\r\n\r\nexport function getIsLevelCompleted(): boolean {\r\n  return isLevelCompleted;\r\n}\r\n\r\nexport function setAvailableCrypto(crypto: AvailableCrypto) {\r\n  availableCrypto = crypto;\r\n}\r\n\r\nexport function getAvailableCrypto(): AvailableCrypto {\r\n  return availableCrypto;\r\n}\r\n\r\nexport function setUsdtFundEnabled(enabled: boolean) {\r\n  usdtFundEnabled = enabled;\r\n}\r\n\r\nexport function getUsdtFundEnabled(): boolean {\r\n  return usdtFundEnabled;\r\n}\r\n\r\nexport function resetCryptoSpawnedCount() {\r\n  cryptoSpawnedThisGame = { btc: 0, eth: 0, usdt: 0 };\r\n}\r\n\r\nexport function getCryptoSpawnedCount() {\r\n  return { ...cryptoSpawnedThisGame };\r\n}\r\n\r\nfunction getColorCounts(balls: Ball[], includeAll: boolean = false): Map<string, number> {\r\n  const counts = new Map<string, number>();\r\n  for (const ball of balls) {\r\n    // For shooter color selection, count ALL balls' colors (including crypto)\r\n    // For chain spawning balance, only count regular balls\r\n    if (includeAll || (!ball.crypto && !ball.isUsdtFund)) {\r\n      counts.set(ball.color, (counts.get(ball.color) || 0) + 1);\r\n    }\r\n  }\r\n  return counts;\r\n}\r\n\r\nfunction selectBalancedColor(balls: Ball[], forShooter: boolean = false): string {\r\n  const activeColors = getActiveBallColors();\r\n  // For shooter: count ALL colors (including crypto balls) to match what's visible on screen\r\n  // For chain spawning: only count regular balls for balance\r\n  const colorCounts = getColorCounts(balls, forShooter);\r\n  \r\n  const totalBalls = balls.filter(b => !b.crypto && !b.isUsdtFund).length;\r\n  const targetPerColor = Math.max(1, Math.floor(totalBalls / activeColors.length));\r\n  \r\n  if (forShooter) {\r\n    const colorsInChain = activeColors.filter(c => (colorCounts.get(c) || 0) > 0);\r\n    if (colorsInChain.length === 0) {\r\n      return activeColors[Math.floor(Math.random() * activeColors.length)];\r\n    }\r\n    \r\n    // Инвертируем веса: цвета с меньшим количеством появляются НАМНОГО чаще\r\n    const maxCount = Math.max(...colorsInChain.map(c => colorCounts.get(c) || 1));\r\n    const weights: { color: string; weight: number }[] = [];\r\n    for (const color of colorsInChain) {\r\n      const count = colorCounts.get(color) || 1;\r\n      // Вес = (maxCount + 1 - count)^2, минимум 1 - квадратичная формула для большего приоритета\r\n      const baseWeight = Math.max(1, maxCount + 1 - count);\r\n      const weight = baseWeight * baseWeight; // Квадрат для более агрессивного приоритета\r\n      weights.push({ color, weight });\r\n    }\r\n    \r\n    const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);\r\n    let random = Math.random() * totalWeight;\r\n    \r\n    for (const { color, weight } of weights) {\r\n      random -= weight;\r\n      if (random <= 0) {\r\n        return color;\r\n      }\r\n    }\r\n    return colorsInChain[0];\r\n  }\r\n  \r\n  // Для спавна в цепочку: когда мало шаров (<=15) И в цепочке уже есть разнообразие цветов (минимум 3)\r\n  // Это предотвращает одноцветный спавн в начале игры\r\n  const colorsInChain = activeColors.filter(c => (colorCounts.get(c) || 0) > 0);\r\n  \r\n  if (totalBalls <= 15 && colorsInChain.length >= 3) {\r\n    // Используем ту же квадратичную формулу что и для shooter\r\n    const maxCount = Math.max(...colorsInChain.map(c => colorCounts.get(c) || 1));\r\n    const weights: { color: string; weight: number }[] = [];\r\n    for (const color of colorsInChain) {\r\n      const count = colorCounts.get(color) || 1;\r\n      const baseWeight = Math.max(1, maxCount + 1 - count);\r\n      const weight = baseWeight * baseWeight;\r\n      weights.push({ color, weight });\r\n    }\r\n    \r\n    const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);\r\n    let random = Math.random() * totalWeight;\r\n    \r\n    for (const { color, weight } of weights) {\r\n      random -= weight;\r\n      if (random <= 0) {\r\n        return color;\r\n      }\r\n    }\r\n    return colorsInChain[0];\r\n  }\r\n  \r\n  // Обычный спавн когда много шаров - балансированное распределение\r\n  const weights: { color: string; weight: number }[] = [];\r\n  \r\n  for (const color of activeColors) {\r\n    const count = colorCounts.get(color) || 0;\r\n    const deficit = Math.max(0, targetPerColor - count);\r\n    let weight = 1 + deficit * 2;\r\n    \r\n    if (count === 0 && totalBalls > 10) {\r\n      weight = 5;\r\n    }\r\n    \r\n    weights.push({ color, weight });\r\n  }\r\n  \r\n  const totalWeight = weights.reduce((sum, w) => sum + w.weight, 0);\r\n  let random = Math.random() * totalWeight;\r\n  \r\n  for (const { color, weight } of weights) {\r\n    random -= weight;\r\n    if (random <= 0) {\r\n      return color;\r\n    }\r\n  }\r\n  \r\n  return activeColors[0];\r\n}\r\n\r\nexport function createBallFromChain(id: string, chainBalls: Ball[], pathProgress: number = 0): Ball {\r\n  const color = selectBalancedColor(chainBalls, true) as BallColor;\r\n  \r\n  return {\r\n    id,\r\n    x: 0,\r\n    y: 0,\r\n    color,\r\n    radius: BALL_RADIUS,\r\n    pathProgress,\r\n  };\r\n}\r\n\r\nexport function createRandomBall(id: string, pathProgress: number = 0, chainBalls: Ball[] = [], forShooter: boolean = false): Ball {\r\n  const activeColors = getActiveBallColors();\r\n  \r\n  // Smart shooter generation when few balls remain\r\n  if (forShooter && chainBalls.length > 0 && chainBalls.length <= 15) {\r\n    // Collect unique ball types in chain (color + crypto/usdtFund combination)\r\n    const ballTypes: Array<{ color: BallColor; crypto?: CryptoType; isUsdtFund?: boolean }> = [];\r\n    const seenKeys = new Set<string>();\r\n    \r\n    for (const ball of chainBalls) {\r\n      const key = ball.isUsdtFund ? `usdt-fund-${ball.color}` : \r\n                  ball.crypto ? `crypto-${ball.crypto}-${ball.color}` : \r\n                  `regular-${ball.color}`;\r\n      if (!seenKeys.has(key)) {\r\n        seenKeys.add(key);\r\n        ballTypes.push({ \r\n          color: ball.color as BallColor, \r\n          crypto: ball.crypto, \r\n          isUsdtFund: ball.isUsdtFund \r\n        });\r\n      }\r\n    }\r\n    \r\n    if (ballTypes.length > 0) {\r\n      // Weight by count of each type in chain (more balls = higher chance)\r\n      const typeWeights = ballTypes.map(type => {\r\n        const count = chainBalls.filter(b => {\r\n          if (type.isUsdtFund) return b.isUsdtFund && b.color === type.color;\r\n          if (type.crypto) return b.crypto === type.crypto && b.color === type.color;\r\n          return !b.crypto && !b.isUsdtFund && b.color === type.color;\r\n        }).length;\r\n        return { type, weight: count };\r\n      });\r\n      \r\n      const totalWeight = typeWeights.reduce((sum, tw) => sum + tw.weight, 0);\r\n      let random = Math.random() * totalWeight;\r\n      \r\n      for (const { type, weight } of typeWeights) {\r\n        random -= weight;\r\n        if (random <= 0) {\r\n          debugLog(`[SHOOTER-SMART] Balls:${chainBalls.length} Types:${ballTypes.length} -> ${type.isUsdtFund ? 'USDT-Fund' : type.crypto || type.color}`);\r\n          return {\r\n            id,\r\n            x: 0,\r\n            y: 0,\r\n            color: type.color,\r\n            crypto: type.crypto,\r\n            isUsdtFund: type.isUsdtFund,\r\n            radius: BALL_RADIUS,\r\n            pathProgress,\r\n          };\r\n        }\r\n      }\r\n      \r\n      // Fallback to first type\r\n      const fallback = ballTypes[0];\r\n      return {\r\n        id,\r\n        x: 0,\r\n        y: 0,\r\n        color: fallback.color,\r\n        crypto: fallback.crypto,\r\n        isUsdtFund: fallback.isUsdtFund,\r\n        radius: BALL_RADIUS,\r\n        pathProgress,\r\n      };\r\n    }\r\n  }\r\n  \r\n  // forShooter=true: pick only from colors in chain (for shooter/next ball)\r\n  // forShooter=false: balanced distribution from all active colors (for chain spawning)\r\n  const color = (chainBalls.length > 0 \r\n    ? selectBalancedColor(chainBalls, forShooter)\r\n    : activeColors[Math.floor(Math.random() * activeColors.length)]) as BallColor;\r\n  \r\n  const spawnChance = currentEconomy.crypto.spawnChance;\r\n  const limits = currentEconomy.perGameLimits;\r\n  \r\n  // Skip crypto spawning on completed levels - only regular balls\r\n  if (isLevelCompleted) {\r\n    return {\r\n      id,\r\n      x: 0,\r\n      y: 0,\r\n      color,\r\n      radius: BALL_RADIUS,\r\n      pathProgress,\r\n    };\r\n  }\r\n  \r\n  const isUsdtFundBall = usdtFundEnabled && Math.random() < spawnChance;\r\n  \r\n  if (isUsdtFundBall) {\r\n    debugLog(`[CRYPTO] Spawning USDT Fund ball: ${id}`);\r\n    return {\r\n      id,\r\n      x: 0,\r\n      y: 0,\r\n      color,\r\n      isUsdtFund: true,\r\n      radius: BALL_RADIUS,\r\n      pathProgress,\r\n    };\r\n  }\r\n  \r\n  const availableTypes = CRYPTO_TYPES.filter(type => {\r\n    if (!availableCrypto[type]) return false;\r\n    const limit = limits[`${type}MaxBeadsPerGame` as keyof typeof limits] || 15;\r\n    return cryptoSpawnedThisGame[type] < limit;\r\n  });\r\n  const hasCryptoAvailable = availableTypes.length > 0;\r\n  const cryptoRoll = Math.random();\r\n  const isCrypto = hasCryptoAvailable && cryptoRoll < spawnChance;\r\n  \r\n  let crypto: CryptoType | undefined = undefined;\r\n  if (isCrypto) {\r\n    crypto = availableTypes[Math.floor(Math.random() * availableTypes.length)];\r\n    cryptoSpawnedThisGame[crypto]++;\r\n    debugLog(`[CRYPTO] Spawned ${crypto} ball: ${id}, roll=${cryptoRoll.toFixed(3)}, chance=${spawnChance}, spawned=${JSON.stringify(cryptoSpawnedThisGame)}`);\r\n  }\r\n  \r\n  return {\r\n    id,\r\n    x: 0,\r\n    y: 0,\r\n    color,\r\n    crypto,\r\n    radius: BALL_RADIUS,\r\n    pathProgress,\r\n  };\r\n}\r\n\r\nexport function createInitialBalls(count: number): Ball[] {\r\n  const balls: Ball[] = [];\r\n  const spacing = getBallSpacing();\r\n  \r\n  // Start balls at small positive offset to ensure smooth movement from start\r\n  const startOffset = spacing * 0.5;\r\n  \r\n  for (let i = 0; i < count; i++) {\r\n    const ball = createRandomBall(`ball-${i}`, startOffset + i * spacing, balls);\r\n    balls.push(ball);\r\n  }\r\n  \r\n  return balls;\r\n}\r\n\r\nexport function createInitialGameState(): GameState {\r\n  debugLog('=== GAME STARTED ===', 'initialBalls:', currentGameplay.balls.initialCount);\r\n  debugLog(`[CRYPTO CONFIG] spawnChance=${currentEconomy.crypto.spawnChance}, availableCrypto=${JSON.stringify(availableCrypto)}, usdtFundEnabled=${usdtFundEnabled}`);\r\n  cryptoSpawnedThisGame = { btc: 0, eth: 0, usdt: 0 };\r\n  resetBoostState();\r\n  const balls = createInitialBalls(currentGameplay.balls.initialCount);\r\n  return {\r\n    balls,\r\n    shooterBall: createRandomBall('shooter', 0, balls, true),\r\n    nextBall: createRandomBall('next', 0, balls, true),\r\n    score: 0,\r\n    combo: 0,\r\n    maxCombo: 0,\r\n    timeLeft: 0,\r\n    cryptoCollected: { btc: 0, eth: 0, usdt: 0 },\r\n    usdtFundCollected: 0,\r\n    isPlaying: false,\r\n    isGameOver: false,\r\n    won: false,\r\n    shotsTotal: 0,\r\n    shotsHit: 0,\r\n    lives: 3,\r\n    extraLivesBought: 0,\r\n    totalBallsSpawned: currentGameplay.balls.initialCount,\r\n  };\r\n}\r\n\r\nconst SPAWN_ANIM_DURATION = 300; // ms for portal emergence animation\r\n\r\nexport function updateBallPositions(balls: Ball[], path: PathPoint[]): Ball[] {\r\n  const now = Date.now();\r\n  \r\n  return balls.map(ball => {\r\n    let visualProgress = ball.pathProgress;\r\n    \r\n    // Apply spawn animation: interpolate from portal (0) to true position\r\n    if (ball.spawnAnimStart) {\r\n      const elapsed = now - ball.spawnAnimStart;\r\n      if (elapsed < SPAWN_ANIM_DURATION) {\r\n        // Ease-out cubic for smooth deceleration\r\n        const t = elapsed / SPAWN_ANIM_DURATION;\r\n        const eased = 1 - Math.pow(1 - t, 3);\r\n        // Interpolate from position 0 (portal) to true pathProgress\r\n        visualProgress = eased * ball.pathProgress;\r\n      }\r\n    }\r\n    \r\n    const position = getPositionOnPath(path, visualProgress);\r\n    return { ...ball, x: position.x, y: position.y };\r\n  });\r\n}\r\n\r\nexport function moveBallsForward(balls: Ball[], deltaTime: number): Ball[] {\r\n  const speedMultiplier = getSpeedMultiplier();\r\n  return balls.map(ball => {\r\n    const dynamicSpeed = calculateDynamicSpeed(ball.pathProgress);\r\n    const moveAmount = dynamicSpeed * deltaTime * 0.001 * speedMultiplier;\r\n    return {\r\n      ...ball,\r\n      pathProgress: ball.pathProgress + moveAmount,\r\n    };\r\n  });\r\n}\r\n\r\nlet rollbackLogCounter = 0;\r\nlet rollbackActiveUntil = 0;\r\nlet rollbackHadGap = false; // Track if we've seen a real gap during this rollback\r\n\r\n// Activate rollback to close gaps after ball removal\r\nexport function activateRollback(_isEarlyGame: boolean = false) {\r\n  rollbackActiveUntil = Date.now() + 800; // Shorter rollback window\r\n  rollbackHadGap = false; // Reset gap tracking for new rollback session\r\n}\r\n\r\nexport function isRollbackActive(): boolean {\r\n  return Date.now() < rollbackActiveUntil;\r\n}\r\n\r\nexport function processRollback(balls: Ball[], deltaTime: number, _spawnFinished: boolean = false): Ball[] {\r\n  const now = Date.now();\r\n  const rollbackActive = now < rollbackActiveUntil;\r\n  \r\n  if (!rollbackActive) {\r\n    return balls;\r\n  }\r\n  \r\n  // With fewer than 2 balls, no gaps possible - immediately deactivate\r\n  if (balls.length < 2) {\r\n    rollbackActiveUntil = 0;\r\n    return balls;\r\n  }\r\n  \r\n  const spacing = getBallSpacing();\r\n  // Fast rollback speed - close gaps quickly like in classic Zuma\r\n  const rollbackSpeed = 0.5;\r\n  const maxCorrectionPerFrame = rollbackSpeed * deltaTime * 0.001;\r\n  \r\n  const newBalls = [...balls];\r\n  \r\n  let hasGap = false;\r\n  let maxGapExcess = 0;\r\n  \r\n  // Find gaps in the chain where balls were removed\r\n  // Front part (higher pathProgress) rolls backward to meet back part\r\n  for (let i = 1; i < newBalls.length; i++) {\r\n    const prevBall = newBalls[i - 1];\r\n    const currentBall = newBalls[i];\r\n    \r\n    const gap = currentBall.pathProgress - prevBall.pathProgress;\r\n    const targetGap = spacing;\r\n    \r\n    // Detect any gap larger than normal spacing (10% threshold for responsiveness)\r\n    if (gap > targetGap * 1.10) {\r\n      const excess = gap - targetGap;\r\n      maxGapExcess = Math.max(maxGapExcess, excess);\r\n      hasGap = true;\r\n      rollbackHadGap = true; // Mark that we've seen a gap during this session\r\n      \r\n      // Calculate correction - move quickly to close gap\r\n      const correction = Math.min(excess * 0.6, maxCorrectionPerFrame);\r\n      \r\n      // Move this ball AND ALL balls behind it backward together\r\n      // This keeps the chain cohesive while closing the gap\r\n      for (let j = i; j < newBalls.length; j++) {\r\n        newBalls[j] = {\r\n          ...newBalls[j],\r\n          pathProgress: newBalls[j].pathProgress - correction,\r\n        };\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Immediately deactivate if no gaps found (edge matches or already closed)\r\n  if (!hasGap) {\r\n    rollbackActiveUntil = 0;\r\n    rollbackHadGap = false;\r\n  }\r\n  \r\n  // Log every 60 frames (~1 second at 60fps) if there are gaps\r\n  rollbackLogCounter++;\r\n  if (rollbackLogCounter >= 60 && maxGapExcess > 0) {\r\n    rollbackLogCounter = 0;\r\n    debugLog(`[ROLLBACK] maxExcess=${maxGapExcess.toFixed(4)}, spacing=${spacing.toFixed(4)}`);\r\n  }\r\n  \r\n  return newBalls;\r\n}\r\n\r\nfunction ballsMatch(ball1: Ball, ball2: Ball): boolean {\r\n  // Rainbow balls match any non-crypto ball\r\n  if (ball1.isRainbow && !ball2.crypto) {\r\n    debugLog(`ballsMatch rainbow: ball1 is rainbow, matches ${ball2.color}`);\r\n    return true;\r\n  }\r\n  if (ball2.isRainbow && !ball1.crypto) {\r\n    debugLog(`ballsMatch rainbow: ball2 is rainbow, matches ${ball1.color}`);\r\n    return true;\r\n  }\r\n  \r\n  if (ball1.crypto && ball2.crypto) {\r\n    const result = ball1.crypto === ball2.crypto;\r\n    debugLog(`ballsMatch crypto: ${ball1.crypto} vs ${ball2.crypto} = ${result}`);\r\n    return result;\r\n  }\r\n  if (!ball1.crypto && !ball2.crypto) {\r\n    const result = ball1.color === ball2.color;\r\n    debugLog(`ballsMatch color: ${ball1.color} vs ${ball2.color} = ${result}`);\r\n    return result;\r\n  }\r\n  debugLog(`ballsMatch mixed: ball1.crypto=${ball1.crypto} ball2.crypto=${ball2.crypto} = false`);\r\n  return false;\r\n}\r\n\r\nexport function findMatchingBalls(balls: Ball[], insertIndex: number, insertedBall: Ball): number[] {\r\n  const opId = getNextOperationId();\r\n  \r\n  if (insertIndex < 0 || insertIndex >= balls.length) {\r\n    debugLog(`[OP${opId}] findMatchingBalls: invalid index ${insertIndex}, balls.length=${balls.length}`);\r\n    return [];\r\n  }\r\n  \r\n  const matches: number[] = [insertIndex];\r\n  const targetBall = balls[insertIndex];\r\n  \r\n  debugLog(`[OP${opId}] findMatchingBalls START: insertIndex=${insertIndex}, targetBall.id=${targetBall.id}, color=${targetBall.color}, crypto=${targetBall.crypto}, isRainbow=${targetBall.isRainbow}`);\r\n  \r\n  const chainSnapshot = balls.slice(0, Math.min(15, balls.length)).map((b, i) => `${i}:${b.color?.slice(0,2)}[${b.id?.slice(-6)}]`).join(' ');\r\n  debugLog(`[OP${opId}] Chain snapshot (first 15): ${chainSnapshot}`);\r\n  \r\n  // For rainbow balls, we need to find the color of adjacent balls to match against\r\n  // Rainbow ball acts as a wildcard for the color of its neighbors\r\n  let matchColor = targetBall.color;\r\n  let matchCrypto = targetBall.crypto;\r\n  \r\n  if (targetBall.isRainbow) {\r\n    // Find the color from the left or right neighbor\r\n    const leftNeighbor = insertIndex > 0 ? balls[insertIndex - 1] : null;\r\n    const rightNeighbor = insertIndex < balls.length - 1 ? balls[insertIndex + 1] : null;\r\n    \r\n    // Prefer non-crypto neighbor's color\r\n    if (leftNeighbor && !leftNeighbor.crypto && !leftNeighbor.isRainbow) {\r\n      matchColor = leftNeighbor.color;\r\n      matchCrypto = undefined;\r\n      debugLog(`  Rainbow using LEFT neighbor color: ${matchColor}`);\r\n    } else if (rightNeighbor && !rightNeighbor.crypto && !rightNeighbor.isRainbow) {\r\n      matchColor = rightNeighbor.color;\r\n      matchCrypto = undefined;\r\n      debugLog(`  Rainbow using RIGHT neighbor color: ${matchColor}`);\r\n    } else {\r\n      debugLog(`  Rainbow has no valid neighbor to match, no match possible`);\r\n      return [];\r\n    }\r\n  }\r\n  \r\n  // Helper function for rainbow-aware matching\r\n  const matchesTarget = (ball: Ball): boolean => {\r\n    if (ball.isRainbow) return true; // Rainbow balls always match in a group\r\n    if (matchCrypto) {\r\n      return ball.crypto === matchCrypto;\r\n    }\r\n    return !ball.crypto && ball.color === matchColor;\r\n  };\r\n  \r\n  let left = insertIndex - 1;\r\n  while (left >= 0 && matchesTarget(balls[left])) {\r\n    debugLog(`  LEFT match at ${left}: id=${balls[left].id}, color=${balls[left].color}, crypto=${balls[left].crypto}`);\r\n    matches.unshift(left);\r\n    left--;\r\n  }\r\n  \r\n  let right = insertIndex + 1;\r\n  while (right < balls.length && matchesTarget(balls[right])) {\r\n    debugLog(`  RIGHT match at ${right}: id=${balls[right].id}, color=${balls[right].color}, crypto=${balls[right].crypto}`);\r\n    matches.push(right);\r\n    right++;\r\n  }\r\n  \r\n  const result = matches.length >= 3 ? matches : [];\r\n  const matchedIds = matches.map(i => balls[i]?.id?.slice(-8) || '?').join(',');\r\n  debugLog(`[OP${opId}] findMatchingBalls END: found ${matches.length} matches, indices=[${matches.join(',')}], ids=[${matchedIds}], returning ${result.length >= 3 ? 'MATCH' : 'NO MATCH'}`);\r\n  \r\n  return result;\r\n}\r\n\r\nexport function calculatePoints(matchedBalls: Ball[], combo: number): {\r\n  points: number;\r\n  cryptoCollected: { btc: number; eth: number; usdt: number };\r\n  usdtFundCollected: number;\r\n} {\r\n  let points = 0;\r\n  const cryptoCollected = { btc: 0, eth: 0, usdt: 0 };\r\n  let usdtFundCollected = 0;\r\n  const economy = currentEconomy;\r\n  \r\n  for (const ball of matchedBalls) {\r\n    if (ball.isUsdtFund) {\r\n      // USDT fund balls: no points, only crypto reward\r\n      usdtFundCollected++;\r\n    } else if (ball.crypto) {\r\n      // Crypto balls: no points, only crypto reward\r\n      cryptoCollected[ball.crypto]++;\r\n    } else {\r\n      // Regular balls: give points (Beads)\r\n      points += economy.points.normal;\r\n    }\r\n  }\r\n  \r\n  const comboMultiplier = Math.pow(economy.combo.multiplier, Math.min(combo, economy.combo.maxChain));\r\n  points = Math.round(points * comboMultiplier);\r\n  \r\n  return { points, cryptoCollected, usdtFundCollected };\r\n}\r\n\r\nexport function insertBallInChain(\r\n  balls: Ball[],\r\n  shooterBall: Ball,\r\n  insertIndex: number\r\n): Ball[] {\r\n  debugLog(`insertBallInChain: shooterBall.color=${shooterBall.color}, crypto=${shooterBall.crypto}, insertIndex=${insertIndex}, chainLength=${balls.length}`);\r\n  \r\n  const newBalls = [...balls];\r\n  const spacing = getBallSpacing();\r\n  \r\n  const insertProgress = insertIndex < balls.length \r\n    ? balls[insertIndex].pathProgress \r\n    : (balls[balls.length - 1]?.pathProgress || 0) + spacing;\r\n  \r\n  const insertedBall: Ball = {\r\n    ...shooterBall,\r\n    id: `ball-${Date.now()}`,\r\n    pathProgress: insertProgress,\r\n  };\r\n  \r\n  debugLog(`  Created insertedBall: id=${insertedBall.id}, color=${insertedBall.color}, crypto=${insertedBall.crypto}`);\r\n  \r\n  for (let i = insertIndex; i < newBalls.length; i++) {\r\n    newBalls[i] = {\r\n      ...newBalls[i],\r\n      pathProgress: newBalls[i].pathProgress + spacing,\r\n    };\r\n  }\r\n  \r\n  newBalls.splice(insertIndex, 0, insertedBall);\r\n  \r\n  debugLog(`  Chain after insert: [${newBalls.slice(Math.max(0, insertIndex-2), insertIndex+3).map(b => `${b.color}${b.crypto ? '('+b.crypto+')' : ''}`).join(', ')}]`);\r\n  \r\n  return newBalls;\r\n}\r\n\r\nexport function removeBalls(balls: Ball[], indices: number[]): Ball[] {\r\n  const opId = getNextOperationId();\r\n  const sortedIndices = [...indices].sort((a, b) => b - a);\r\n  const newBalls = [...balls];\r\n  \r\n  debugLog(`[OP${opId}] removeBalls: removing ${indices.length} balls at indices [${indices.join(',')}]`);\r\n  const removedInfo = indices.map(i => {\r\n    const b = balls[i];\r\n    const shortId = b?.id?.slice(-8) || '?';\r\n    return `idx${i}:${b?.color}${b?.crypto ? '('+b.crypto+')' : ''}[${shortId}]`;\r\n  });\r\n  debugLog(`[OP${opId}] Balls being removed: [${removedInfo.join(', ')}]`);\r\n  \r\n  for (const index of sortedIndices) {\r\n    newBalls.splice(index, 1);\r\n  }\r\n  \r\n  debugLog(`[OP${opId}] Chain after removal: length=${newBalls.length}`);\r\n  return newBalls;\r\n}\r\n\r\nexport function findAllMatches(balls: Ball[]): { indices: number[]; matchedBalls: Ball[] }[] {\r\n  if (balls.length < 3) return [];\r\n  \r\n  const allMatches: { indices: number[]; matchedBalls: Ball[] }[] = [];\r\n  const processed = new Set<number>();\r\n  \r\n  for (let i = 0; i < balls.length; i++) {\r\n    if (processed.has(i)) continue;\r\n    \r\n    const currentBall = balls[i];\r\n    const group: number[] = [i];\r\n    \r\n    let j = i + 1;\r\n    while (j < balls.length && ballsMatch(balls[j], currentBall)) {\r\n      group.push(j);\r\n      j++;\r\n    }\r\n    \r\n    if (group.length >= 3) {\r\n      group.forEach(idx => processed.add(idx));\r\n      allMatches.push({\r\n        indices: group,\r\n        matchedBalls: group.map(idx => balls[idx])\r\n      });\r\n    }\r\n  }\r\n  \r\n  return allMatches;\r\n}\r\n\r\nexport function checkCollision(\r\n  projectileX: number,\r\n  projectileY: number,\r\n  balls: Ball[],\r\n  path: PathPoint[]\r\n): { index: number; insertBefore: boolean } | null {\r\n  const collisionDistance = BALL_RADIUS * COLLISION_RADIUS_MULTIPLIER;\r\n  \r\n  let closestIndex = -1;\r\n  let closestDistance = Infinity;\r\n  \r\n  for (let i = 0; i < balls.length; i++) {\r\n    const ball = balls[i];\r\n    if (ball.pathProgress < 0) continue;\r\n    \r\n    const dx = projectileX - ball.x;\r\n    const dy = projectileY - ball.y;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    \r\n    if (distance < collisionDistance && distance < closestDistance) {\r\n      closestDistance = distance;\r\n      closestIndex = i;\r\n    }\r\n  }\r\n  \r\n  if (closestIndex === -1) return null;\r\n  \r\n  const hitBall = balls[closestIndex];\r\n  \r\n  const projectileProgress = findClosestProgressOnPath(projectileX, projectileY, path);\r\n  \r\n  const insertBefore = projectileProgress < hitBall.pathProgress;\r\n  \r\n  return { index: closestIndex, insertBefore };\r\n}\r\n\r\nexport function checkPathCollision(\r\n  projectileX: number,\r\n  projectileY: number,\r\n  prevX: number,\r\n  prevY: number,\r\n  balls: Ball[],\r\n  path: PathPoint[]\r\n): { index: number; insertBefore: boolean } | null {\r\n  const directHit = checkCollision(projectileX, projectileY, balls, path);\r\n  if (directHit) return directHit;\r\n  \r\n  const dx = projectileX - prevX;\r\n  const dy = projectileY - prevY;\r\n  const stepDistance = Math.sqrt(dx * dx + dy * dy);\r\n  \r\n  if (stepDistance > BALL_RADIUS) {\r\n    const steps = Math.ceil(stepDistance / (BALL_RADIUS * 0.5));\r\n    for (let i = 1; i < steps; i++) {\r\n      const t = i / steps;\r\n      const checkX = prevX + dx * t;\r\n      const checkY = prevY + dy * t;\r\n      \r\n      const hit = checkCollision(checkX, checkY, balls, path);\r\n      if (hit) return hit;\r\n    }\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\nfunction findClosestProgressOnPath(x: number, y: number, path: PathPoint[]): number {\r\n  let closestIndex = 0;\r\n  let closestDistance = Infinity;\r\n  \r\n  for (let i = 0; i < path.length; i++) {\r\n    const dx = x - path[i].x;\r\n    const dy = y - path[i].y;\r\n    const dist = dx * dx + dy * dy;\r\n    if (dist < closestDistance) {\r\n      closestDistance = dist;\r\n      closestIndex = i;\r\n    }\r\n  }\r\n  \r\n  return closestIndex / (path.length - 1);\r\n}\r\n\r\nexport function addNewBallsToChain(balls: Ball[], count: number): Ball[] {\r\n  const newBalls = [...balls];\r\n  const spacing = getBallSpacing();\r\n  \r\n  for (let i = 0; i < count; i++) {\r\n    const lastProgress = newBalls.length > 0 \r\n      ? newBalls[newBalls.length - 1].pathProgress \r\n      : 0;\r\n    const newBall = createRandomBall(`new-${Date.now()}-${i}`, lastProgress + spacing, newBalls);\r\n    newBalls.push(newBall);\r\n  }\r\n  \r\n  return newBalls;\r\n}\r\n\r\nexport function spawnBallAtStart(balls: Ball[]): Ball[] {\r\n  const spacing = getBallSpacing();\r\n  const newBall = createRandomBall(`spawn-${Date.now()}`, 0, balls);\r\n  \r\n  const shiftedBalls = balls.map(ball => ({\r\n    ...ball,\r\n    pathProgress: ball.pathProgress + spacing,\r\n  }));\r\n  \r\n  return [newBall, ...shiftedBalls];\r\n}\r\n\r\nexport function checkGameOver(balls: Ball[]): boolean {\r\n  return balls.some(ball => ball.pathProgress >= 1);\r\n}\r\n\r\nexport function checkWin(balls: Ball[]): boolean {\r\n  return balls.length === 0;\r\n}\r\n\r\nexport const BALL_COLOR_MAP: Record<BallColor, string> = {\r\n  red: '#ef4444',\r\n  blue: '#3b82f6',\r\n  green: '#22c55e',\r\n  yellow: '#eab308',\r\n  purple: '#a855f7',\r\n  cyan: '#00e5ff',\r\n  magenta: '#ff2bf2',\r\n  amber: '#ffc400',\r\n  lime: '#b6ff00',\r\n  violet: '#8c3bff',\r\n};\r\n\r\nexport const CRYPTO_COLOR_MAP: Record<CryptoType, string> = {\r\n  btc: '#f7931a',\r\n  eth: '#627eea',\r\n  usdt: '#26a17b',\r\n};\r\n\r\nexport const CRYPTO_SYMBOL_MAP: Record<CryptoType, string> = {\r\n  btc: '₿',\r\n  eth: 'Ξ',\r\n  usdt: '₮',\r\n};\r\n\r\nexport { BALL_RADIUS, SHOOTER_BALL_SPEED };\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2225, "column": 0}, "map": {"version":3,"sources":["file:///D:/BeadsLine/lib/levelConfig.ts"],"sourcesContent":["export type PathType = 'spiral' | 'zigzag' | 'wave' | 'sShape' | 'heart' | 'infinity';\r\n\r\nexport interface LevelPath {\r\n  type: PathType;\r\n  segments: number;\r\n  spiralTurns?: number;\r\n  outerRadius?: number;\r\n  innerRadius?: number;\r\n  amplitude?: number;\r\n  frequency?: number;\r\n}\r\n\r\nexport interface LevelConfig {\r\n  id: number;\r\n  name: string;\r\n  nameRu: string;\r\n  description: string;\r\n  descriptionRu: string;\r\n  path: LevelPath;\r\n  difficulty: 'easy' | 'medium' | 'hard';\r\n  initialBalls: number;\r\n  targetBalls: number;\r\n  maxBalls: number;\r\n  speed: {\r\n    base: number;\r\n    max: number;\r\n  };\r\n  colors: number;\r\n  unlockCondition: number | null;\r\n  ballSpacing?: number;\r\n  spawnPeriod?: number;\r\n}\r\n\r\nexport const LEVELS: LevelConfig[] = [\r\n  {\r\n    id: 1,\r\n    name: \"Classic Spiral\",\r\n    nameRu: \"Классическая спираль\",\r\n    description: \"The original spiral path\",\r\n    descriptionRu: \"Классический спиральный путь\",\r\n    path: {\r\n      type: 'spiral',\r\n      segments: 600,\r\n      spiralTurns: 3.0,\r\n      outerRadius: 0.42,\r\n      innerRadius: 0.15,\r\n    },\r\n    difficulty: 'easy',\r\n    initialBalls: 5,\r\n    targetBalls: 50,\r\n    maxBalls: 60,\r\n    speed: { base: 0.020, max: 0.030 },\r\n    colors: 5,\r\n    unlockCondition: null,\r\n  },\r\n  {\r\n    id: 2,\r\n    name: \"Zigzag Path\",\r\n    nameRu: \"Зигзаг\",\r\n    description: \"Sharp turns challenge your aim\",\r\n    descriptionRu: \"Резкие повороты бросают вызов вашей точности\",\r\n    path: {\r\n      type: 'zigzag',\r\n      segments: 500,\r\n      amplitude: 0.35,\r\n      frequency: 4,\r\n    },\r\n    difficulty: 'easy',\r\n    initialBalls: 5,\r\n    targetBalls: 45,\r\n    maxBalls: 55,\r\n    speed: { base: 0.012, max: 0.018 },\r\n    colors: 5,\r\n    unlockCondition: 1,\r\n  },\r\n  {\r\n    id: 3,\r\n    name: \"Gentle Wave\",\r\n    nameRu: \"Плавная волна\",\r\n    description: \"Smooth wave pattern\",\r\n    descriptionRu: \"Плавный волнообразный путь\",\r\n    path: {\r\n      type: 'wave',\r\n      segments: 550,\r\n      amplitude: 0.18,\r\n      frequency: 3,\r\n    },\r\n    difficulty: 'easy',\r\n    initialBalls: 6,\r\n    targetBalls: 50,\r\n    maxBalls: 60,\r\n    speed: { base: 0.013, max: 0.019 },\r\n    colors: 5,\r\n    unlockCondition: 2,\r\n  },\r\n  {\r\n    id: 4,\r\n    name: \"S-Curve\",\r\n    nameRu: \"S-образный\",\r\n    description: \"Double curve path\",\r\n    descriptionRu: \"Путь в форме буквы S\",\r\n    path: {\r\n      type: 'sShape',\r\n      segments: 500,\r\n      amplitude: 0.30,\r\n    },\r\n    difficulty: 'medium',\r\n    initialBalls: 6,\r\n    targetBalls: 55,\r\n    maxBalls: 65,\r\n    speed: { base: 0.014, max: 0.021 },\r\n    colors: 6,\r\n    unlockCondition: 3,\r\n  },\r\n  {\r\n    id: 5,\r\n    name: \"Tight Spiral\",\r\n    nameRu: \"Тугая спираль\",\r\n    description: \"More turns, less space\",\r\n    descriptionRu: \"Больше витков, меньше места\",\r\n    path: {\r\n      type: 'spiral',\r\n      segments: 700,\r\n      spiralTurns: 4.5,\r\n      outerRadius: 0.40,\r\n      innerRadius: 0.12,\r\n    },\r\n    difficulty: 'medium',\r\n    initialBalls: 7,\r\n    targetBalls: 60,\r\n    maxBalls: 70,\r\n    speed: { base: 0.014, max: 0.022 },\r\n    colors: 6,\r\n    unlockCondition: 4,\r\n    ballSpacing: 0.013,\r\n    spawnPeriod: 1200,\r\n  },\r\n  {\r\n    id: 6,\r\n    name: \"Heart Path\",\r\n    nameRu: \"Сердце\",\r\n    description: \"Love-shaped challenge\",\r\n    descriptionRu: \"Путь в форме сердца\",\r\n    path: {\r\n      type: 'heart',\r\n      segments: 600,\r\n    },\r\n    difficulty: 'medium',\r\n    initialBalls: 7,\r\n    targetBalls: 55,\r\n    maxBalls: 65,\r\n    speed: { base: 0.013, max: 0.020 },\r\n    colors: 6,\r\n    unlockCondition: 5,\r\n  },\r\n  {\r\n    id: 7,\r\n    name: \"Infinity Loop\",\r\n    nameRu: \"Бесконечность\",\r\n    description: \"Figure-eight path\",\r\n    descriptionRu: \"Путь в форме восьмёрки\",\r\n    path: {\r\n      type: 'infinity',\r\n      segments: 650,\r\n    },\r\n    difficulty: 'hard',\r\n    initialBalls: 8,\r\n    targetBalls: 65,\r\n    maxBalls: 75,\r\n    speed: { base: 0.015, max: 0.023 },\r\n    colors: 7,\r\n    unlockCondition: 6,\r\n  },\r\n  {\r\n    id: 8,\r\n    name: \"Extreme Zigzag\",\r\n    nameRu: \"Экстремальный зигзаг\",\r\n    description: \"Fast and furious turns\",\r\n    descriptionRu: \"Быстрые и яростные повороты\",\r\n    path: {\r\n      type: 'zigzag',\r\n      segments: 600,\r\n      amplitude: 0.30,\r\n      frequency: 8,\r\n    },\r\n    difficulty: 'hard',\r\n    initialBalls: 8,\r\n    targetBalls: 70,\r\n    maxBalls: 80,\r\n    speed: { base: 0.016, max: 0.024 },\r\n    colors: 7,\r\n    unlockCondition: 7,\r\n  },\r\n  {\r\n    id: 9,\r\n    name: \"Chaos Wave\",\r\n    nameRu: \"Хаос волна\",\r\n    description: \"Complex wave pattern\",\r\n    descriptionRu: \"Сложный волновой паттерн\",\r\n    path: {\r\n      type: 'wave',\r\n      segments: 700,\r\n      amplitude: 0.25,\r\n      frequency: 5,\r\n    },\r\n    difficulty: 'hard',\r\n    initialBalls: 10,\r\n    targetBalls: 75,\r\n    maxBalls: 85,\r\n    speed: { base: 0.017, max: 0.026 },\r\n    colors: 8,\r\n    unlockCondition: 8,\r\n  },\r\n  {\r\n    id: 10,\r\n    name: \"Ultimate Spiral\",\r\n    nameRu: \"Ультимативная спираль\",\r\n    description: \"The final challenge\",\r\n    descriptionRu: \"Финальное испытание\",\r\n    path: {\r\n      type: 'spiral',\r\n      segments: 800,\r\n      spiralTurns: 5.5,\r\n      outerRadius: 0.44,\r\n      innerRadius: 0.10,\r\n    },\r\n    difficulty: 'hard',\r\n    initialBalls: 12,\r\n    targetBalls: 80,\r\n    maxBalls: 90,\r\n    speed: { base: 0.015, max: 0.024 },\r\n    colors: 8,\r\n    unlockCondition: 9,\r\n  },\r\n];\r\n\r\nexport function getLevelById(id: number): LevelConfig | undefined {\r\n  return LEVELS.find(level => level.id === id);\r\n}\r\n\r\nexport function getUnlockedLevels(completedLevels: number[]): LevelConfig[] {\r\n  return LEVELS.filter(level => {\r\n    if (level.unlockCondition === null) return true;\r\n    return completedLevels.includes(level.unlockCondition);\r\n  });\r\n}\r\n\r\nexport function isLevelUnlocked(levelId: number, completedLevels: number[]): boolean {\r\n  const level = getLevelById(levelId);\r\n  if (!level) return false;\r\n  if (level.unlockCondition === null) return true;\r\n  return completedLevels.includes(level.unlockCondition);\r\n}\r\n\r\nexport function getDifficultyColor(difficulty: LevelConfig['difficulty']): string {\r\n  switch (difficulty) {\r\n    case 'easy': return 'text-green-500';\r\n    case 'medium': return 'text-yellow-500';\r\n    case 'hard': return 'text-red-500';\r\n    default: return 'text-gray-500';\r\n  }\r\n}\r\n\r\nexport function getDifficultyBgColor(difficulty: LevelConfig['difficulty']): string {\r\n  switch (difficulty) {\r\n    case 'easy': return 'bg-green-500/20';\r\n    case 'medium': return 'bg-yellow-500/20';\r\n    case 'hard': return 'bg-red-500/20';\r\n    default: return 'bg-gray-500/20';\r\n  }\r\n}\r\n\r\nexport function getDifficultyLabel(difficulty: LevelConfig['difficulty']): string {\r\n  switch (difficulty) {\r\n    case 'easy': return 'Лёгкий';\r\n    case 'medium': return 'Средний';\r\n    case 'hard': return 'Сложный';\r\n    default: return difficulty;\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2528, "column": 0}, "map": {"version":3,"sources":["file:///D:/BeadsLine/hooks/use-toast.ts"],"sourcesContent":["import * as React from \"react\"\r\n\r\nimport type {\r\n  ToastActionElement,\r\n  ToastProps,\r\n} from \"@/components/ui/toast\"\r\n\r\nconst TOAST_LIMIT = 1\r\nconst TOAST_REMOVE_DELAY = 1000000\r\n\r\ntype ToasterToast = ToastProps & {\r\n  id: string\r\n  title?: React.ReactNode\r\n  description?: React.ReactNode\r\n  action?: ToastActionElement\r\n}\r\n\r\nconst actionTypes = {\r\n  ADD_TOAST: \"ADD_TOAST\",\r\n  UPDATE_TOAST: \"UPDATE_TOAST\",\r\n  DISMISS_TOAST: \"DISMISS_TOAST\",\r\n  REMOVE_TOAST: \"REMOVE_TOAST\",\r\n} as const\r\n\r\nlet count = 0\r\n\r\nfunction genId() {\r\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\r\n  return count.toString()\r\n}\r\n\r\ntype ActionType = typeof actionTypes\r\n\r\ntype Action =\r\n  | {\r\n      type: ActionType[\"ADD_TOAST\"]\r\n      toast: ToasterToast\r\n    }\r\n  | {\r\n      type: ActionType[\"UPDATE_TOAST\"]\r\n      toast: Partial<ToasterToast>\r\n    }\r\n  | {\r\n      type: ActionType[\"DISMISS_TOAST\"]\r\n      toastId?: ToasterToast[\"id\"]\r\n    }\r\n  | {\r\n      type: ActionType[\"REMOVE_TOAST\"]\r\n      toastId?: ToasterToast[\"id\"]\r\n    }\r\n\r\ninterface State {\r\n  toasts: ToasterToast[]\r\n}\r\n\r\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\r\n\r\nconst addToRemoveQueue = (toastId: string) => {\r\n  if (toastTimeouts.has(toastId)) {\r\n    return\r\n  }\r\n\r\n  const timeout = setTimeout(() => {\r\n    toastTimeouts.delete(toastId)\r\n    dispatch({\r\n      type: \"REMOVE_TOAST\",\r\n      toastId: toastId,\r\n    })\r\n  }, TOAST_REMOVE_DELAY)\r\n\r\n  toastTimeouts.set(toastId, timeout)\r\n}\r\n\r\nexport const reducer = (state: State, action: Action): State => {\r\n  switch (action.type) {\r\n    case \"ADD_TOAST\":\r\n      return {\r\n        ...state,\r\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\r\n      }\r\n\r\n    case \"UPDATE_TOAST\":\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.map((t) =>\r\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\r\n        ),\r\n      }\r\n\r\n    case \"DISMISS_TOAST\": {\r\n      const { toastId } = action\r\n\r\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\r\n      // but I'll keep it here for simplicity\r\n      if (toastId) {\r\n        addToRemoveQueue(toastId)\r\n      } else {\r\n        state.toasts.forEach((toast) => {\r\n          addToRemoveQueue(toast.id)\r\n        })\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.map((t) =>\r\n          t.id === toastId || toastId === undefined\r\n            ? {\r\n                ...t,\r\n                open: false,\r\n              }\r\n            : t\r\n        ),\r\n      }\r\n    }\r\n    case \"REMOVE_TOAST\":\r\n      if (action.toastId === undefined) {\r\n        return {\r\n          ...state,\r\n          toasts: [],\r\n        }\r\n      }\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\r\n      }\r\n  }\r\n}\r\n\r\nconst listeners: Array<(state: State) => void> = []\r\n\r\nlet memoryState: State = { toasts: [] }\r\n\r\nfunction dispatch(action: Action) {\r\n  memoryState = reducer(memoryState, action)\r\n  listeners.forEach((listener) => {\r\n    listener(memoryState)\r\n  })\r\n}\r\n\r\ntype Toast = Omit<ToasterToast, \"id\">\r\n\r\nfunction toast({ ...props }: Toast) {\r\n  const id = genId()\r\n\r\n  const update = (props: ToasterToast) =>\r\n    dispatch({\r\n      type: \"UPDATE_TOAST\",\r\n      toast: { ...props, id },\r\n    })\r\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\r\n\r\n  dispatch({\r\n    type: \"ADD_TOAST\",\r\n    toast: {\r\n      ...props,\r\n      id,\r\n      open: true,\r\n      onOpenChange: (open) => {\r\n        if (!open) dismiss()\r\n      },\r\n    },\r\n  })\r\n\r\n  return {\r\n    id: id,\r\n    dismiss,\r\n    update,\r\n  }\r\n}\r\n\r\nfunction useToast() {\r\n  const [state, setState] = React.useState<State>(memoryState)\r\n\r\n  React.useEffect(() => {\r\n    listeners.push(setState)\r\n    return () => {\r\n      const index = listeners.indexOf(setState)\r\n      if (index > -1) {\r\n        listeners.splice(index, 1)\r\n      }\r\n    }\r\n  }, [state])\r\n\r\n  return {\r\n    ...state,\r\n    toast,\r\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\r\n  }\r\n}\r\n\r\nexport { useToast, toast }\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2683, "column": 0}, "map": {"version":3,"sources":["file:///D:/BeadsLine/hooks/useGameState.ts"],"sourcesContent":["import { useState, useCallback, useRef, useEffect } from 'react';\r\nimport type { GameState, Ball } from '@shared/schema';\r\nimport {\r\n  createInitialGameState,\r\n  createRandomBall,\r\n  createBallFromChain,\r\n  generatePathForLevel,\r\n  getShooterPosition,\r\n  updateBallPositions,\r\n  moveBallsForward,\r\n  processRollback,\r\n  findMatchingBalls,\r\n  findAllMatches,\r\n  calculatePoints,\r\n  insertBallInChain,\r\n  removeBalls,\r\n  checkCollision,\r\n  checkPathCollision,\r\n  checkGameOver,\r\n  checkWin,\r\n  setAvailableCrypto,\r\n  setUsdtFundEnabled,\r\n  setEconomyConfig,\r\n  setGameplayConfig,\r\n  getGameplayConfig,\r\n  getBallSpacing,\r\n  resetCryptoSpawnedCount,\r\n  setCurrentLevel,\r\n  updateBoostTimers,\r\n  consumeBomb,\r\n  applyBombEffect,\r\n  consumeRainbow,\r\n  consumeRewind,\r\n  applyRewindEffect,\r\n  consumeShield,\r\n  consumeMagnet,\r\n  applyMagnetEffect,\r\n  consumeLaser,\r\n  applyLaserEffect,\r\n  SHOOTER_BALL_SPEED,\r\n  debugLog,\r\n  activateRollback,\r\n  isRollbackActive,\r\n  type PathPoint,\r\n} from '@/lib/gameEngine';\r\nimport { GAME_CONFIG } from '@/lib/gameConfig';\r\nimport { hapticFeedback } from '@/lib/telegram';\r\nimport { \r\n  playShootSound, \r\n  playMatchSound, \r\n  playCryptoMatchSound, \r\n  playComboSound,\r\n  playLifeLostSound,\r\n  playWinSound,\r\n  playGameOverSound,\r\n  initSounds\r\n} from '@/lib/sounds';\r\nimport type { LevelConfig } from '@/lib/levelConfig';\r\n\r\ninterface UseGameStateProps {\r\n  canvasWidth: number;\r\n  canvasHeight: number;\r\n  onGameEnd?: (state: GameState) => void;\r\n  level: LevelConfig;\r\n  bonusLives?: number;\r\n  onUseBonusLife?: () => void;\r\n}\r\n\r\ninterface Projectile {\r\n  x: number;\r\n  y: number;\r\n  prevX: number;\r\n  prevY: number;\r\n  vx: number;\r\n  vy: number;\r\n  ball: Ball;\r\n}\r\n\r\ninterface GapContext {\r\n  leftBallId: string | null;\r\n  rightBallId: string | null;\r\n}\r\n\r\ninterface PendingChainReaction {\r\n  matchedBallIds: string[];\r\n  newLeftBallId: string | null;\r\n  newRightBallId: string | null;\r\n  combo: number;\r\n}\r\n\r\nconst CHAIN_REACTION_DELAY = 150;\r\n\r\n// Debug log buffer - accumulates logs and sends them in batches\r\nconst debugLogBuffer: string[] = [];\r\nlet debugLogTimeout: ReturnType<typeof setTimeout> | null = null;\r\n\r\nfunction sendDebugLog(message: string) {\r\n  const timestamp = new Date().toISOString().slice(11, 23);\r\n  debugLogBuffer.push(`[${timestamp}] ${message}`);\r\n  \r\n  // Debounce sending - wait 500ms after last log before sending batch\r\n  if (debugLogTimeout) clearTimeout(debugLogTimeout);\r\n  debugLogTimeout = setTimeout(() => {\r\n    if (debugLogBuffer.length > 0) {\r\n      const logsToSend = [...debugLogBuffer];\r\n      debugLogBuffer.length = 0;\r\n      fetch('/api/debug-logs', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({ logs: logsToSend }),\r\n      }).catch(() => {}); // Ignore errors\r\n    }\r\n  }, 500);\r\n}\r\n\r\nexport function useGameState({ canvasWidth, canvasHeight, onGameEnd, level, bonusLives = 0, onUseBonusLife }: UseGameStateProps) {\r\n  const [gameState, setGameState] = useState<GameState>(createInitialGameState);\r\n  const [path, setPath] = useState<PathPoint[]>([]);\r\n  const [projectile, setProjectile] = useState<Projectile | null>(null);\r\n  const [shooterAngle, setShooterAngle] = useState(-Math.PI / 2);\r\n  const [elapsedTime, setElapsedTime] = useState(0);\r\n  const [usedBonusLives, setUsedBonusLives] = useState(0);\r\n  const [isPaused, setIsPaused] = useState(false);\r\n  \r\n  const isPausedRef = useRef(false);\r\n  const stepFrameRef = useRef(false);\r\n  const gameLoopRef = useRef<number | null>(null);\r\n  const timeTrackerRef = useRef<ReturnType<typeof setInterval> | null>(null);\r\n  const lastTimeRef = useRef<number>(0);\r\n  const pathRef = useRef<PathPoint[]>([]);\r\n  const onGameEndRef = useRef(onGameEnd);\r\n  const gameEndedRef = useRef(false);\r\n  const dimensionsRef = useRef({ width: canvasWidth, height: canvasHeight });\r\n  const gameStartTimeRef = useRef<number>(0);\r\n  const spawnAccumRef = useRef<number>(0);\r\n  const totalSpawnedRef = useRef<number>(0);\r\n  const spawnFinishedRef = useRef<boolean>(false);\r\n  const gapContextRef = useRef<GapContext | null>(null);\r\n  const maxTotalBallsRef = useRef<number>(100);\r\n  const currentLifeMaxRef = useRef<number>(100); // Лимит шаров на текущую жизнь\r\n  const pendingChainReactionRef = useRef<PendingChainReaction | null>(null);\r\n  const bonusLivesRef = useRef(bonusLives);\r\n  const usedBonusLivesRef = useRef(0);\r\n  const onUseBonusLifeRef = useRef(onUseBonusLife);\r\n  const shooterBallRef = useRef(gameState.shooterBall);\r\n  \r\n  useEffect(() => {\r\n    shooterBallRef.current = gameState.shooterBall;\r\n  }, [gameState.shooterBall]);\r\n  \r\n  useEffect(() => {\r\n    bonusLivesRef.current = bonusLives;\r\n  }, [bonusLives]);\r\n  \r\n  useEffect(() => {\r\n    onUseBonusLifeRef.current = onUseBonusLife;\r\n  }, [onUseBonusLife]);\r\n  const chainReactionTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\r\n  \r\n  onGameEndRef.current = onGameEnd;\r\n  pathRef.current = path;\r\n  dimensionsRef.current = { width: canvasWidth, height: canvasHeight };\r\n  \r\n  const shooterPosition = getShooterPosition(canvasWidth, canvasHeight);\r\n\r\n  useEffect(() => {\r\n    if (canvasWidth > 0 && canvasHeight > 0) {\r\n      setCurrentLevel(level);\r\n      const newPath = generatePathForLevel(canvasWidth, canvasHeight, level);\r\n      setPath(newPath);\r\n      pathRef.current = newPath;\r\n    }\r\n  }, [canvasWidth, canvasHeight, level]);\r\n\r\n  const stopAllTimers = useCallback(() => {\r\n    if (gameLoopRef.current !== null) {\r\n      cancelAnimationFrame(gameLoopRef.current);\r\n      gameLoopRef.current = null;\r\n    }\r\n    if (timeTrackerRef.current !== null) {\r\n      clearInterval(timeTrackerRef.current);\r\n      timeTrackerRef.current = null;\r\n    }\r\n    if (chainReactionTimeoutRef.current !== null) {\r\n      clearTimeout(chainReactionTimeoutRef.current);\r\n      chainReactionTimeoutRef.current = null;\r\n    }\r\n    pendingChainReactionRef.current = null;\r\n  }, []);\r\n\r\n  const startGame = useCallback(async () => {\r\n    if (timeTrackerRef.current !== null) {\r\n      console.warn('Game already running, ignoring startGame call');\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      const [economyRes, gameplayRes, cryptoAvailRes] = await Promise.all([\r\n        fetch('/api/game-economy'),\r\n        fetch('/api/gameplay-config'),\r\n        fetch('/api/crypto-availability', { credentials: 'include' }),\r\n      ]);\r\n      \r\n      // Default to crypto disabled for safety\r\n      let cryptoAvailable = { btc: false, eth: false, usdt: false };\r\n      \r\n      if (economyRes.ok) {\r\n        const economyData = await economyRes.json();\r\n        setEconomyConfig(economyData);\r\n        // Get crypto availability from economy config (respects cryptoFundEnabled toggle)\r\n        cryptoAvailable = economyData.cryptoAvailable || { btc: false, eth: false, usdt: false };\r\n        setUsdtFundEnabled(economyData.usdtFundEnabled === true);\r\n      }\r\n      \r\n      if (cryptoAvailRes.ok) {\r\n        const cryptoAvail = await cryptoAvailRes.json();\r\n        // Only override if crypto-availability returns explicit values\r\n        // This endpoint also respects cryptoFundEnabled, so use AND logic\r\n        cryptoAvailable = {\r\n          btc: cryptoAvailable.btc && (cryptoAvail.btcEnabled === true),\r\n          eth: cryptoAvailable.eth && (cryptoAvail.ethEnabled === true),\r\n          usdt: cryptoAvailable.usdt && (cryptoAvail.usdtEnabled === true),\r\n        };\r\n      }\r\n      \r\n      setAvailableCrypto(cryptoAvailable);\r\n      \r\n      if (gameplayRes.ok) {\r\n        const gameplayData = await gameplayRes.json();\r\n        // Override with level-specific spawn period if available\r\n        if (level?.spawnPeriod) {\r\n          gameplayData.spawn = { ...gameplayData.spawn, period: level.spawnPeriod };\r\n        }\r\n        setGameplayConfig(gameplayData);\r\n        maxTotalBallsRef.current = gameplayData.balls?.maxTotalBalls || 100;\r\n        currentLifeMaxRef.current = maxTotalBallsRef.current; // Изначально = максимум\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to fetch game config:', error);\r\n      // Default to crypto disabled for safety when API fails\r\n      setAvailableCrypto({ btc: false, eth: false, usdt: false });\r\n      setUsdtFundEnabled(false);\r\n    }\r\n    \r\n    stopAllTimers();\r\n    gameEndedRef.current = false;\r\n    gameStartTimeRef.current = Date.now();\r\n    setElapsedTime(0);\r\n    \r\n    resetCryptoSpawnedCount();\r\n    \r\n    const dims = dimensionsRef.current;\r\n    setCurrentLevel(level);\r\n    const newPath = generatePathForLevel(dims.width, dims.height, level);\r\n    setPath(newPath);\r\n    pathRef.current = newPath;\r\n    \r\n    const initialState = createInitialGameState();\r\n    const ballsWithPositions = updateBallPositions(initialState.balls, newPath);\r\n    \r\n    setGameState({\r\n      ...initialState,\r\n      balls: ballsWithPositions,\r\n      isPlaying: true,\r\n      timeLeft: 0,\r\n    });\r\n    setProjectile(null);\r\n    setShooterAngle(-Math.PI / 2);\r\n    lastTimeRef.current = 0;\r\n    spawnAccumRef.current = 0;\r\n    totalSpawnedRef.current = getGameplayConfig().balls.initialCount;\r\n    spawnFinishedRef.current = false;\r\n    gapContextRef.current = null;\r\n    \r\n    // Track frame count for debug logging\r\n    let frameCount = 0;\r\n    \r\n    const runLoop = (timestamp: number) => {\r\n      if (gameEndedRef.current) return;\r\n\r\n      if (isPausedRef.current && !stepFrameRef.current) {\r\n        lastTimeRef.current = timestamp; // Keep time up to date to avoid jump\r\n        gameLoopRef.current = requestAnimationFrame(runLoop);\r\n        return;\r\n      }\r\n      if (stepFrameRef.current) {\r\n        stepFrameRef.current = false; // Consume step signal\r\n      }\r\n      \r\n      frameCount++;\r\n      \r\n      const deltaTime = lastTimeRef.current ? timestamp - lastTimeRef.current : 16;\r\n      lastTimeRef.current = timestamp;\r\n      const currentPath = pathRef.current;\r\n      \r\n      updateBoostTimers();\r\n      \r\n      if (pendingChainReactionRef.current) {\r\n        gameLoopRef.current = requestAnimationFrame(runLoop);\r\n        return;\r\n      }\r\n      \r\n      // Log gap context state every 60 frames (roughly once per second)\r\n      if (gapContextRef.current && Math.random() < 0.02) {\r\n        sendDebugLog(`[LOOP] gap exists: L:${gapContextRef.current.leftBallId?.slice(-6)} R:${gapContextRef.current.rightBallId?.slice(-6)}`);\r\n      }\r\n      \r\n      setGameState(prev => {\r\n        if (!prev.isPlaying || gameEndedRef.current) return prev;\r\n        \r\n        // During rollback, pause forward movement to let chain close gaps properly\r\n        let newBalls = isRollbackActive() \r\n          ? prev.balls \r\n          : moveBallsForward(prev.balls, deltaTime);\r\n        \r\n        newBalls = processRollback(newBalls, deltaTime, spawnFinishedRef.current);\r\n        \r\n        let updatedState = prev;\r\n        \r\n        const gap = gapContextRef.current;\r\n        // Debug: log gap status every check\r\n        if (gap) {\r\n          const leftIdx = gap.leftBallId ? newBalls.findIndex(b => b.id === gap.leftBallId) : -1;\r\n          const rightIdx = gap.rightBallId ? newBalls.findIndex(b => b.id === gap.rightBallId) : -1;\r\n          const isAdj = rightIdx === leftIdx + 1;\r\n          // Only log when adjacent or first time\r\n          if (isAdj) {\r\n            sendDebugLog(`[GAP-FOUND] L:${leftIdx} R:${rightIdx} adj:${isAdj} len:${newBalls.length}`);\r\n          }\r\n        }\r\n        if (gap && newBalls.length >= 3) {\r\n          const leftIdx = gap.leftBallId ? newBalls.findIndex(b => b.id === gap.leftBallId) : -1;\r\n          const rightIdx = gap.rightBallId ? newBalls.findIndex(b => b.id === gap.rightBallId) : -1;\r\n          \r\n          // Log every frame when gap context exists (only log when adjacent to reduce spam)\r\n          if (rightIdx === leftIdx + 1 || leftIdx < 0 || rightIdx < 0) {\r\n            sendDebugLog(`[GAP] leftIdx:${leftIdx} rightIdx:${rightIdx} adj:${rightIdx === leftIdx + 1} left:${gap.leftBallId?.slice(-6)} right:${gap.rightBallId?.slice(-6)}`);\r\n          }\r\n          \r\n          let foundMatch = false;\r\n          let matchesToProcess: number[] | null = null;\r\n          \r\n          if (leftIdx >= 0 && rightIdx >= 0 && rightIdx === leftIdx + 1) {\r\n            const leftBall = newBalls[leftIdx];\r\n            const rightBall = newBalls[rightIdx];\r\n            \r\n            // Check if balls match: crypto balls match by crypto type, regular balls by color\r\n            const ballsDoMatch = (leftBall.crypto && rightBall.crypto) \r\n              ? leftBall.crypto === rightBall.crypto \r\n              : (!leftBall.crypto && !rightBall.crypto && leftBall.color === rightBall.color);\r\n            \r\n            sendDebugLog(`[CHECK] L:${leftBall.id.slice(-6)} ${leftBall.color}/${leftBall.crypto || 'reg'} R:${rightBall.id.slice(-6)} ${rightBall.color}/${rightBall.crypto || 'reg'} match:${ballsDoMatch}`);\r\n            \r\n            if (ballsDoMatch) {\r\n              // Boundary balls match - check for 3+ chain that includes both\r\n              const matches = findMatchingBalls(newBalls, leftIdx, leftBall);\r\n              sendDebugLog(`[MATCH] found:${matches.length} both:${matches.includes(leftIdx) && matches.includes(rightIdx)}`);\r\n              \r\n              if (matches.length >= 3 && matches.includes(leftIdx) && matches.includes(rightIdx)) {\r\n                foundMatch = true;\r\n                matchesToProcess = matches;\r\n              }\r\n            } else {\r\n              // Boundary balls DON'T match - check each side independently for 3+ chains\r\n              // Check LEFT side: leftBall and its left neighbors\r\n              const leftMatches = findMatchingBalls(newBalls, leftIdx, leftBall);\r\n              sendDebugLog(`[LEFT] matches:${leftMatches.length} hasLeft:${leftMatches.includes(leftIdx)}`);\r\n              if (leftMatches.length >= 3 && leftMatches.includes(leftIdx)) {\r\n                foundMatch = true;\r\n                matchesToProcess = leftMatches;\r\n              }\r\n              \r\n              // Check RIGHT side: rightBall and its right neighbors (only if left didn't match)\r\n              if (!foundMatch) {\r\n                const rightMatches = findMatchingBalls(newBalls, rightIdx, rightBall);\r\n                sendDebugLog(`[RIGHT] matches:${rightMatches.length} hasRight:${rightMatches.includes(rightIdx)}`);\r\n                if (rightMatches.length >= 3 && rightMatches.includes(rightIdx)) {\r\n                  foundMatch = true;\r\n                  matchesToProcess = rightMatches;\r\n                }\r\n              }\r\n            }\r\n          } else if (leftIdx >= 0 && rightIdx < 0) {\r\n            sendDebugLog(`[EDGE] Only left exists, checking`);\r\n            const matches = findMatchingBalls(newBalls, leftIdx, newBalls[leftIdx]);\r\n            if (matches.length >= 3 && matches.includes(leftIdx)) {\r\n              foundMatch = true;\r\n              matchesToProcess = matches;\r\n            }\r\n          } else if (rightIdx >= 0 && leftIdx < 0) {\r\n            sendDebugLog(`[EDGE] Only right exists, checking`);\r\n            const matches = findMatchingBalls(newBalls, rightIdx, newBalls[rightIdx]);\r\n            if (matches.length >= 3 && matches.includes(rightIdx)) {\r\n              foundMatch = true;\r\n              matchesToProcess = matches;\r\n            }\r\n          } else if (leftIdx < 0 || rightIdx < 0) {\r\n            sendDebugLog(`[CLEAR] Ball not found! left:${leftIdx} right:${rightIdx}`);\r\n            gapContextRef.current = null;\r\n          }\r\n          \r\n          if (foundMatch && matchesToProcess) {\r\n            const matchedBalls = matchesToProcess.map(i => newBalls[i]);\r\n            const matchedBallIds = matchedBalls.map(b => b.id);\r\n            \r\n            sendDebugLog(`[CHAIN] Triggering chain reaction! Removing ${matchesToProcess.length} balls`);\r\n            \r\n            const minIdx = matchesToProcess[0];\r\n            const maxIdx = matchesToProcess[matchesToProcess.length - 1];\r\n            const newLeftBall = minIdx > 0 ? newBalls[minIdx - 1] : null;\r\n            const newRightBall = maxIdx < newBalls.length - 1 ? newBalls[maxIdx + 1] : null;\r\n            \r\n            pendingChainReactionRef.current = {\r\n              matchedBallIds,\r\n              newLeftBallId: newLeftBall?.id || null,\r\n              newRightBallId: newRightBall?.id || null,\r\n              combo: prev.combo\r\n            };\r\n            \r\n            chainReactionTimeoutRef.current = setTimeout(() => {\r\n              setGameState(currentState => {\r\n                if (!currentState.isPlaying || gameEndedRef.current) {\r\n                  pendingChainReactionRef.current = null;\r\n                  return currentState;\r\n                }\r\n                \r\n                const pending = pendingChainReactionRef.current;\r\n                if (!pending) return currentState;\r\n                \r\n                const ballIndicesToRemove = pending.matchedBallIds\r\n                  .map(id => currentState.balls.findIndex(b => b.id === id))\r\n                  .filter(idx => idx >= 0)\r\n                  .sort((a, b) => a - b);\r\n                \r\n                pendingChainReactionRef.current = null;\r\n                \r\n                if (ballIndicesToRemove.length < 3) {\r\n                  gapContextRef.current = null;\r\n                  return currentState;\r\n                }\r\n                \r\n                const matchedBalls = ballIndicesToRemove.map(i => currentState.balls[i]);\r\n                const chainCombo = pending.combo;\r\n                const newCombo = chainCombo + 1;\r\n                const { points, cryptoCollected, usdtFundCollected } = calculatePoints(matchedBalls, chainCombo);\r\n                \r\n                const processedBalls = removeBalls(currentState.balls, ballIndicesToRemove);\r\n                // Only arm portal retreat if very early in game (< 10 balls spawned)\r\n                const isEarlyGame = totalSpawnedRef.current < 10;\r\n                activateRollback(isEarlyGame);\r\n                \r\n                if (pending.newLeftBallId || pending.newRightBallId) {\r\n                  gapContextRef.current = { \r\n                    leftBallId: pending.newLeftBallId, \r\n                    rightBallId: pending.newRightBallId \r\n                  };\r\n                } else {\r\n                  gapContextRef.current = null;\r\n                }\r\n                \r\n                hapticFeedback('medium');\r\n                \r\n                const hasCrypto = matchedBalls.some(b => b.crypto || b.isUsdtFund);\r\n                if (hasCrypto) {\r\n                  playCryptoMatchSound();\r\n                } else {\r\n                  playMatchSound(newCombo);\r\n                }\r\n                if (newCombo > 1) {\r\n                  playComboSound(newCombo);\r\n                }\r\n                \r\n                const ballsWithPositions = updateBallPositions(processedBalls, pathRef.current);\r\n                \r\n                return {\r\n                  ...currentState,\r\n                  balls: ballsWithPositions,\r\n                  score: currentState.score + points,\r\n                  combo: newCombo,\r\n                  maxCombo: Math.max(currentState.maxCombo, newCombo),\r\n                  cryptoCollected: {\r\n                    btc: currentState.cryptoCollected.btc + cryptoCollected.btc,\r\n                    eth: currentState.cryptoCollected.eth + cryptoCollected.eth,\r\n                    usdt: currentState.cryptoCollected.usdt + cryptoCollected.usdt,\r\n                  },\r\n                  usdtFundCollected: currentState.usdtFundCollected + usdtFundCollected,\r\n                };\r\n              });\r\n            }, CHAIN_REACTION_DELAY);\r\n            \r\n            newBalls = updateBallPositions(newBalls, currentPath);\r\n            return { ...prev, balls: newBalls };\r\n          }\r\n          \r\n          if (!foundMatch) {\r\n            gapContextRef.current = null;\r\n          }\r\n        }\r\n        \r\n        const gameplayConfig = getGameplayConfig();\r\n        const { period } = gameplayConfig.spawn;\r\n        const buffer = GAME_CONFIG.spawn.buffer;\r\n        const { targetCount } = gameplayConfig.balls;\r\n        \r\n        spawnAccumRef.current += deltaTime;\r\n        \r\n        // Используем currentLifeMaxRef - лимит на текущую жизнь\r\n        const canSpawn = !spawnFinishedRef.current && \r\n                         newBalls.length < targetCount && \r\n                         totalSpawnedRef.current < currentLifeMaxRef.current;\r\n        \r\n        if (spawnAccumRef.current >= period && canSpawn) {\r\n          const spacing = getBallSpacing();\r\n          \r\n          // Find tail ball (lowest progress)\r\n          const tailBall = newBalls.length > 0 \r\n            ? newBalls.reduce((min, b) => b.pathProgress < min.pathProgress ? b : min, newBalls[0])\r\n            : null;\r\n          const tailProgress = tailBall?.pathProgress ?? spacing;\r\n          \r\n          // Spawn at correct logical position (adjacent to tail) for chain cohesion\r\n          const spawnPosition = Math.max(0, tailProgress - spacing);\r\n          \r\n          sendDebugLog(`[SPAWN] accum=${spawnAccumRef.current.toFixed(0)}ms, balls=${newBalls.length}, tailProg=${tailProgress.toFixed(4)}, spawnPos=${spawnPosition.toFixed(4)}`);\r\n          \r\n          spawnAccumRef.current = 0;\r\n          \r\n          // Create ball at correct position with spawn animation for visual portal emergence\r\n          const rawBall = createRandomBall(`spawn-${Date.now()}-${Math.random().toString(36).slice(2)}`, spawnPosition, newBalls);\r\n          const newBall = { ...rawBall, spawnAnimStart: Date.now() };\r\n          \r\n          sendDebugLog(`[SPAWN] Created ball at pos=${spawnPosition.toFixed(4)} with portal anim, id=${newBall.id.slice(0,10)}, color=${newBall.color}`);\r\n          \r\n          newBalls = [newBall, ...newBalls];\r\n          totalSpawnedRef.current++;\r\n          \r\n          if (totalSpawnedRef.current >= currentLifeMaxRef.current) {\r\n            spawnFinishedRef.current = true;\r\n          }\r\n        }\r\n        \r\n        newBalls = updateBallPositions(newBalls, currentPath);\r\n        \r\n        // Победа: все шары уничтожены И спавн завершён\r\n        if (checkWin(newBalls) && spawnFinishedRef.current) {\r\n          gameEndedRef.current = true;\r\n          stopAllTimers();\r\n          const duration = Math.floor((Date.now() - gameStartTimeRef.current) / 1000);\r\n          const finalState = { ...updatedState, balls: newBalls, isPlaying: false, isGameOver: true, won: true, timeLeft: duration };\r\n          setTimeout(() => {\r\n            onGameEndRef.current?.(finalState);\r\n            hapticFeedback('success');\r\n            playWinSound();\r\n          }, 0);\r\n          return finalState;\r\n        }\r\n        \r\n        if (checkGameOver(newBalls)) {\r\n          if (consumeShield()) {\r\n            const spacing = GAME_CONFIG.balls.spacing;\r\n            const beforeCount = newBalls.length;\r\n            \r\n            // FIX: Лимит шаров на следующую жизнь = сколько было на экране\r\n            currentLifeMaxRef.current = beforeCount;\r\n            sendDebugLog(`[ЩИТ] Сработал. Было ${beforeCount} шаров. Новый лимит: ${currentLifeMaxRef.current}`);\r\n            \r\n            let respawnedBalls = [...newBalls];\r\n            respawnedBalls.sort((a, b) => b.pathProgress - a.pathProgress);\r\n            \r\n            // FIX: keepCount = половина от того, что БЫЛО на экране\r\n            let keepCount = Math.ceil(beforeCount / 2);\r\n            keepCount = Math.min(keepCount, beforeCount);\r\n            respawnedBalls = respawnedBalls.slice(0, keepCount);\r\n            \r\n            const n = respawnedBalls.length;\r\n            if (n > 0) {\r\n              const headPos = 0.5; // Голова на 50%\r\n              \r\n              for (let i = 0; i < n; i++) {\r\n                const newProgress = Math.max(0, headPos - i * spacing);\r\n                respawnedBalls[i] = { \r\n                  ...respawnedBalls[i], \r\n                  pathProgress: newProgress,\r\n                  spawnAnimStart: undefined // Без анимации - сразу на позицию\r\n                };\r\n              }\r\n            }\r\n            \r\n            respawnedBalls.sort((a, b) => a.pathProgress - b.pathProgress);\r\n            respawnedBalls = updateBallPositions(respawnedBalls, currentPath);\r\n            \r\n            gapContextRef.current = null;\r\n            spawnFinishedRef.current = false;\r\n            // currentLifeMaxRef уже установлен\r\n            totalSpawnedRef.current = respawnedBalls.length;\r\n\r\n            sendDebugLog(`[ЩИТ] После: осталось ${respawnedBalls.length}, ещё выедут ${currentLifeMaxRef.current - respawnedBalls.length}`);\r\n            hapticFeedback('medium');\r\n            return { ...updatedState, balls: respawnedBalls, combo: 0 };\r\n          }\r\n          \r\n          const beforeLossCount = newBalls.length;\r\n          const maxProgressBefore = newBalls.length > 0 ? Math.max(...newBalls.map(b => b.pathProgress)) : 0;\r\n          \r\n          const newLives = updatedState.lives - 1;\r\n          sendDebugLog(`[ПОТЕРЯ ЖИЗНИ] До: ${beforeLossCount} шаров, голова на ${(maxProgressBefore * 100).toFixed(0)}%, осталось жизней: ${newLives}.`);\r\n          \r\n          if (newLives <= 0) {\r\n            // Проверяем есть ли бонусные жизни из BEADS BOX\r\n            const availableBonusLives = bonusLivesRef.current - usedBonusLivesRef.current;\r\n            \r\n            if (availableBonusLives > 0) {\r\n              // Используем бонусную жизнь\r\n              usedBonusLivesRef.current += 1;\r\n              setUsedBonusLives(prev => prev + 1);\r\n              \r\n              // Вызываем callback для списания бонусной жизни с сервера\r\n              setTimeout(() => {\r\n                onUseBonusLifeRef.current?.();\r\n              }, 0);\r\n              \r\n              // Сбрасываем шарики в начало (как при обычной потере жизни)\r\n              const spacing = GAME_CONFIG.balls.spacing;\r\n              \r\n              let respawnedBalls = [...newBalls];\r\n              respawnedBalls.sort((a, b) => b.pathProgress - a.pathProgress);\r\n              \r\n              let keepCount = Math.ceil(beforeLossCount / 2);\r\n              keepCount = Math.min(keepCount, beforeLossCount);\r\n              respawnedBalls = respawnedBalls.slice(0, keepCount);\r\n              \r\n              const n = respawnedBalls.length;\r\n              if (n > 0) {\r\n                const headPos = 0.5; // Голова на 50%\r\n                \r\n                for (let i = 0; i < n; i++) {\r\n                  const newProgress = Math.max(0, headPos - i * spacing);\r\n                  respawnedBalls[i] = { \r\n                    ...respawnedBalls[i], \r\n                    pathProgress: newProgress,\r\n                    spawnAnimStart: undefined // Без анимации - сразу на позицию\r\n                  };\r\n                }\r\n              }\r\n              \r\n              respawnedBalls.sort((a, b) => a.pathProgress - b.pathProgress);\r\n              respawnedBalls = updateBallPositions(respawnedBalls, currentPath);\r\n              \r\n              gapContextRef.current = null;\r\n              spawnFinishedRef.current = false;\r\n              currentLifeMaxRef.current = maxTotalBallsRef.current; // FIX: Лимит всегда сбрасывается на максимум\r\n              totalSpawnedRef.current = respawnedBalls.length;\r\n              \r\n              sendDebugLog(`[ПОТЕРЯ ЖИЗНИ] После (бонус): было ${beforeLossCount}, осталось ${respawnedBalls.length}, ещё выедут ${currentLifeMaxRef.current - respawnedBalls.length}`);\r\n              hapticFeedback('warning');\r\n              playLifeLostSound();\r\n              return { ...updatedState, balls: respawnedBalls, lives: 1, combo: 0 };\r\n            }\r\n            \r\n            // Нет бонусных жизней - конец игры\r\n            gameEndedRef.current = true;\r\n            stopAllTimers();\r\n            const duration = Math.floor((Date.now() - gameStartTimeRef.current) / 1000);\r\n            const finalState = { ...updatedState, balls: newBalls, lives: 0, isPlaying: false, isGameOver: true, won: false, timeLeft: duration };\r\n            setTimeout(() => {\r\n              onGameEndRef.current?.(finalState);\r\n              hapticFeedback('error');\r\n              playGameOverSound();\r\n            }, 0);\r\n            return finalState;\r\n          }\r\n          \r\n          const spacing = GAME_CONFIG.balls.spacing;\r\n          \r\n          let respawnedBalls = [...newBalls];\r\n          respawnedBalls.sort((a, b) => b.pathProgress - a.pathProgress);\r\n          \r\n          let keepCount = Math.ceil(beforeLossCount / 2);\r\n          keepCount = Math.min(keepCount, beforeLossCount);\r\n          respawnedBalls = respawnedBalls.slice(0, keepCount);\r\n          \r\n          const n = respawnedBalls.length;\r\n          if (n > 0) {\r\n            const headPos = 0.5; // Голова на 50%\r\n            \r\n            for (let i = 0; i < n; i++) {\r\n              const newProgress = Math.max(0, headPos - i * spacing);\r\n              respawnedBalls[i] = { \r\n                ...respawnedBalls[i], \r\n                pathProgress: newProgress,\r\n                spawnAnimStart: undefined // Без анимации - сразу на позицию\r\n              };\r\n            }\r\n          }\r\n          \r\n          respawnedBalls.sort((a, b) => a.pathProgress - b.pathProgress);\r\n          respawnedBalls = updateBallPositions(respawnedBalls, currentPath);\r\n          \r\n          gapContextRef.current = null;\r\n          spawnFinishedRef.current = false;\r\n          currentLifeMaxRef.current = maxTotalBallsRef.current; // FIX: Лимит всегда сбрасывается на максимум\r\n          totalSpawnedRef.current = respawnedBalls.length;\r\n          \r\n          sendDebugLog(`[ПОТЕРЯ ЖИЗНИ] Было ${beforeLossCount} шаров, осталось ${respawnedBalls.length}, ещё выедут ${currentLifeMaxRef.current - respawnedBalls.length}`);\r\n          hapticFeedback('warning');\r\n          playLifeLostSound();\r\n          return { ...updatedState, balls: respawnedBalls, lives: newLives, combo: 0 };\r\n        }\r\n        \r\n        return { ...updatedState, balls: newBalls };\r\n      });\r\n      \r\n      setProjectile(prev => {\r\n        if (!prev || gameEndedRef.current) return prev;\r\n        \r\n        const dims = dimensionsRef.current;\r\n        const newX = prev.x + prev.vx;\r\n        const newY = prev.y + prev.vy;\r\n        \r\n        if (newX < 0 || newX > dims.width || newY < 0 || newY > dims.height) {\r\n          return null;\r\n        }\r\n        \r\n        return { ...prev, prevX: prev.x, prevY: prev.y, x: newX, y: newY };\r\n      });\r\n      \r\n      gameLoopRef.current = requestAnimationFrame(runLoop);\r\n    };\r\n    \r\n    gameLoopRef.current = requestAnimationFrame(runLoop);\r\n    \r\n    timeTrackerRef.current = setInterval(() => {\r\n      if (gameEndedRef.current) return;\r\n      setElapsedTime(Math.floor((Date.now() - gameStartTimeRef.current) / 1000));\r\n    }, 1000);\r\n    \r\n    hapticFeedback('medium');\r\n  }, [stopAllTimers]);\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      stopAllTimers();\r\n    };\r\n  }, [stopAllTimers]);\r\n\r\n  useEffect(() => {\r\n    if (!projectile || gameEndedRef.current) return;\r\n    \r\n    setGameState(prev => {\r\n      if (!prev.isPlaying || gameEndedRef.current) return prev;\r\n      \r\n      const collision = checkPathCollision(\r\n        projectile.x, projectile.y,\r\n        projectile.prevX, projectile.prevY,\r\n        prev.balls, pathRef.current\r\n      );\r\n      \r\n      if (collision) {\r\n        const insertIndex = collision.insertBefore ? collision.index : collision.index + 1;\r\n        \r\n        // Check if laser boost is active - pierces through balls without inserting\r\n        const laserResult = consumeLaser();\r\n        if (laserResult.active) {\r\n          const hitIndices: number[] = [];\r\n          for (let i = 0; i < Math.min(laserResult.pierceCount, prev.balls.length); i++) {\r\n            const idx = collision.index + i;\r\n            if (idx >= 0 && idx < prev.balls.length) {\r\n              hitIndices.push(idx);\r\n            }\r\n          }\r\n          \r\n          if (hitIndices.length > 0) {\r\n            const { newBalls: laserBalls, removedBalls } = applyLaserEffect(prev.balls, hitIndices);\r\n            const updatedBalls = updateBallPositions(laserBalls, pathRef.current);\r\n            \r\n            const { points, cryptoCollected, usdtFundCollected } = calculatePoints(removedBalls, 0);\r\n            \r\n            hapticFeedback('heavy');\r\n            playComboSound(removedBalls.length);\r\n            \r\n            const hasCrypto = removedBalls.some(b => b.crypto || b.isUsdtFund);\r\n            if (hasCrypto) {\r\n              playCryptoMatchSound();\r\n            } else {\r\n              playMatchSound();\r\n            }\r\n            \r\n            gapContextRef.current = null;\r\n            setProjectile(null);\r\n            \r\n            return {\r\n              ...prev,\r\n              balls: updatedBalls,\r\n              score: prev.score + points,\r\n              combo: removedBalls.length,\r\n              maxCombo: Math.max(prev.maxCombo, removedBalls.length),\r\n              cryptoCollected: {\r\n                btc: prev.cryptoCollected.btc + cryptoCollected.btc,\r\n                eth: prev.cryptoCollected.eth + cryptoCollected.eth,\r\n                usdt: prev.cryptoCollected.usdt + cryptoCollected.usdt,\r\n              },\r\n              usdtFundCollected: prev.usdtFundCollected + usdtFundCollected,\r\n              shooterBall: prev.nextBall,\r\n              nextBall: createRandomBall('next-' + Date.now(), 0, prev.balls, true),\r\n            };\r\n          }\r\n        }\r\n        \r\n        let newBalls = insertBallInChain(prev.balls, projectile.ball, insertIndex);\r\n        newBalls = updateBallPositions(newBalls, pathRef.current);\r\n        \r\n        // Check if magnet boost is active - attracts same color balls closer\r\n        const magnetResult = consumeMagnet();\r\n        if (magnetResult.active) {\r\n          newBalls = applyMagnetEffect(newBalls, insertIndex, magnetResult.radius);\r\n          newBalls = updateBallPositions(newBalls, pathRef.current);\r\n          hapticFeedback('medium');\r\n        }\r\n        \r\n        // Check if bomb boost is active\r\n        if (consumeBomb()) {\r\n          const { newBalls: bombedBalls, removedBalls } = applyBombEffect(newBalls, insertIndex, 5);\r\n          newBalls = bombedBalls;\r\n          \r\n          if (removedBalls.length > 0) {\r\n            const { points, cryptoCollected, usdtFundCollected } = calculatePoints(removedBalls, 0);\r\n            \r\n            hapticFeedback('heavy');\r\n            playComboSound(2);\r\n            \r\n            const hasCrypto = removedBalls.some(b => b.crypto || b.isUsdtFund);\r\n            if (hasCrypto) {\r\n              playCryptoMatchSound();\r\n            } else {\r\n              playMatchSound();\r\n            }\r\n            \r\n            gapContextRef.current = null;\r\n            setProjectile(null);\r\n            \r\n            return {\r\n              ...prev,\r\n              balls: newBalls,\r\n              score: prev.score + points,\r\n              combo: 2,\r\n              maxCombo: Math.max(prev.maxCombo, 2),\r\n              cryptoCollected: {\r\n                btc: prev.cryptoCollected.btc + cryptoCollected.btc,\r\n                eth: prev.cryptoCollected.eth + cryptoCollected.eth,\r\n                usdt: prev.cryptoCollected.usdt + cryptoCollected.usdt,\r\n              },\r\n              usdtFundCollected: prev.usdtFundCollected + usdtFundCollected,\r\n              shooterBall: prev.nextBall,\r\n              nextBall: createRandomBall('next-' + Date.now(), 0, newBalls, true),\r\n            };\r\n          }\r\n        }\r\n        \r\n        const matches = findMatchingBalls(newBalls, insertIndex, projectile.ball);\r\n        \r\n        if (matches.length >= 3) {\r\n          const matchedBalls = matches.map(i => newBalls[i]);\r\n          const { points, cryptoCollected, usdtFundCollected } = calculatePoints(matchedBalls, 0);\r\n          \r\n          const minIdx = matches[0];\r\n          const maxIdx = matches[matches.length - 1];\r\n          const leftBall = minIdx > 0 ? newBalls[minIdx - 1] : null;\r\n          const rightBall = maxIdx < newBalls.length - 1 ? newBalls[maxIdx + 1] : null;\r\n          \r\n          newBalls = removeBalls(newBalls, matches);\r\n          // Only arm portal retreat if very early in game (< 10 balls spawned)\r\n          const isEarlyGame = totalSpawnedRef.current < 10;\r\n          activateRollback(isEarlyGame);\r\n          \r\n          let totalPoints = points;\r\n          let totalCryptoCollected = { ...cryptoCollected };\r\n          let totalUsdtFundCollected = usdtFundCollected;\r\n          let currentCombo = 1;\r\n          let currentLeftBall = leftBall;\r\n          let currentRightBall = rightBall;\r\n          \r\n          // Check for immediate chain reaction (balls are already adjacent after removal)\r\n          while (currentLeftBall && currentRightBall && newBalls.length >= 3) {\r\n            const leftIdx = newBalls.findIndex(b => b.id === currentLeftBall!.id);\r\n            const rightIdx = newBalls.findIndex(b => b.id === currentRightBall!.id);\r\n            \r\n            if (leftIdx < 0 || rightIdx < 0 || rightIdx !== leftIdx + 1) {\r\n              sendDebugLog(`[CHAIN-BREAK] L:${leftIdx} R:${rightIdx} adj:${rightIdx === leftIdx + 1}`);\r\n              break;\r\n            }\r\n            \r\n            // Check if boundary balls match\r\n            const leftB = newBalls[leftIdx];\r\n            const rightB = newBalls[rightIdx];\r\n            const ballsDoMatch = (leftB.crypto && rightB.crypto) \r\n              ? leftB.crypto === rightB.crypto \r\n              : (!leftB.crypto && !rightB.crypto && leftB.color === rightB.color);\r\n            \r\n            if (!ballsDoMatch) {\r\n              sendDebugLog(`[CHAIN-NOMATCH] L:${leftB.color}/${leftB.crypto || 'reg'} R:${rightB.color}/${rightB.crypto || 'reg'}`);\r\n              break;\r\n            }\r\n            \r\n            // Find matching balls starting from left\r\n            const chainMatches = findMatchingBalls(newBalls, leftIdx, leftB);\r\n            \r\n            if (chainMatches.length < 3 || !chainMatches.includes(leftIdx) || !chainMatches.includes(rightIdx)) {\r\n              sendDebugLog(`[CHAIN-SHORT] found:${chainMatches.length} hasLeft:${chainMatches.includes(leftIdx)} hasRight:${chainMatches.includes(rightIdx)}`);\r\n              break;\r\n            }\r\n            \r\n            // Chain reaction found!\r\n            currentCombo++;\r\n            sendDebugLog(`[CHAIN-REACT] combo:${currentCombo} removing:${chainMatches.length} balls`);\r\n            \r\n            const chainMatchedBalls = chainMatches.map(i => newBalls[i]);\r\n            const chainResult = calculatePoints(chainMatchedBalls, currentCombo - 1);\r\n            totalPoints += chainResult.points;\r\n            totalCryptoCollected.btc += chainResult.cryptoCollected.btc;\r\n            totalCryptoCollected.eth += chainResult.cryptoCollected.eth;\r\n            totalCryptoCollected.usdt += chainResult.cryptoCollected.usdt;\r\n            totalUsdtFundCollected += chainResult.usdtFundCollected;\r\n            \r\n            // Get new boundary balls before removal\r\n            const newMinIdx = chainMatches[0];\r\n            const newMaxIdx = chainMatches[chainMatches.length - 1];\r\n            currentLeftBall = newMinIdx > 0 ? newBalls[newMinIdx - 1] : null;\r\n            currentRightBall = newMaxIdx < newBalls.length - 1 ? newBalls[newMaxIdx + 1] : null;\r\n            \r\n            newBalls = removeBalls(newBalls, chainMatches);\r\n            // Keep same early game state for chain reactions\r\n            activateRollback(isEarlyGame);\r\n            \r\n            // Play combo sound\r\n            const hasChainCrypto = chainMatchedBalls.some(b => b.crypto || b.isUsdtFund);\r\n            if (hasChainCrypto) {\r\n              playCryptoMatchSound();\r\n            }\r\n            playComboSound(currentCombo);\r\n            hapticFeedback('heavy');\r\n          }\r\n          \r\n          // Clear gap context since we processed chain reactions synchronously\r\n          gapContextRef.current = null;\r\n          sendDebugLog(`[CHAIN-END] combo:${currentCombo} points:${totalPoints}`);\r\n          \r\n          hapticFeedback('medium');\r\n          \r\n          const hasCrypto = matchedBalls.some(b => b.crypto || b.isUsdtFund);\r\n          if (hasCrypto) {\r\n            playCryptoMatchSound();\r\n          } else {\r\n            playMatchSound(currentCombo);\r\n          }\r\n          const newScore = prev.score + totalPoints;\r\n          \r\n          setProjectile(null);\r\n          \r\n          // Победа: все шары уничтожены И спавн завершён\r\n          if (checkWin(newBalls) && spawnFinishedRef.current) {\r\n            gameEndedRef.current = true;\r\n            stopAllTimers();\r\n            const duration = Math.floor((Date.now() - gameStartTimeRef.current) / 1000);\r\n            const finalState = {\r\n              ...prev,\r\n              balls: newBalls,\r\n              score: newScore,\r\n              combo: currentCombo,\r\n              maxCombo: Math.max(prev.maxCombo, currentCombo),\r\n              cryptoCollected: {\r\n                btc: prev.cryptoCollected.btc + totalCryptoCollected.btc,\r\n                eth: prev.cryptoCollected.eth + totalCryptoCollected.eth,\r\n                usdt: prev.cryptoCollected.usdt + totalCryptoCollected.usdt,\r\n              },\r\n              usdtFundCollected: prev.usdtFundCollected + totalUsdtFundCollected,\r\n              shotsHit: prev.shotsHit + 1,\r\n              isPlaying: false,\r\n              isGameOver: true,\r\n              won: true,\r\n              timeLeft: duration,\r\n            };\r\n            setTimeout(() => {\r\n              onGameEndRef.current?.(finalState);\r\n              hapticFeedback('success');\r\n            }, 100);\r\n            return finalState;\r\n          }\r\n          \r\n          return {\r\n            ...prev,\r\n            balls: newBalls,\r\n            score: newScore,\r\n            combo: currentCombo,\r\n            maxCombo: Math.max(prev.maxCombo, currentCombo),\r\n            cryptoCollected: {\r\n              btc: prev.cryptoCollected.btc + totalCryptoCollected.btc,\r\n              eth: prev.cryptoCollected.eth + totalCryptoCollected.eth,\r\n              usdt: prev.cryptoCollected.usdt + totalCryptoCollected.usdt,\r\n            },\r\n            usdtFundCollected: prev.usdtFundCollected + totalUsdtFundCollected,\r\n            shotsHit: prev.shotsHit + 1,\r\n          };\r\n        } else {\r\n          setProjectile(null);\r\n          if (gapContextRef.current) {\r\n            sendDebugLog(`[RESET] Gap context cleared by non-matching shot!`);\r\n          }\r\n          gapContextRef.current = null;\r\n          \r\n          return {\r\n            ...prev,\r\n            balls: newBalls,\r\n            combo: 0,\r\n            shotsHit: prev.shotsHit + 1,\r\n          };\r\n        }\r\n      }\r\n      \r\n      return prev;\r\n    });\r\n  }, [projectile, stopAllTimers]);\r\n\r\n  const shoot = useCallback((targetX: number, targetY: number) => {\r\n    // Use ref to get current shooterBall to avoid stale closure issues\r\n    const currentShooterBall = shooterBallRef.current;\r\n    if (!gameState.isPlaying || projectile || !currentShooterBall) return;\r\n    \r\n    const dx = targetX - shooterPosition.x;\r\n    const dy = targetY - shooterPosition.y;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    \r\n    if (distance === 0) return;\r\n    \r\n    const vx = (dx / distance) * SHOOTER_BALL_SPEED;\r\n    const vy = (dy / distance) * SHOOTER_BALL_SPEED;\r\n    \r\n    // Apply rainbow boost to the shooting ball if active\r\n    let ballToShoot = currentShooterBall;\r\n    if (consumeRainbow()) {\r\n      ballToShoot = { ...ballToShoot, isRainbow: true };\r\n    }\r\n    \r\n    setProjectile({\r\n      x: shooterPosition.x,\r\n      y: shooterPosition.y,\r\n      prevX: shooterPosition.x,\r\n      prevY: shooterPosition.y,\r\n      vx,\r\n      vy,\r\n      ball: ballToShoot,\r\n    });\r\n    \r\n    setGameState(prev => ({\r\n      ...prev,\r\n      shooterBall: prev.nextBall,\r\n      nextBall: createRandomBall('next-' + Date.now(), 0, prev.balls, true),\r\n      shotsTotal: prev.shotsTotal + 1,\r\n    }));\r\n    \r\n    hapticFeedback('light');\r\n    playShootSound();\r\n  }, [gameState.isPlaying, projectile, shooterPosition]);\r\n\r\n  const updateAim = useCallback((targetX: number, targetY: number) => {\r\n    if (!gameState.isPlaying) return;\r\n    \r\n    const dx = targetX - shooterPosition.x;\r\n    const dy = targetY - shooterPosition.y;\r\n    const angle = Math.atan2(dy, dx);\r\n    \r\n    setShooterAngle(angle);\r\n  }, [gameState.isPlaying, shooterPosition]);\r\n\r\n  // resumeGame принимает опцию incrementLives для addExtraLife\r\n  const resumeGame = useCallback((options?: { incrementLives?: boolean }) => {\r\n    const shouldIncrementLives = options?.incrementLives ?? false;\r\n    stopAllTimers();\r\n    gameEndedRef.current = false;\r\n    lastTimeRef.current = 0;\r\n    spawnAccumRef.current = 0;\r\n    \r\n    setGameState(prev => {\r\n      let currentPath = pathRef.current;\r\n      if (currentPath.length === 0) {\r\n        console.warn(\"Path not initialized in resumeGame, regenerating...\");\r\n        currentPath = generatePathForLevel(dimensionsRef.current.width, dimensionsRef.current.height, level);\r\n        pathRef.current = currentPath;\r\n        setPath(currentPath);\r\n      }\r\n      \r\n      const beforeCount = prev.balls.length;\r\n      \r\n      if (prev.balls.length === 0) {\r\n        spawnFinishedRef.current = true;\r\n        totalSpawnedRef.current = 0;\r\n        currentLifeMaxRef.current = 0;\r\n        const logType = shouldIncrementLives ? 'ПОКУПКА ЖИЗНИ' : 'ПРОДОЛЖИТЬ ИГРУ';\r\n        sendDebugLog(`[${logType}] Цепочка: 0 → 0 шаров, спавн завершён.`);\r\n        return {\r\n          ...prev,\r\n          lives: shouldIncrementLives ? prev.lives + 1 : 1,\r\n          isPlaying: true,\r\n          isGameOver: false,\r\n          won: false,\r\n          extraLivesBought: prev.extraLivesBought + 1,\r\n        };\r\n      }\r\n      \r\n      // FIX: Логика, аналогичная потере жизни\r\n      const spacing = GAME_CONFIG.balls.spacing;\r\n      let respawnedBalls = [...prev.balls].sort((a, b) => b.pathProgress - a.pathProgress);\r\n\r\n      currentLifeMaxRef.current = beforeCount; // Лимит = сколько было\r\n\r\n      let keepCount = Math.ceil(beforeCount / 2);\r\n      keepCount = Math.min(keepCount, beforeCount);\r\n      respawnedBalls = respawnedBalls.slice(0, keepCount);\r\n      \r\n      const n = respawnedBalls.length;\r\n      if (n > 0) {\r\n        const headPos = 0.5; // Голова на 50%\r\n        for (let i = 0; i < n; i++) {\r\n          const newProgress = Math.max(0, headPos - i * spacing);\r\n          respawnedBalls[i] = { \r\n            ...respawnedBalls[i], \r\n            pathProgress: newProgress,\r\n            spawnAnimStart: undefined\r\n          };\r\n        }\r\n      }\r\n      \r\n      respawnedBalls.sort((a, b) => a.pathProgress - b.pathProgress);\r\n      respawnedBalls = updateBallPositions(respawnedBalls, currentPath);\r\n      \r\n      gapContextRef.current = null;\r\n      spawnFinishedRef.current = false;\r\n      totalSpawnedRef.current = respawnedBalls.length;\r\n      \r\n      const logType = shouldIncrementLives ? 'ПОКУПКА ЖИЗНИ' : 'ПРОДОЛЖИТЬ ИГРУ';\r\n      sendDebugLog(`[${logType}] Было ${beforeCount}, осталось ${respawnedBalls.length}, ещё выедут ${currentLifeMaxRef.current - respawnedBalls.length}`);\r\n      \r\n      return {\r\n        ...prev,\r\n        balls: respawnedBalls,\r\n        lives: shouldIncrementLives ? prev.lives + 1 : 1,\r\n        isPlaying: true,\r\n        isGameOver: false,\r\n        won: false,\r\n        extraLivesBought: prev.extraLivesBought + 1,\r\n      };\r\n    });\r\n    \r\n    const currentPath = pathRef.current;\r\n    \r\n    const runLoop = (timestamp: number) => {\r\n      if (gameEndedRef.current) return;\r\n      \r\n      const deltaTime = lastTimeRef.current ? timestamp - lastTimeRef.current : 16;\r\n      lastTimeRef.current = timestamp;\r\n      \r\n      updateBoostTimers();\r\n      \r\n      setGameState(prev => {\r\n        if (!prev.isPlaying || gameEndedRef.current) return prev;\r\n        \r\n        let newBalls = isRollbackActive() \r\n          ? prev.balls \r\n          : moveBallsForward(prev.balls, deltaTime);\r\n        newBalls = processRollback(newBalls, deltaTime, spawnFinishedRef.current);\r\n        \r\n        const gameplayConfig = getGameplayConfig();\r\n        const { period } = gameplayConfig.spawn;\r\n        const { targetCount } = gameplayConfig.balls;\r\n        \r\n        spawnAccumRef.current += deltaTime;\r\n        \r\n        const canSpawn = !spawnFinishedRef.current && \r\n                         newBalls.length < targetCount && \r\n                         totalSpawnedRef.current < currentLifeMaxRef.current;\r\n        \r\n        if (spawnAccumRef.current >= period && canSpawn) {\r\n          const spacing = getBallSpacing();\r\n          \r\n          const tailBall = newBalls.length > 0 \r\n            ? newBalls.reduce((min, b) => b.pathProgress < min.pathProgress ? b : min, newBalls[0])\r\n            : null;\r\n          const tailProgress = tailBall?.pathProgress ?? spacing;\r\n          const spawnPosition = Math.max(0, tailProgress - spacing);\r\n          \r\n          spawnAccumRef.current = 0;\r\n          \r\n          const rawBall = createRandomBall(`spawn-${Date.now()}-${Math.random().toString(36).slice(2)}`, spawnPosition, newBalls);\r\n          const newBall = { ...rawBall, spawnAnimStart: Date.now() };\r\n          \r\n          newBalls = [newBall, ...newBalls];\r\n          totalSpawnedRef.current++;\r\n          \r\n          if (totalSpawnedRef.current >= currentLifeMaxRef.current) {\r\n            spawnFinishedRef.current = true;\r\n          }\r\n        }\r\n        \r\n        newBalls = updateBallPositions(newBalls, currentPath);\r\n        \r\n        if (checkWin(newBalls) && spawnFinishedRef.current) {\r\n          gameEndedRef.current = true;\r\n          stopAllTimers();\r\n          const duration = Math.floor((Date.now() - gameStartTimeRef.current) / 1000);\r\n          const finalState = { ...prev, balls: newBalls, isPlaying: false, isGameOver: true, won: true, timeLeft: duration };\r\n          setTimeout(() => {\r\n            onGameEndRef.current?.(finalState);\r\n            hapticFeedback('success');\r\n            playWinSound();\r\n          }, 0);\r\n          return finalState;\r\n        }\r\n        \r\n        if (checkGameOver(newBalls)) {\r\n          if (consumeShield()) {\r\n            const spacing = GAME_CONFIG.balls.spacing;\r\n            const beforeCount = newBalls.length;\r\n            \r\n            let respawnedBalls = [...newBalls];\r\n            respawnedBalls.sort((a, b) => b.pathProgress - a.pathProgress);\r\n            \r\n            let keepCount = Math.ceil(maxTotalBallsRef.current / 2);\r\n            keepCount = Math.min(keepCount, beforeCount);\r\n            respawnedBalls = respawnedBalls.slice(0, keepCount);\r\n            \r\n            const n = respawnedBalls.length;\r\n            if (n > 0) {\r\n              const headPos = 0.5;\r\n              \r\n              for (let i = 0; i < n; i++) {\r\n                const newProgress = Math.max(0, headPos - i * spacing);\r\n                respawnedBalls[i] = { \r\n                  ...respawnedBalls[i], \r\n                  pathProgress: newProgress,\r\n                  spawnAnimStart: undefined\r\n                };\r\n              }\r\n            }\r\n            \r\n            respawnedBalls.sort((a, b) => a.pathProgress - b.pathProgress);\r\n            respawnedBalls = updateBallPositions(respawnedBalls, currentPath);\r\n            \r\n            gapContextRef.current = null;\r\n            spawnFinishedRef.current = false;\r\n            currentLifeMaxRef.current = maxTotalBallsRef.current;\r\n            totalSpawnedRef.current = respawnedBalls.length;\r\n            hapticFeedback('medium');\r\n            return { ...prev, balls: respawnedBalls, combo: 0 };\r\n          }\r\n          \r\n          const beforeLossCount2 = newBalls.length;\r\n          const maxProgressBefore2 = newBalls.length > 0 ? Math.max(...newBalls.map(b => b.pathProgress)) : 0;\r\n\r\n          const newLives = prev.lives - 1;\r\n          sendDebugLog(`[ПОТЕРЯ ЖИЗНИ] До: ${beforeLossCount2} шаров, голова на ${(maxProgressBefore2 * 100).toFixed(0)}%, осталось жизней: ${newLives}.`);\r\n          \r\n          if (newLives <= 0) {\r\n            const availableBonusLives = bonusLivesRef.current - usedBonusLivesRef.current;\r\n            \r\n            if (availableBonusLives > 0) {\r\n              usedBonusLivesRef.current += 1;\r\n              setUsedBonusLives(prev => prev + 1);\r\n              \r\n              setTimeout(() => {\r\n                onUseBonusLifeRef.current?.();\r\n              }, 0);\r\n              \r\n              const spacing = GAME_CONFIG.balls.spacing;\r\n              \r\n              let respawnedBalls = [...newBalls];\r\n              respawnedBalls.sort((a, b) => b.pathProgress - a.pathProgress);\r\n              \r\n              let keepCount = Math.ceil(beforeLossCount2 / 2);\r\n              keepCount = Math.min(keepCount, beforeLossCount2);\r\n              respawnedBalls = respawnedBalls.slice(0, keepCount);\r\n              \r\n              const n = respawnedBalls.length;\r\n              if (n > 0) {\r\n                const headPos = 0.5;\r\n                \r\n                for (let i = 0; i < n; i++) {\r\n                  const newProgress = Math.max(0, headPos - i * spacing);\r\n                  respawnedBalls[i] = { \r\n                    ...respawnedBalls[i], \r\n                    pathProgress: newProgress,\r\n                    spawnAnimStart: undefined\r\n                  };\r\n                }\r\n              }\r\n              \r\n              respawnedBalls.sort((a, b) => a.pathProgress - b.pathProgress);\r\n              respawnedBalls = updateBallPositions(respawnedBalls, currentPath);\r\n              \r\n              gapContextRef.current = null;\r\n              spawnFinishedRef.current = false;\r\n              currentLifeMaxRef.current = maxTotalBallsRef.current; // FIX: Лимит всегда сбрасывается на максимум\r\n              totalSpawnedRef.current = respawnedBalls.length;\r\n              \r\n              sendDebugLog(`[ПОТЕРЯ ЖИЗНИ] После (бонус): было ${beforeLossCount2}, осталось ${respawnedBalls.length}, ещё выедут ${currentLifeMaxRef.current - respawnedBalls.length}`);\r\n              hapticFeedback('warning');\r\n              playLifeLostSound();\r\n              return { ...prev, balls: respawnedBalls, lives: 1, combo: 0 };\r\n            }\r\n            \r\n            gameEndedRef.current = true;\r\n            stopAllTimers();\r\n            const duration = Math.floor((Date.now() - gameStartTimeRef.current) / 1000);\r\n            const finalState = { ...prev, balls: newBalls, lives: 0, isPlaying: false, isGameOver: true, won: false, timeLeft: duration };\r\n            setTimeout(() => {\r\n              onGameEndRef.current?.(finalState);\r\n              hapticFeedback('error');\r\n              playGameOverSound();\r\n            }, 0);\r\n            return finalState;\r\n          }\r\n          \r\n          const spacing = GAME_CONFIG.balls.spacing;\r\n          \r\n          let respawnedBalls = [...newBalls];\r\n          respawnedBalls.sort((a, b) => b.pathProgress - a.pathProgress);\r\n          \r\n          let keepCount = Math.ceil(beforeLossCount2 / 2);\r\n          keepCount = Math.min(keepCount, beforeLossCount2);\r\n          respawnedBalls = respawnedBalls.slice(0, keepCount);\r\n          \r\n          const n = respawnedBalls.length;\r\n          if (n > 0) {\r\n            const headPos = 0.5;\r\n            \r\n            for (let i = 0; i < n; i++) {\r\n              const newProgress = Math.max(0, headPos - i * spacing);\r\n              respawnedBalls[i] = { \r\n                ...respawnedBalls[i], \r\n                pathProgress: newProgress,\r\n                spawnAnimStart: undefined\r\n              };\r\n            }\r\n          }\r\n          \r\n          respawnedBalls.sort((a, b) => a.pathProgress - b.pathProgress);\r\n          respawnedBalls = updateBallPositions(respawnedBalls, currentPath);\r\n          \r\n          gapContextRef.current = null;\r\n          spawnFinishedRef.current = false;\r\n          currentLifeMaxRef.current = maxTotalBallsRef.current; // FIX: Лимит всегда сбрасывается на максимум\r\n          totalSpawnedRef.current = respawnedBalls.length;\r\n          \r\n          sendDebugLog(`[ПОТЕРЯ ЖИЗНИ] Было ${beforeLossCount2} шаров, осталось ${respawnedBalls.length}, ещё выедут ${currentLifeMaxRef.current - respawnedBalls.length}`);\r\n          hapticFeedback('warning');\r\n          playLifeLostSound();\r\n          return { ...prev, balls: respawnedBalls, lives: newLives, combo: 0 };\r\n        }\r\n        \r\n        return { ...prev, balls: newBalls };\r\n      });\r\n      \r\n      setProjectile(prev => {\r\n        if (!prev || gameEndedRef.current) return prev;\r\n        \r\n        const dims = dimensionsRef.current;\r\n        const newX = prev.x + prev.vx;\r\n        const newY = prev.y + prev.vy;\r\n        \r\n        if (newX < 0 || newX > dims.width || newY < 0 || newY > dims.height) {\r\n          return null;\r\n        }\r\n        \r\n        return { ...prev, prevX: prev.x, prevY: prev.y, x: newX, y: newY };\r\n      });\r\n      \r\n      gameLoopRef.current = requestAnimationFrame(runLoop);\r\n    };\r\n    \r\n    gameLoopRef.current = requestAnimationFrame(runLoop);\r\n    \r\n    timeTrackerRef.current = setInterval(() => {\r\n      if (gameEndedRef.current) return;\r\n      setElapsedTime(Math.floor((Date.now() - gameStartTimeRef.current) / 1000));\r\n    }, 1000);\r\n    \r\n    hapticFeedback('success');\r\n  }, [stopAllTimers, level]);\r\n\r\n  const ballsOnScreen = gameState.balls.length;\r\n  const totalBalls = maxTotalBallsRef.current;\r\n  const totalSpawned = totalSpawnedRef.current;\r\n  const ballsRemaining = totalBalls - totalSpawned + ballsOnScreen;\r\n  const currentLifeMax = currentLifeMaxRef.current;\r\n\r\n  const applyRewind = useCallback(() => {\r\n    setGameState(prev => {\r\n      const rewindedBalls = applyRewindEffect(prev.balls, 0.2);\r\n      const updatedBalls = updateBallPositions(rewindedBalls, pathRef.current);\r\n      return { ...prev, balls: updatedBalls };\r\n    });\r\n    hapticFeedback('medium');\r\n  }, []);\r\n\r\n  // addExtraLife вызывает resumeGame с флагом incrementLives\r\n  const addExtraLife = useCallback((extraSeconds: number) => {\r\n    resumeGame({ incrementLives: true });\r\n  }, [resumeGame]);\r\n\r\n  const togglePause = useCallback(() => {\r\n    isPausedRef.current = !isPausedRef.current;\r\n    setIsPaused(isPausedRef.current);\r\n    sendDebugLog(`[DEBUG] Game ${isPausedRef.current ? 'Paused' : 'Resumed'}`);\r\n  }, []);\r\n\r\n  const stepFrame = useCallback(() => {\r\n    if (isPausedRef.current) {\r\n      stepFrameRef.current = true;\r\n      sendDebugLog(`[DEBUG] Stepping one frame`);\r\n    }\r\n  }, []);\r\n\r\n  return {\r\n    gameState,\r\n    path,\r\n    projectile,\r\n    shooterAngle,\r\n    shooterPosition,\r\n    elapsedTime,\r\n    ballsOnScreen,\r\n    ballsRemaining,\r\n    totalBalls,\r\n    totalSpawned,\r\n    currentLifeMax,\r\n    isPaused,\r\n    startGame,\r\n    shoot,\r\n    updateAim,\r\n    addExtraLife,\r\n    resumeGame,\r\n    applyRewind,\r\n    togglePause,\r\n    stepFrame,\r\n  };\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AAEA;AA2CA;AACA;AACA;;;;;;AA2CA,MAAM,uBAAuB;AAE7B,gEAAgE;AAChE,MAAM,iBAA2B,EAAE;AACnC,IAAI,kBAAwD;AAE5D,SAAS,aAAa,OAAe;IACnC,MAAM,YAAY,IAAI,OAAO,WAAW,GAAG,KAAK,CAAC,IAAI;IACrD,eAAe,IAAI,CAAC,CAAC,CAAC,EAAE,UAAU,EAAE,EAAE,SAAS;IAE/C,oEAAoE;IACpE,IAAI,iBAAiB,aAAa;IAClC,kBAAkB,WAAW;QAC3B,IAAI,eAAe,MAAM,GAAG,GAAG;YAC7B,MAAM,aAAa;mBAAI;aAAe;YACtC,eAAe,MAAM,GAAG;YACxB,MAAM,mBAAmB;gBACvB,QAAQ;gBACR,SAAS;oBAAE,gBAAgB;gBAAmB;gBAC9C,MAAM,KAAK,SAAS,CAAC;oBAAE,MAAM;gBAAW;YAC1C,GAAG,KAAK,CAAC,KAAO,IAAI,gBAAgB;QACtC;IACF,GAAG;AACL;AAEO,SAAS,aAAa,EAAE,WAAW,EAAE,YAAY,EAAE,SAAS,EAAE,KAAK,EAAE,aAAa,CAAC,EAAE,cAAc,EAAqB;IAC7H,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,+GAAQ,EAAY,oIAAsB;IAC5E,MAAM,CAAC,MAAM,QAAQ,GAAG,IAAA,+GAAQ,EAAc,EAAE;IAChD,MAAM,CAAC,YAAY,cAAc,GAAG,IAAA,+GAAQ,EAAoB;IAChE,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,+GAAQ,EAAC,CAAC,KAAK,EAAE,GAAG;IAC5D,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,+GAAQ,EAAC;IAC/C,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,+GAAQ,EAAC;IACrD,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,+GAAQ,EAAC;IAEzC,MAAM,cAAc,IAAA,6GAAM,EAAC;IAC3B,MAAM,eAAe,IAAA,6GAAM,EAAC;IAC5B,MAAM,cAAc,IAAA,6GAAM,EAAgB;IAC1C,MAAM,iBAAiB,IAAA,6GAAM,EAAwC;IACrE,MAAM,cAAc,IAAA,6GAAM,EAAS;IACnC,MAAM,UAAU,IAAA,6GAAM,EAAc,EAAE;IACtC,MAAM,eAAe,IAAA,6GAAM,EAAC;IAC5B,MAAM,eAAe,IAAA,6GAAM,EAAC;IAC5B,MAAM,gBAAgB,IAAA,6GAAM,EAAC;QAAE,OAAO;QAAa,QAAQ;IAAa;IACxE,MAAM,mBAAmB,IAAA,6GAAM,EAAS;IACxC,MAAM,gBAAgB,IAAA,6GAAM,EAAS;IACrC,MAAM,kBAAkB,IAAA,6GAAM,EAAS;IACvC,MAAM,mBAAmB,IAAA,6GAAM,EAAU;IACzC,MAAM,gBAAgB,IAAA,6GAAM,EAAoB;IAChD,MAAM,mBAAmB,IAAA,6GAAM,EAAS;IACxC,MAAM,oBAAoB,IAAA,6GAAM,EAAS,MAAM,+BAA+B;IAC9E,MAAM,0BAA0B,IAAA,6GAAM,EAA8B;IACpE,MAAM,gBAAgB,IAAA,6GAAM,EAAC;IAC7B,MAAM,oBAAoB,IAAA,6GAAM,EAAC;IACjC,MAAM,oBAAoB,IAAA,6GAAM,EAAC;IACjC,MAAM,iBAAiB,IAAA,6GAAM,EAAC,UAAU,WAAW;IAEnD,IAAA,gHAAS,EAAC;QACR,eAAe,OAAO,GAAG,UAAU,WAAW;IAChD,GAAG;QAAC,UAAU,WAAW;KAAC;IAE1B,IAAA,gHAAS,EAAC;QACR,cAAc,OAAO,GAAG;IAC1B,GAAG;QAAC;KAAW;IAEf,IAAA,gHAAS,EAAC;QACR,kBAAkB,OAAO,GAAG;IAC9B,GAAG;QAAC;KAAe;IACnB,MAAM,0BAA0B,IAAA,6GAAM,EAAuC;IAE7E,aAAa,OAAO,GAAG;IACvB,QAAQ,OAAO,GAAG;IAClB,cAAc,OAAO,GAAG;QAAE,OAAO;QAAa,QAAQ;IAAa;IAEnE,MAAM,kBAAkB,IAAA,gIAAkB,EAAC,aAAa;IAExD,IAAA,gHAAS,EAAC;QACR,IAAI,cAAc,KAAK,eAAe,GAAG;YACvC,IAAA,6HAAe,EAAC;YAChB,MAAM,UAAU,IAAA,kIAAoB,EAAC,aAAa,cAAc;YAChE,QAAQ;YACR,QAAQ,OAAO,GAAG;QACpB;IACF,GAAG;QAAC;QAAa;QAAc;KAAM;IAErC,MAAM,gBAAgB,IAAA,kHAAW,EAAC;QAChC,IAAI,YAAY,OAAO,KAAK,MAAM;YAChC,qBAAqB,YAAY,OAAO;YACxC,YAAY,OAAO,GAAG;QACxB;QACA,IAAI,eAAe,OAAO,KAAK,MAAM;YACnC,cAAc,eAAe,OAAO;YACpC,eAAe,OAAO,GAAG;QAC3B;QACA,IAAI,wBAAwB,OAAO,KAAK,MAAM;YAC5C,aAAa,wBAAwB,OAAO;YAC5C,wBAAwB,OAAO,GAAG;QACpC;QACA,wBAAwB,OAAO,GAAG;IACpC,GAAG,EAAE;IAEL,MAAM,YAAY,IAAA,kHAAW,EAAC;QAC5B,IAAI,eAAe,OAAO,KAAK,MAAM;YACnC,QAAQ,IAAI,CAAC;YACb;QACF;QAEA,IAAI;YACF,MAAM,CAAC,YAAY,aAAa,eAAe,GAAG,MAAM,QAAQ,GAAG,CAAC;gBAClE,MAAM;gBACN,MAAM;gBACN,MAAM,4BAA4B;oBAAE,aAAa;gBAAU;aAC5D;YAED,wCAAwC;YACxC,IAAI,kBAAkB;gBAAE,KAAK;gBAAO,KAAK;gBAAO,MAAM;YAAM;YAE5D,IAAI,WAAW,EAAE,EAAE;gBACjB,MAAM,cAAc,MAAM,WAAW,IAAI;gBACzC,IAAA,8HAAgB,EAAC;gBACjB,kFAAkF;gBAClF,kBAAkB,YAAY,eAAe,IAAI;oBAAE,KAAK;oBAAO,KAAK;oBAAO,MAAM;gBAAM;gBACvF,IAAA,gIAAkB,EAAC,YAAY,eAAe,KAAK;YACrD;YAEA,IAAI,eAAe,EAAE,EAAE;gBACrB,MAAM,cAAc,MAAM,eAAe,IAAI;gBAC7C,+DAA+D;gBAC/D,kEAAkE;gBAClE,kBAAkB;oBAChB,KAAK,gBAAgB,GAAG,IAAK,YAAY,UAAU,KAAK;oBACxD,KAAK,gBAAgB,GAAG,IAAK,YAAY,UAAU,KAAK;oBACxD,MAAM,gBAAgB,IAAI,IAAK,YAAY,WAAW,KAAK;gBAC7D;YACF;YAEA,IAAA,gIAAkB,EAAC;YAEnB,IAAI,YAAY,EAAE,EAAE;gBAClB,MAAM,eAAe,MAAM,YAAY,IAAI;gBAC3C,yDAAyD;gBACzD,IAAI,OAAO,aAAa;oBACtB,aAAa,KAAK,GAAG;wBAAE,GAAG,aAAa,KAAK;wBAAE,QAAQ,MAAM,WAAW;oBAAC;gBAC1E;gBACA,IAAA,+HAAiB,EAAC;gBAClB,iBAAiB,OAAO,GAAG,aAAa,KAAK,EAAE,iBAAiB;gBAChE,kBAAkB,OAAO,GAAG,iBAAiB,OAAO,EAAE,wBAAwB;YAChF;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,gCAAgC;YAC9C,uDAAuD;YACvD,IAAA,gIAAkB,EAAC;gBAAE,KAAK;gBAAO,KAAK;gBAAO,MAAM;YAAM;YACzD,IAAA,gIAAkB,EAAC;QACrB;QAEA;QACA,aAAa,OAAO,GAAG;QACvB,iBAAiB,OAAO,GAAG,KAAK,GAAG;QACnC,eAAe;QAEf,IAAA,qIAAuB;QAEvB,MAAM,OAAO,cAAc,OAAO;QAClC,IAAA,6HAAe,EAAC;QAChB,MAAM,UAAU,IAAA,kIAAoB,EAAC,KAAK,KAAK,EAAE,KAAK,MAAM,EAAE;QAC9D,QAAQ;QACR,QAAQ,OAAO,GAAG;QAElB,MAAM,eAAe,IAAA,oIAAsB;QAC3C,MAAM,qBAAqB,IAAA,iIAAmB,EAAC,aAAa,KAAK,EAAE;QAEnE,aAAa;YACX,GAAG,YAAY;YACf,OAAO;YACP,WAAW;YACX,UAAU;QACZ;QACA,cAAc;QACd,gBAAgB,CAAC,KAAK,EAAE,GAAG;QAC3B,YAAY,OAAO,GAAG;QACtB,cAAc,OAAO,GAAG;QACxB,gBAAgB,OAAO,GAAG,IAAA,+HAAiB,IAAG,KAAK,CAAC,YAAY;QAChE,iBAAiB,OAAO,GAAG;QAC3B,cAAc,OAAO,GAAG;QAExB,sCAAsC;QACtC,IAAI,aAAa;QAEjB,MAAM,UAAU,CAAC;YACf,IAAI,aAAa,OAAO,EAAE;YAE1B,IAAI,YAAY,OAAO,IAAI,CAAC,aAAa,OAAO,EAAE;gBAChD,YAAY,OAAO,GAAG,WAAW,qCAAqC;gBACtE,YAAY,OAAO,GAAG,sBAAsB;gBAC5C;YACF;YACA,IAAI,aAAa,OAAO,EAAE;gBACxB,aAAa,OAAO,GAAG,OAAO,sBAAsB;YACtD;YAEA;YAEA,MAAM,YAAY,YAAY,OAAO,GAAG,YAAY,YAAY,OAAO,GAAG;YAC1E,YAAY,OAAO,GAAG;YACtB,MAAM,cAAc,QAAQ,OAAO;YAEnC,IAAA,+HAAiB;YAEjB,IAAI,wBAAwB,OAAO,EAAE;gBACnC,YAAY,OAAO,GAAG,sBAAsB;gBAC5C;YACF;YAEA,kEAAkE;YAClE,IAAI,cAAc,OAAO,IAAI,KAAK,MAAM,KAAK,MAAM;gBACjD,aAAa,CAAC,qBAAqB,EAAE,cAAc,OAAO,CAAC,UAAU,EAAE,MAAM,CAAC,GAAG,GAAG,EAAE,cAAc,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC,IAAI;YACtI;YAEA,aAAa,CAAA;gBACX,IAAI,CAAC,KAAK,SAAS,IAAI,aAAa,OAAO,EAAE,OAAO;gBAEpD,2EAA2E;gBAC3E,IAAI,WAAW,IAAA,8HAAgB,MAC3B,KAAK,KAAK,GACV,IAAA,8HAAgB,EAAC,KAAK,KAAK,EAAE;gBAEjC,WAAW,IAAA,6HAAe,EAAC,UAAU,WAAW,iBAAiB,OAAO;gBAExE,IAAI,eAAe;gBAEnB,MAAM,MAAM,cAAc,OAAO;gBACjC,oCAAoC;gBACpC,IAAI,KAAK;oBACP,MAAM,UAAU,IAAI,UAAU,GAAG,SAAS,SAAS,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,IAAI,UAAU,IAAI,CAAC;oBACrF,MAAM,WAAW,IAAI,WAAW,GAAG,SAAS,SAAS,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,IAAI,WAAW,IAAI,CAAC;oBACxF,MAAM,QAAQ,aAAa,UAAU;oBACrC,uCAAuC;oBACvC,IAAI,OAAO;wBACT,aAAa,CAAC,cAAc,EAAE,QAAQ,GAAG,EAAE,SAAS,KAAK,EAAE,MAAM,KAAK,EAAE,SAAS,MAAM,EAAE;oBAC3F;gBACF;gBACA,IAAI,OAAO,SAAS,MAAM,IAAI,GAAG;oBAC/B,MAAM,UAAU,IAAI,UAAU,GAAG,SAAS,SAAS,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,IAAI,UAAU,IAAI,CAAC;oBACrF,MAAM,WAAW,IAAI,WAAW,GAAG,SAAS,SAAS,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,IAAI,WAAW,IAAI,CAAC;oBAExF,kFAAkF;oBAClF,IAAI,aAAa,UAAU,KAAK,UAAU,KAAK,WAAW,GAAG;wBAC3D,aAAa,CAAC,cAAc,EAAE,QAAQ,UAAU,EAAE,SAAS,KAAK,EAAE,aAAa,UAAU,EAAE,MAAM,EAAE,IAAI,UAAU,EAAE,MAAM,CAAC,GAAG,OAAO,EAAE,IAAI,WAAW,EAAE,MAAM,CAAC,IAAI;oBACpK;oBAEA,IAAI,aAAa;oBACjB,IAAI,mBAAoC;oBAExC,IAAI,WAAW,KAAK,YAAY,KAAK,aAAa,UAAU,GAAG;wBAC7D,MAAM,WAAW,QAAQ,CAAC,QAAQ;wBAClC,MAAM,YAAY,QAAQ,CAAC,SAAS;wBAEpC,kFAAkF;wBAClF,MAAM,eAAe,AAAC,SAAS,MAAM,IAAI,UAAU,MAAM,GACrD,SAAS,MAAM,KAAK,UAAU,MAAM,GACnC,CAAC,SAAS,MAAM,IAAI,CAAC,UAAU,MAAM,IAAI,SAAS,KAAK,KAAK,UAAU,KAAK;wBAEhF,aAAa,CAAC,UAAU,EAAE,SAAS,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE,SAAS,KAAK,CAAC,CAAC,EAAE,SAAS,MAAM,IAAI,MAAM,GAAG,EAAE,UAAU,EAAE,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,EAAE,UAAU,KAAK,CAAC,CAAC,EAAE,UAAU,MAAM,IAAI,MAAM,OAAO,EAAE,cAAc;wBAEjM,IAAI,cAAc;4BAChB,+DAA+D;4BAC/D,MAAM,UAAU,IAAA,+HAAiB,EAAC,UAAU,SAAS;4BACrD,aAAa,CAAC,cAAc,EAAE,QAAQ,MAAM,CAAC,MAAM,EAAE,QAAQ,QAAQ,CAAC,YAAY,QAAQ,QAAQ,CAAC,WAAW;4BAE9G,IAAI,QAAQ,MAAM,IAAI,KAAK,QAAQ,QAAQ,CAAC,YAAY,QAAQ,QAAQ,CAAC,WAAW;gCAClF,aAAa;gCACb,mBAAmB;4BACrB;wBACF,OAAO;4BACL,2EAA2E;4BAC3E,mDAAmD;4BACnD,MAAM,cAAc,IAAA,+HAAiB,EAAC,UAAU,SAAS;4BACzD,aAAa,CAAC,eAAe,EAAE,YAAY,MAAM,CAAC,SAAS,EAAE,YAAY,QAAQ,CAAC,UAAU;4BAC5F,IAAI,YAAY,MAAM,IAAI,KAAK,YAAY,QAAQ,CAAC,UAAU;gCAC5D,aAAa;gCACb,mBAAmB;4BACrB;4BAEA,kFAAkF;4BAClF,IAAI,CAAC,YAAY;gCACf,MAAM,eAAe,IAAA,+HAAiB,EAAC,UAAU,UAAU;gCAC3D,aAAa,CAAC,gBAAgB,EAAE,aAAa,MAAM,CAAC,UAAU,EAAE,aAAa,QAAQ,CAAC,WAAW;gCACjG,IAAI,aAAa,MAAM,IAAI,KAAK,aAAa,QAAQ,CAAC,WAAW;oCAC/D,aAAa;oCACb,mBAAmB;gCACrB;4BACF;wBACF;oBACF,OAAO,IAAI,WAAW,KAAK,WAAW,GAAG;wBACvC,aAAa,CAAC,iCAAiC,CAAC;wBAChD,MAAM,UAAU,IAAA,+HAAiB,EAAC,UAAU,SAAS,QAAQ,CAAC,QAAQ;wBACtE,IAAI,QAAQ,MAAM,IAAI,KAAK,QAAQ,QAAQ,CAAC,UAAU;4BACpD,aAAa;4BACb,mBAAmB;wBACrB;oBACF,OAAO,IAAI,YAAY,KAAK,UAAU,GAAG;wBACvC,aAAa,CAAC,kCAAkC,CAAC;wBACjD,MAAM,UAAU,IAAA,+HAAiB,EAAC,UAAU,UAAU,QAAQ,CAAC,SAAS;wBACxE,IAAI,QAAQ,MAAM,IAAI,KAAK,QAAQ,QAAQ,CAAC,WAAW;4BACrD,aAAa;4BACb,mBAAmB;wBACrB;oBACF,OAAO,IAAI,UAAU,KAAK,WAAW,GAAG;wBACtC,aAAa,CAAC,6BAA6B,EAAE,QAAQ,OAAO,EAAE,UAAU;wBACxE,cAAc,OAAO,GAAG;oBAC1B;oBAEA,IAAI,cAAc,kBAAkB;wBAClC,MAAM,eAAe,iBAAiB,GAAG,CAAC,CAAA,IAAK,QAAQ,CAAC,EAAE;wBAC1D,MAAM,iBAAiB,aAAa,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE;wBAEjD,aAAa,CAAC,4CAA4C,EAAE,iBAAiB,MAAM,CAAC,MAAM,CAAC;wBAE3F,MAAM,SAAS,gBAAgB,CAAC,EAAE;wBAClC,MAAM,SAAS,gBAAgB,CAAC,iBAAiB,MAAM,GAAG,EAAE;wBAC5D,MAAM,cAAc,SAAS,IAAI,QAAQ,CAAC,SAAS,EAAE,GAAG;wBACxD,MAAM,eAAe,SAAS,SAAS,MAAM,GAAG,IAAI,QAAQ,CAAC,SAAS,EAAE,GAAG;wBAE3E,wBAAwB,OAAO,GAAG;4BAChC;4BACA,eAAe,aAAa,MAAM;4BAClC,gBAAgB,cAAc,MAAM;4BACpC,OAAO,KAAK,KAAK;wBACnB;wBAEA,wBAAwB,OAAO,GAAG,WAAW;4BAC3C,aAAa,CAAA;gCACX,IAAI,CAAC,aAAa,SAAS,IAAI,aAAa,OAAO,EAAE;oCACnD,wBAAwB,OAAO,GAAG;oCAClC,OAAO;gCACT;gCAEA,MAAM,UAAU,wBAAwB,OAAO;gCAC/C,IAAI,CAAC,SAAS,OAAO;gCAErB,MAAM,sBAAsB,QAAQ,cAAc,CAC/C,GAAG,CAAC,CAAA,KAAM,aAAa,KAAK,CAAC,SAAS,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,KACrD,MAAM,CAAC,CAAA,MAAO,OAAO,GACrB,IAAI,CAAC,CAAC,GAAG,IAAM,IAAI;gCAEtB,wBAAwB,OAAO,GAAG;gCAElC,IAAI,oBAAoB,MAAM,GAAG,GAAG;oCAClC,cAAc,OAAO,GAAG;oCACxB,OAAO;gCACT;gCAEA,MAAM,eAAe,oBAAoB,GAAG,CAAC,CAAA,IAAK,aAAa,KAAK,CAAC,EAAE;gCACvE,MAAM,aAAa,QAAQ,KAAK;gCAChC,MAAM,WAAW,aAAa;gCAC9B,MAAM,EAAE,MAAM,EAAE,eAAe,EAAE,iBAAiB,EAAE,GAAG,IAAA,6HAAe,EAAC,cAAc;gCAErF,MAAM,iBAAiB,IAAA,yHAAW,EAAC,aAAa,KAAK,EAAE;gCACvD,qEAAqE;gCACrE,MAAM,cAAc,gBAAgB,OAAO,GAAG;gCAC9C,IAAA,8HAAgB,EAAC;gCAEjB,IAAI,QAAQ,aAAa,IAAI,QAAQ,cAAc,EAAE;oCACnD,cAAc,OAAO,GAAG;wCACtB,YAAY,QAAQ,aAAa;wCACjC,aAAa,QAAQ,cAAc;oCACrC;gCACF,OAAO;oCACL,cAAc,OAAO,GAAG;gCAC1B;gCAEA,IAAA,0HAAc,EAAC;gCAEf,MAAM,YAAY,aAAa,IAAI,CAAC,CAAA,IAAK,EAAE,MAAM,IAAI,EAAE,UAAU;gCACjE,IAAI,WAAW;oCACb,IAAA,8HAAoB;gCACtB,OAAO;oCACL,IAAA,wHAAc,EAAC;gCACjB;gCACA,IAAI,WAAW,GAAG;oCAChB,IAAA,wHAAc,EAAC;gCACjB;gCAEA,MAAM,qBAAqB,IAAA,iIAAmB,EAAC,gBAAgB,QAAQ,OAAO;gCAE9E,OAAO;oCACL,GAAG,YAAY;oCACf,OAAO;oCACP,OAAO,aAAa,KAAK,GAAG;oCAC5B,OAAO;oCACP,UAAU,KAAK,GAAG,CAAC,aAAa,QAAQ,EAAE;oCAC1C,iBAAiB;wCACf,KAAK,aAAa,eAAe,CAAC,GAAG,GAAG,gBAAgB,GAAG;wCAC3D,KAAK,aAAa,eAAe,CAAC,GAAG,GAAG,gBAAgB,GAAG;wCAC3D,MAAM,aAAa,eAAe,CAAC,IAAI,GAAG,gBAAgB,IAAI;oCAChE;oCACA,mBAAmB,aAAa,iBAAiB,GAAG;gCACtD;4BACF;wBACF,GAAG;wBAEH,WAAW,IAAA,iIAAmB,EAAC,UAAU;wBACzC,OAAO;4BAAE,GAAG,IAAI;4BAAE,OAAO;wBAAS;oBACpC;oBAEA,IAAI,CAAC,YAAY;wBACf,cAAc,OAAO,GAAG;oBAC1B;gBACF;gBAEA,MAAM,iBAAiB,IAAA,+HAAiB;gBACxC,MAAM,EAAE,MAAM,EAAE,GAAG,eAAe,KAAK;gBACvC,MAAM,SAAS,yHAAW,CAAC,KAAK,CAAC,MAAM;gBACvC,MAAM,EAAE,WAAW,EAAE,GAAG,eAAe,KAAK;gBAE5C,cAAc,OAAO,IAAI;gBAEzB,wDAAwD;gBACxD,MAAM,WAAW,CAAC,iBAAiB,OAAO,IACzB,SAAS,MAAM,GAAG,eAClB,gBAAgB,OAAO,GAAG,kBAAkB,OAAO;gBAEpE,IAAI,cAAc,OAAO,IAAI,UAAU,UAAU;oBAC/C,MAAM,UAAU,IAAA,4HAAc;oBAE9B,mCAAmC;oBACnC,MAAM,WAAW,SAAS,MAAM,GAAG,IAC/B,SAAS,MAAM,CAAC,CAAC,KAAK,IAAM,EAAE,YAAY,GAAG,IAAI,YAAY,GAAG,IAAI,KAAK,QAAQ,CAAC,EAAE,IACpF;oBACJ,MAAM,eAAe,UAAU,gBAAgB;oBAE/C,0EAA0E;oBAC1E,MAAM,gBAAgB,KAAK,GAAG,CAAC,GAAG,eAAe;oBAEjD,aAAa,CAAC,cAAc,EAAE,cAAc,OAAO,CAAC,OAAO,CAAC,GAAG,UAAU,EAAE,SAAS,MAAM,CAAC,WAAW,EAAE,aAAa,OAAO,CAAC,GAAG,WAAW,EAAE,cAAc,OAAO,CAAC,IAAI;oBAEvK,cAAc,OAAO,GAAG;oBAExB,mFAAmF;oBACnF,MAAM,UAAU,IAAA,8HAAgB,EAAC,CAAC,MAAM,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,KAAK,CAAC,IAAI,EAAE,eAAe;oBAC9G,MAAM,UAAU;wBAAE,GAAG,OAAO;wBAAE,gBAAgB,KAAK,GAAG;oBAAG;oBAEzD,aAAa,CAAC,4BAA4B,EAAE,cAAc,OAAO,CAAC,GAAG,sBAAsB,EAAE,QAAQ,EAAE,CAAC,KAAK,CAAC,GAAE,IAAI,QAAQ,EAAE,QAAQ,KAAK,EAAE;oBAE7I,WAAW;wBAAC;2BAAY;qBAAS;oBACjC,gBAAgB,OAAO;oBAEvB,IAAI,gBAAgB,OAAO,IAAI,kBAAkB,OAAO,EAAE;wBACxD,iBAAiB,OAAO,GAAG;oBAC7B;gBACF;gBAEA,WAAW,IAAA,iIAAmB,EAAC,UAAU;gBAEzC,+CAA+C;gBAC/C,IAAI,IAAA,sHAAQ,EAAC,aAAa,iBAAiB,OAAO,EAAE;oBAClD,aAAa,OAAO,GAAG;oBACvB;oBACA,MAAM,WAAW,KAAK,KAAK,CAAC,CAAC,KAAK,GAAG,KAAK,iBAAiB,OAAO,IAAI;oBACtE,MAAM,aAAa;wBAAE,GAAG,YAAY;wBAAE,OAAO;wBAAU,WAAW;wBAAO,YAAY;wBAAM,KAAK;wBAAM,UAAU;oBAAS;oBACzH,WAAW;wBACT,aAAa,OAAO,GAAG;wBACvB,IAAA,0HAAc,EAAC;wBACf,IAAA,sHAAY;oBACd,GAAG;oBACH,OAAO;gBACT;gBAEA,IAAI,IAAA,2HAAa,EAAC,WAAW;oBAC3B,IAAI,IAAA,2HAAa,KAAI;wBACnB,MAAM,UAAU,yHAAW,CAAC,KAAK,CAAC,OAAO;wBACzC,MAAM,cAAc,SAAS,MAAM;wBAEnC,+DAA+D;wBAC/D,kBAAkB,OAAO,GAAG;wBAC5B,aAAa,CAAC,qBAAqB,EAAE,YAAY,qBAAqB,EAAE,kBAAkB,OAAO,EAAE;wBAEnG,IAAI,iBAAiB;+BAAI;yBAAS;wBAClC,eAAe,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;wBAE7D,wDAAwD;wBACxD,IAAI,YAAY,KAAK,IAAI,CAAC,cAAc;wBACxC,YAAY,KAAK,GAAG,CAAC,WAAW;wBAChC,iBAAiB,eAAe,KAAK,CAAC,GAAG;wBAEzC,MAAM,IAAI,eAAe,MAAM;wBAC/B,IAAI,IAAI,GAAG;4BACT,MAAM,UAAU,KAAK,gBAAgB;4BAErC,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;gCAC1B,MAAM,cAAc,KAAK,GAAG,CAAC,GAAG,UAAU,IAAI;gCAC9C,cAAc,CAAC,EAAE,GAAG;oCAClB,GAAG,cAAc,CAAC,EAAE;oCACpB,cAAc;oCACd,gBAAgB,UAAU,kCAAkC;gCAC9D;4BACF;wBACF;wBAEA,eAAe,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;wBAC7D,iBAAiB,IAAA,iIAAmB,EAAC,gBAAgB;wBAErD,cAAc,OAAO,GAAG;wBACxB,iBAAiB,OAAO,GAAG;wBAC3B,mCAAmC;wBACnC,gBAAgB,OAAO,GAAG,eAAe,MAAM;wBAE/C,aAAa,CAAC,sBAAsB,EAAE,eAAe,MAAM,CAAC,aAAa,EAAE,kBAAkB,OAAO,GAAG,eAAe,MAAM,EAAE;wBAC9H,IAAA,0HAAc,EAAC;wBACf,OAAO;4BAAE,GAAG,YAAY;4BAAE,OAAO;4BAAgB,OAAO;wBAAE;oBAC5D;oBAEA,MAAM,kBAAkB,SAAS,MAAM;oBACvC,MAAM,oBAAoB,SAAS,MAAM,GAAG,IAAI,KAAK,GAAG,IAAI,SAAS,GAAG,CAAC,CAAA,IAAK,EAAE,YAAY,KAAK;oBAEjG,MAAM,WAAW,aAAa,KAAK,GAAG;oBACtC,aAAa,CAAC,mBAAmB,EAAE,gBAAgB,kBAAkB,EAAE,CAAC,oBAAoB,GAAG,EAAE,OAAO,CAAC,GAAG,oBAAoB,EAAE,SAAS,CAAC,CAAC;oBAE7I,IAAI,YAAY,GAAG;wBACjB,gDAAgD;wBAChD,MAAM,sBAAsB,cAAc,OAAO,GAAG,kBAAkB,OAAO;wBAE7E,IAAI,sBAAsB,GAAG;4BAC3B,4BAA4B;4BAC5B,kBAAkB,OAAO,IAAI;4BAC7B,kBAAkB,CAAA,OAAQ,OAAO;4BAEjC,0DAA0D;4BAC1D,WAAW;gCACT,kBAAkB,OAAO;4BAC3B,GAAG;4BAEH,4DAA4D;4BAC5D,MAAM,UAAU,yHAAW,CAAC,KAAK,CAAC,OAAO;4BAEzC,IAAI,iBAAiB;mCAAI;6BAAS;4BAClC,eAAe,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;4BAE7D,IAAI,YAAY,KAAK,IAAI,CAAC,kBAAkB;4BAC5C,YAAY,KAAK,GAAG,CAAC,WAAW;4BAChC,iBAAiB,eAAe,KAAK,CAAC,GAAG;4BAEzC,MAAM,IAAI,eAAe,MAAM;4BAC/B,IAAI,IAAI,GAAG;gCACT,MAAM,UAAU,KAAK,gBAAgB;gCAErC,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;oCAC1B,MAAM,cAAc,KAAK,GAAG,CAAC,GAAG,UAAU,IAAI;oCAC9C,cAAc,CAAC,EAAE,GAAG;wCAClB,GAAG,cAAc,CAAC,EAAE;wCACpB,cAAc;wCACd,gBAAgB,UAAU,kCAAkC;oCAC9D;gCACF;4BACF;4BAEA,eAAe,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;4BAC7D,iBAAiB,IAAA,iIAAmB,EAAC,gBAAgB;4BAErD,cAAc,OAAO,GAAG;4BACxB,iBAAiB,OAAO,GAAG;4BAC3B,kBAAkB,OAAO,GAAG,iBAAiB,OAAO,EAAE,6CAA6C;4BACnG,gBAAgB,OAAO,GAAG,eAAe,MAAM;4BAE/C,aAAa,CAAC,mCAAmC,EAAE,gBAAgB,WAAW,EAAE,eAAe,MAAM,CAAC,aAAa,EAAE,kBAAkB,OAAO,GAAG,eAAe,MAAM,EAAE;4BACxK,IAAA,0HAAc,EAAC;4BACf,IAAA,2HAAiB;4BACjB,OAAO;gCAAE,GAAG,YAAY;gCAAE,OAAO;gCAAgB,OAAO;gCAAG,OAAO;4BAAE;wBACtE;wBAEA,mCAAmC;wBACnC,aAAa,OAAO,GAAG;wBACvB;wBACA,MAAM,WAAW,KAAK,KAAK,CAAC,CAAC,KAAK,GAAG,KAAK,iBAAiB,OAAO,IAAI;wBACtE,MAAM,aAAa;4BAAE,GAAG,YAAY;4BAAE,OAAO;4BAAU,OAAO;4BAAG,WAAW;4BAAO,YAAY;4BAAM,KAAK;4BAAO,UAAU;wBAAS;wBACpI,WAAW;4BACT,aAAa,OAAO,GAAG;4BACvB,IAAA,0HAAc,EAAC;4BACf,IAAA,2HAAiB;wBACnB,GAAG;wBACH,OAAO;oBACT;oBAEA,MAAM,UAAU,yHAAW,CAAC,KAAK,CAAC,OAAO;oBAEzC,IAAI,iBAAiB;2BAAI;qBAAS;oBAClC,eAAe,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;oBAE7D,IAAI,YAAY,KAAK,IAAI,CAAC,kBAAkB;oBAC5C,YAAY,KAAK,GAAG,CAAC,WAAW;oBAChC,iBAAiB,eAAe,KAAK,CAAC,GAAG;oBAEzC,MAAM,IAAI,eAAe,MAAM;oBAC/B,IAAI,IAAI,GAAG;wBACT,MAAM,UAAU,KAAK,gBAAgB;wBAErC,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;4BAC1B,MAAM,cAAc,KAAK,GAAG,CAAC,GAAG,UAAU,IAAI;4BAC9C,cAAc,CAAC,EAAE,GAAG;gCAClB,GAAG,cAAc,CAAC,EAAE;gCACpB,cAAc;gCACd,gBAAgB,UAAU,kCAAkC;4BAC9D;wBACF;oBACF;oBAEA,eAAe,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;oBAC7D,iBAAiB,IAAA,iIAAmB,EAAC,gBAAgB;oBAErD,cAAc,OAAO,GAAG;oBACxB,iBAAiB,OAAO,GAAG;oBAC3B,kBAAkB,OAAO,GAAG,iBAAiB,OAAO,EAAE,6CAA6C;oBACnG,gBAAgB,OAAO,GAAG,eAAe,MAAM;oBAE/C,aAAa,CAAC,oBAAoB,EAAE,gBAAgB,iBAAiB,EAAE,eAAe,MAAM,CAAC,aAAa,EAAE,kBAAkB,OAAO,GAAG,eAAe,MAAM,EAAE;oBAC/J,IAAA,0HAAc,EAAC;oBACf,IAAA,2HAAiB;oBACjB,OAAO;wBAAE,GAAG,YAAY;wBAAE,OAAO;wBAAgB,OAAO;wBAAU,OAAO;oBAAE;gBAC7E;gBAEA,OAAO;oBAAE,GAAG,YAAY;oBAAE,OAAO;gBAAS;YAC5C;YAEA,cAAc,CAAA;gBACZ,IAAI,CAAC,QAAQ,aAAa,OAAO,EAAE,OAAO;gBAE1C,MAAM,OAAO,cAAc,OAAO;gBAClC,MAAM,OAAO,KAAK,CAAC,GAAG,KAAK,EAAE;gBAC7B,MAAM,OAAO,KAAK,CAAC,GAAG,KAAK,EAAE;gBAE7B,IAAI,OAAO,KAAK,OAAO,KAAK,KAAK,IAAI,OAAO,KAAK,OAAO,KAAK,MAAM,EAAE;oBACnE,OAAO;gBACT;gBAEA,OAAO;oBAAE,GAAG,IAAI;oBAAE,OAAO,KAAK,CAAC;oBAAE,OAAO,KAAK,CAAC;oBAAE,GAAG;oBAAM,GAAG;gBAAK;YACnE;YAEA,YAAY,OAAO,GAAG,sBAAsB;QAC9C;QAEA,YAAY,OAAO,GAAG,sBAAsB;QAE5C,eAAe,OAAO,GAAG,YAAY;YACnC,IAAI,aAAa,OAAO,EAAE;YAC1B,eAAe,KAAK,KAAK,CAAC,CAAC,KAAK,GAAG,KAAK,iBAAiB,OAAO,IAAI;QACtE,GAAG;QAEH,IAAA,0HAAc,EAAC;IACjB,GAAG;QAAC;KAAc;IAElB,IAAA,gHAAS,EAAC;QACR,OAAO;YACL;QACF;IACF,GAAG;QAAC;KAAc;IAElB,IAAA,gHAAS,EAAC;QACR,IAAI,CAAC,cAAc,aAAa,OAAO,EAAE;QAEzC,aAAa,CAAA;YACX,IAAI,CAAC,KAAK,SAAS,IAAI,aAAa,OAAO,EAAE,OAAO;YAEpD,MAAM,YAAY,IAAA,gIAAkB,EAClC,WAAW,CAAC,EAAE,WAAW,CAAC,EAC1B,WAAW,KAAK,EAAE,WAAW,KAAK,EAClC,KAAK,KAAK,EAAE,QAAQ,OAAO;YAG7B,IAAI,WAAW;gBACb,MAAM,cAAc,UAAU,YAAY,GAAG,UAAU,KAAK,GAAG,UAAU,KAAK,GAAG;gBAEjF,2EAA2E;gBAC3E,MAAM,cAAc,IAAA,0HAAY;gBAChC,IAAI,YAAY,MAAM,EAAE;oBACtB,MAAM,aAAuB,EAAE;oBAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,GAAG,CAAC,YAAY,WAAW,EAAE,KAAK,KAAK,CAAC,MAAM,GAAG,IAAK;wBAC7E,MAAM,MAAM,UAAU,KAAK,GAAG;wBAC9B,IAAI,OAAO,KAAK,MAAM,KAAK,KAAK,CAAC,MAAM,EAAE;4BACvC,WAAW,IAAI,CAAC;wBAClB;oBACF;oBAEA,IAAI,WAAW,MAAM,GAAG,GAAG;wBACzB,MAAM,EAAE,UAAU,UAAU,EAAE,YAAY,EAAE,GAAG,IAAA,8HAAgB,EAAC,KAAK,KAAK,EAAE;wBAC5E,MAAM,eAAe,IAAA,iIAAmB,EAAC,YAAY,QAAQ,OAAO;wBAEpE,MAAM,EAAE,MAAM,EAAE,eAAe,EAAE,iBAAiB,EAAE,GAAG,IAAA,6HAAe,EAAC,cAAc;wBAErF,IAAA,0HAAc,EAAC;wBACf,IAAA,wHAAc,EAAC,aAAa,MAAM;wBAElC,MAAM,YAAY,aAAa,IAAI,CAAC,CAAA,IAAK,EAAE,MAAM,IAAI,EAAE,UAAU;wBACjE,IAAI,WAAW;4BACb,IAAA,8HAAoB;wBACtB,OAAO;4BACL,IAAA,wHAAc;wBAChB;wBAEA,cAAc,OAAO,GAAG;wBACxB,cAAc;wBAEd,OAAO;4BACL,GAAG,IAAI;4BACP,OAAO;4BACP,OAAO,KAAK,KAAK,GAAG;4BACpB,OAAO,aAAa,MAAM;4BAC1B,UAAU,KAAK,GAAG,CAAC,KAAK,QAAQ,EAAE,aAAa,MAAM;4BACrD,iBAAiB;gCACf,KAAK,KAAK,eAAe,CAAC,GAAG,GAAG,gBAAgB,GAAG;gCACnD,KAAK,KAAK,eAAe,CAAC,GAAG,GAAG,gBAAgB,GAAG;gCACnD,MAAM,KAAK,eAAe,CAAC,IAAI,GAAG,gBAAgB,IAAI;4BACxD;4BACA,mBAAmB,KAAK,iBAAiB,GAAG;4BAC5C,aAAa,KAAK,QAAQ;4BAC1B,UAAU,IAAA,8HAAgB,EAAC,UAAU,KAAK,GAAG,IAAI,GAAG,KAAK,KAAK,EAAE;wBAClE;oBACF;gBACF;gBAEA,IAAI,WAAW,IAAA,+HAAiB,EAAC,KAAK,KAAK,EAAE,WAAW,IAAI,EAAE;gBAC9D,WAAW,IAAA,iIAAmB,EAAC,UAAU,QAAQ,OAAO;gBAExD,qEAAqE;gBACrE,MAAM,eAAe,IAAA,2HAAa;gBAClC,IAAI,aAAa,MAAM,EAAE;oBACvB,WAAW,IAAA,+HAAiB,EAAC,UAAU,aAAa,aAAa,MAAM;oBACvE,WAAW,IAAA,iIAAmB,EAAC,UAAU,QAAQ,OAAO;oBACxD,IAAA,0HAAc,EAAC;gBACjB;gBAEA,gCAAgC;gBAChC,IAAI,IAAA,yHAAW,KAAI;oBACjB,MAAM,EAAE,UAAU,WAAW,EAAE,YAAY,EAAE,GAAG,IAAA,6HAAe,EAAC,UAAU,aAAa;oBACvF,WAAW;oBAEX,IAAI,aAAa,MAAM,GAAG,GAAG;wBAC3B,MAAM,EAAE,MAAM,EAAE,eAAe,EAAE,iBAAiB,EAAE,GAAG,IAAA,6HAAe,EAAC,cAAc;wBAErF,IAAA,0HAAc,EAAC;wBACf,IAAA,wHAAc,EAAC;wBAEf,MAAM,YAAY,aAAa,IAAI,CAAC,CAAA,IAAK,EAAE,MAAM,IAAI,EAAE,UAAU;wBACjE,IAAI,WAAW;4BACb,IAAA,8HAAoB;wBACtB,OAAO;4BACL,IAAA,wHAAc;wBAChB;wBAEA,cAAc,OAAO,GAAG;wBACxB,cAAc;wBAEd,OAAO;4BACL,GAAG,IAAI;4BACP,OAAO;4BACP,OAAO,KAAK,KAAK,GAAG;4BACpB,OAAO;4BACP,UAAU,KAAK,GAAG,CAAC,KAAK,QAAQ,EAAE;4BAClC,iBAAiB;gCACf,KAAK,KAAK,eAAe,CAAC,GAAG,GAAG,gBAAgB,GAAG;gCACnD,KAAK,KAAK,eAAe,CAAC,GAAG,GAAG,gBAAgB,GAAG;gCACnD,MAAM,KAAK,eAAe,CAAC,IAAI,GAAG,gBAAgB,IAAI;4BACxD;4BACA,mBAAmB,KAAK,iBAAiB,GAAG;4BAC5C,aAAa,KAAK,QAAQ;4BAC1B,UAAU,IAAA,8HAAgB,EAAC,UAAU,KAAK,GAAG,IAAI,GAAG,UAAU;wBAChE;oBACF;gBACF;gBAEA,MAAM,UAAU,IAAA,+HAAiB,EAAC,UAAU,aAAa,WAAW,IAAI;gBAExE,IAAI,QAAQ,MAAM,IAAI,GAAG;oBACvB,MAAM,eAAe,QAAQ,GAAG,CAAC,CAAA,IAAK,QAAQ,CAAC,EAAE;oBACjD,MAAM,EAAE,MAAM,EAAE,eAAe,EAAE,iBAAiB,EAAE,GAAG,IAAA,6HAAe,EAAC,cAAc;oBAErF,MAAM,SAAS,OAAO,CAAC,EAAE;oBACzB,MAAM,SAAS,OAAO,CAAC,QAAQ,MAAM,GAAG,EAAE;oBAC1C,MAAM,WAAW,SAAS,IAAI,QAAQ,CAAC,SAAS,EAAE,GAAG;oBACrD,MAAM,YAAY,SAAS,SAAS,MAAM,GAAG,IAAI,QAAQ,CAAC,SAAS,EAAE,GAAG;oBAExE,WAAW,IAAA,yHAAW,EAAC,UAAU;oBACjC,qEAAqE;oBACrE,MAAM,cAAc,gBAAgB,OAAO,GAAG;oBAC9C,IAAA,8HAAgB,EAAC;oBAEjB,IAAI,cAAc;oBAClB,IAAI,uBAAuB;wBAAE,GAAG,eAAe;oBAAC;oBAChD,IAAI,yBAAyB;oBAC7B,IAAI,eAAe;oBACnB,IAAI,kBAAkB;oBACtB,IAAI,mBAAmB;oBAEvB,gFAAgF;oBAChF,MAAO,mBAAmB,oBAAoB,SAAS,MAAM,IAAI,EAAG;wBAClE,MAAM,UAAU,SAAS,SAAS,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,gBAAiB,EAAE;wBACpE,MAAM,WAAW,SAAS,SAAS,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,iBAAkB,EAAE;wBAEtE,IAAI,UAAU,KAAK,WAAW,KAAK,aAAa,UAAU,GAAG;4BAC3D,aAAa,CAAC,gBAAgB,EAAE,QAAQ,GAAG,EAAE,SAAS,KAAK,EAAE,aAAa,UAAU,GAAG;4BACvF;wBACF;wBAEA,gCAAgC;wBAChC,MAAM,QAAQ,QAAQ,CAAC,QAAQ;wBAC/B,MAAM,SAAS,QAAQ,CAAC,SAAS;wBACjC,MAAM,eAAe,AAAC,MAAM,MAAM,IAAI,OAAO,MAAM,GAC/C,MAAM,MAAM,KAAK,OAAO,MAAM,GAC7B,CAAC,MAAM,MAAM,IAAI,CAAC,OAAO,MAAM,IAAI,MAAM,KAAK,KAAK,OAAO,KAAK;wBAEpE,IAAI,CAAC,cAAc;4BACjB,aAAa,CAAC,kBAAkB,EAAE,MAAM,KAAK,CAAC,CAAC,EAAE,MAAM,MAAM,IAAI,MAAM,GAAG,EAAE,OAAO,KAAK,CAAC,CAAC,EAAE,OAAO,MAAM,IAAI,OAAO;4BACpH;wBACF;wBAEA,yCAAyC;wBACzC,MAAM,eAAe,IAAA,+HAAiB,EAAC,UAAU,SAAS;wBAE1D,IAAI,aAAa,MAAM,GAAG,KAAK,CAAC,aAAa,QAAQ,CAAC,YAAY,CAAC,aAAa,QAAQ,CAAC,WAAW;4BAClG,aAAa,CAAC,oBAAoB,EAAE,aAAa,MAAM,CAAC,SAAS,EAAE,aAAa,QAAQ,CAAC,SAAS,UAAU,EAAE,aAAa,QAAQ,CAAC,WAAW;4BAC/I;wBACF;wBAEA,wBAAwB;wBACxB;wBACA,aAAa,CAAC,oBAAoB,EAAE,aAAa,UAAU,EAAE,aAAa,MAAM,CAAC,MAAM,CAAC;wBAExF,MAAM,oBAAoB,aAAa,GAAG,CAAC,CAAA,IAAK,QAAQ,CAAC,EAAE;wBAC3D,MAAM,cAAc,IAAA,6HAAe,EAAC,mBAAmB,eAAe;wBACtE,eAAe,YAAY,MAAM;wBACjC,qBAAqB,GAAG,IAAI,YAAY,eAAe,CAAC,GAAG;wBAC3D,qBAAqB,GAAG,IAAI,YAAY,eAAe,CAAC,GAAG;wBAC3D,qBAAqB,IAAI,IAAI,YAAY,eAAe,CAAC,IAAI;wBAC7D,0BAA0B,YAAY,iBAAiB;wBAEvD,wCAAwC;wBACxC,MAAM,YAAY,YAAY,CAAC,EAAE;wBACjC,MAAM,YAAY,YAAY,CAAC,aAAa,MAAM,GAAG,EAAE;wBACvD,kBAAkB,YAAY,IAAI,QAAQ,CAAC,YAAY,EAAE,GAAG;wBAC5D,mBAAmB,YAAY,SAAS,MAAM,GAAG,IAAI,QAAQ,CAAC,YAAY,EAAE,GAAG;wBAE/E,WAAW,IAAA,yHAAW,EAAC,UAAU;wBACjC,iDAAiD;wBACjD,IAAA,8HAAgB,EAAC;wBAEjB,mBAAmB;wBACnB,MAAM,iBAAiB,kBAAkB,IAAI,CAAC,CAAA,IAAK,EAAE,MAAM,IAAI,EAAE,UAAU;wBAC3E,IAAI,gBAAgB;4BAClB,IAAA,8HAAoB;wBACtB;wBACA,IAAA,wHAAc,EAAC;wBACf,IAAA,0HAAc,EAAC;oBACjB;oBAEA,qEAAqE;oBACrE,cAAc,OAAO,GAAG;oBACxB,aAAa,CAAC,kBAAkB,EAAE,aAAa,QAAQ,EAAE,aAAa;oBAEtE,IAAA,0HAAc,EAAC;oBAEf,MAAM,YAAY,aAAa,IAAI,CAAC,CAAA,IAAK,EAAE,MAAM,IAAI,EAAE,UAAU;oBACjE,IAAI,WAAW;wBACb,IAAA,8HAAoB;oBACtB,OAAO;wBACL,IAAA,wHAAc,EAAC;oBACjB;oBACA,MAAM,WAAW,KAAK,KAAK,GAAG;oBAE9B,cAAc;oBAEd,+CAA+C;oBAC/C,IAAI,IAAA,sHAAQ,EAAC,aAAa,iBAAiB,OAAO,EAAE;wBAClD,aAAa,OAAO,GAAG;wBACvB;wBACA,MAAM,WAAW,KAAK,KAAK,CAAC,CAAC,KAAK,GAAG,KAAK,iBAAiB,OAAO,IAAI;wBACtE,MAAM,aAAa;4BACjB,GAAG,IAAI;4BACP,OAAO;4BACP,OAAO;4BACP,OAAO;4BACP,UAAU,KAAK,GAAG,CAAC,KAAK,QAAQ,EAAE;4BAClC,iBAAiB;gCACf,KAAK,KAAK,eAAe,CAAC,GAAG,GAAG,qBAAqB,GAAG;gCACxD,KAAK,KAAK,eAAe,CAAC,GAAG,GAAG,qBAAqB,GAAG;gCACxD,MAAM,KAAK,eAAe,CAAC,IAAI,GAAG,qBAAqB,IAAI;4BAC7D;4BACA,mBAAmB,KAAK,iBAAiB,GAAG;4BAC5C,UAAU,KAAK,QAAQ,GAAG;4BAC1B,WAAW;4BACX,YAAY;4BACZ,KAAK;4BACL,UAAU;wBACZ;wBACA,WAAW;4BACT,aAAa,OAAO,GAAG;4BACvB,IAAA,0HAAc,EAAC;wBACjB,GAAG;wBACH,OAAO;oBACT;oBAEA,OAAO;wBACL,GAAG,IAAI;wBACP,OAAO;wBACP,OAAO;wBACP,OAAO;wBACP,UAAU,KAAK,GAAG,CAAC,KAAK,QAAQ,EAAE;wBAClC,iBAAiB;4BACf,KAAK,KAAK,eAAe,CAAC,GAAG,GAAG,qBAAqB,GAAG;4BACxD,KAAK,KAAK,eAAe,CAAC,GAAG,GAAG,qBAAqB,GAAG;4BACxD,MAAM,KAAK,eAAe,CAAC,IAAI,GAAG,qBAAqB,IAAI;wBAC7D;wBACA,mBAAmB,KAAK,iBAAiB,GAAG;wBAC5C,UAAU,KAAK,QAAQ,GAAG;oBAC5B;gBACF,OAAO;oBACL,cAAc;oBACd,IAAI,cAAc,OAAO,EAAE;wBACzB,aAAa,CAAC,iDAAiD,CAAC;oBAClE;oBACA,cAAc,OAAO,GAAG;oBAExB,OAAO;wBACL,GAAG,IAAI;wBACP,OAAO;wBACP,OAAO;wBACP,UAAU,KAAK,QAAQ,GAAG;oBAC5B;gBACF;YACF;YAEA,OAAO;QACT;IACF,GAAG;QAAC;QAAY;KAAc;IAE9B,MAAM,QAAQ,IAAA,kHAAW,EAAC,CAAC,SAAiB;QAC1C,mEAAmE;QACnE,MAAM,qBAAqB,eAAe,OAAO;QACjD,IAAI,CAAC,UAAU,SAAS,IAAI,cAAc,CAAC,oBAAoB;QAE/D,MAAM,KAAK,UAAU,gBAAgB,CAAC;QACtC,MAAM,KAAK,UAAU,gBAAgB,CAAC;QACtC,MAAM,WAAW,KAAK,IAAI,CAAC,KAAK,KAAK,KAAK;QAE1C,IAAI,aAAa,GAAG;QAEpB,MAAM,KAAK,AAAC,KAAK,WAAY,gIAAkB;QAC/C,MAAM,KAAK,AAAC,KAAK,WAAY,gIAAkB;QAE/C,qDAAqD;QACrD,IAAI,cAAc;QAClB,IAAI,IAAA,4HAAc,KAAI;YACpB,cAAc;gBAAE,GAAG,WAAW;gBAAE,WAAW;YAAK;QAClD;QAEA,cAAc;YACZ,GAAG,gBAAgB,CAAC;YACpB,GAAG,gBAAgB,CAAC;YACpB,OAAO,gBAAgB,CAAC;YACxB,OAAO,gBAAgB,CAAC;YACxB;YACA;YACA,MAAM;QACR;QAEA,aAAa,CAAA,OAAQ,CAAC;gBACpB,GAAG,IAAI;gBACP,aAAa,KAAK,QAAQ;gBAC1B,UAAU,IAAA,8HAAgB,EAAC,UAAU,KAAK,GAAG,IAAI,GAAG,KAAK,KAAK,EAAE;gBAChE,YAAY,KAAK,UAAU,GAAG;YAChC,CAAC;QAED,IAAA,0HAAc,EAAC;QACf,IAAA,wHAAc;IAChB,GAAG;QAAC,UAAU,SAAS;QAAE;QAAY;KAAgB;IAErD,MAAM,YAAY,IAAA,kHAAW,EAAC,CAAC,SAAiB;QAC9C,IAAI,CAAC,UAAU,SAAS,EAAE;QAE1B,MAAM,KAAK,UAAU,gBAAgB,CAAC;QACtC,MAAM,KAAK,UAAU,gBAAgB,CAAC;QACtC,MAAM,QAAQ,KAAK,KAAK,CAAC,IAAI;QAE7B,gBAAgB;IAClB,GAAG;QAAC,UAAU,SAAS;QAAE;KAAgB;IAEzC,6DAA6D;IAC7D,MAAM,aAAa,IAAA,kHAAW,EAAC,CAAC;QAC9B,MAAM,uBAAuB,SAAS,kBAAkB;QACxD;QACA,aAAa,OAAO,GAAG;QACvB,YAAY,OAAO,GAAG;QACtB,cAAc,OAAO,GAAG;QAExB,aAAa,CAAA;YACX,IAAI,cAAc,QAAQ,OAAO;YACjC,IAAI,YAAY,MAAM,KAAK,GAAG;gBAC5B,QAAQ,IAAI,CAAC;gBACb,cAAc,IAAA,kIAAoB,EAAC,cAAc,OAAO,CAAC,KAAK,EAAE,cAAc,OAAO,CAAC,MAAM,EAAE;gBAC9F,QAAQ,OAAO,GAAG;gBAClB,QAAQ;YACV;YAEA,MAAM,cAAc,KAAK,KAAK,CAAC,MAAM;YAErC,IAAI,KAAK,KAAK,CAAC,MAAM,KAAK,GAAG;gBAC3B,iBAAiB,OAAO,GAAG;gBAC3B,gBAAgB,OAAO,GAAG;gBAC1B,kBAAkB,OAAO,GAAG;gBAC5B,MAAM,UAAU,uBAAuB,kBAAkB;gBACzD,aAAa,CAAC,CAAC,EAAE,QAAQ,uCAAuC,CAAC;gBACjE,OAAO;oBACL,GAAG,IAAI;oBACP,OAAO,uBAAuB,KAAK,KAAK,GAAG,IAAI;oBAC/C,WAAW;oBACX,YAAY;oBACZ,KAAK;oBACL,kBAAkB,KAAK,gBAAgB,GAAG;gBAC5C;YACF;YAEA,wCAAwC;YACxC,MAAM,UAAU,yHAAW,CAAC,KAAK,CAAC,OAAO;YACzC,IAAI,iBAAiB;mBAAI,KAAK,KAAK;aAAC,CAAC,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;YAEnF,kBAAkB,OAAO,GAAG,aAAa,uBAAuB;YAEhE,IAAI,YAAY,KAAK,IAAI,CAAC,cAAc;YACxC,YAAY,KAAK,GAAG,CAAC,WAAW;YAChC,iBAAiB,eAAe,KAAK,CAAC,GAAG;YAEzC,MAAM,IAAI,eAAe,MAAM;YAC/B,IAAI,IAAI,GAAG;gBACT,MAAM,UAAU,KAAK,gBAAgB;gBACrC,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;oBAC1B,MAAM,cAAc,KAAK,GAAG,CAAC,GAAG,UAAU,IAAI;oBAC9C,cAAc,CAAC,EAAE,GAAG;wBAClB,GAAG,cAAc,CAAC,EAAE;wBACpB,cAAc;wBACd,gBAAgB;oBAClB;gBACF;YACF;YAEA,eAAe,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;YAC7D,iBAAiB,IAAA,iIAAmB,EAAC,gBAAgB;YAErD,cAAc,OAAO,GAAG;YACxB,iBAAiB,OAAO,GAAG;YAC3B,gBAAgB,OAAO,GAAG,eAAe,MAAM;YAE/C,MAAM,UAAU,uBAAuB,kBAAkB;YACzD,aAAa,CAAC,CAAC,EAAE,QAAQ,OAAO,EAAE,YAAY,WAAW,EAAE,eAAe,MAAM,CAAC,aAAa,EAAE,kBAAkB,OAAO,GAAG,eAAe,MAAM,EAAE;YAEnJ,OAAO;gBACL,GAAG,IAAI;gBACP,OAAO;gBACP,OAAO,uBAAuB,KAAK,KAAK,GAAG,IAAI;gBAC/C,WAAW;gBACX,YAAY;gBACZ,KAAK;gBACL,kBAAkB,KAAK,gBAAgB,GAAG;YAC5C;QACF;QAEA,MAAM,cAAc,QAAQ,OAAO;QAEnC,MAAM,UAAU,CAAC;YACf,IAAI,aAAa,OAAO,EAAE;YAE1B,MAAM,YAAY,YAAY,OAAO,GAAG,YAAY,YAAY,OAAO,GAAG;YAC1E,YAAY,OAAO,GAAG;YAEtB,IAAA,+HAAiB;YAEjB,aAAa,CAAA;gBACX,IAAI,CAAC,KAAK,SAAS,IAAI,aAAa,OAAO,EAAE,OAAO;gBAEpD,IAAI,WAAW,IAAA,8HAAgB,MAC3B,KAAK,KAAK,GACV,IAAA,8HAAgB,EAAC,KAAK,KAAK,EAAE;gBACjC,WAAW,IAAA,6HAAe,EAAC,UAAU,WAAW,iBAAiB,OAAO;gBAExE,MAAM,iBAAiB,IAAA,+HAAiB;gBACxC,MAAM,EAAE,MAAM,EAAE,GAAG,eAAe,KAAK;gBACvC,MAAM,EAAE,WAAW,EAAE,GAAG,eAAe,KAAK;gBAE5C,cAAc,OAAO,IAAI;gBAEzB,MAAM,WAAW,CAAC,iBAAiB,OAAO,IACzB,SAAS,MAAM,GAAG,eAClB,gBAAgB,OAAO,GAAG,kBAAkB,OAAO;gBAEpE,IAAI,cAAc,OAAO,IAAI,UAAU,UAAU;oBAC/C,MAAM,UAAU,IAAA,4HAAc;oBAE9B,MAAM,WAAW,SAAS,MAAM,GAAG,IAC/B,SAAS,MAAM,CAAC,CAAC,KAAK,IAAM,EAAE,YAAY,GAAG,IAAI,YAAY,GAAG,IAAI,KAAK,QAAQ,CAAC,EAAE,IACpF;oBACJ,MAAM,eAAe,UAAU,gBAAgB;oBAC/C,MAAM,gBAAgB,KAAK,GAAG,CAAC,GAAG,eAAe;oBAEjD,cAAc,OAAO,GAAG;oBAExB,MAAM,UAAU,IAAA,8HAAgB,EAAC,CAAC,MAAM,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,KAAK,CAAC,IAAI,EAAE,eAAe;oBAC9G,MAAM,UAAU;wBAAE,GAAG,OAAO;wBAAE,gBAAgB,KAAK,GAAG;oBAAG;oBAEzD,WAAW;wBAAC;2BAAY;qBAAS;oBACjC,gBAAgB,OAAO;oBAEvB,IAAI,gBAAgB,OAAO,IAAI,kBAAkB,OAAO,EAAE;wBACxD,iBAAiB,OAAO,GAAG;oBAC7B;gBACF;gBAEA,WAAW,IAAA,iIAAmB,EAAC,UAAU;gBAEzC,IAAI,IAAA,sHAAQ,EAAC,aAAa,iBAAiB,OAAO,EAAE;oBAClD,aAAa,OAAO,GAAG;oBACvB;oBACA,MAAM,WAAW,KAAK,KAAK,CAAC,CAAC,KAAK,GAAG,KAAK,iBAAiB,OAAO,IAAI;oBACtE,MAAM,aAAa;wBAAE,GAAG,IAAI;wBAAE,OAAO;wBAAU,WAAW;wBAAO,YAAY;wBAAM,KAAK;wBAAM,UAAU;oBAAS;oBACjH,WAAW;wBACT,aAAa,OAAO,GAAG;wBACvB,IAAA,0HAAc,EAAC;wBACf,IAAA,sHAAY;oBACd,GAAG;oBACH,OAAO;gBACT;gBAEA,IAAI,IAAA,2HAAa,EAAC,WAAW;oBAC3B,IAAI,IAAA,2HAAa,KAAI;wBACnB,MAAM,UAAU,yHAAW,CAAC,KAAK,CAAC,OAAO;wBACzC,MAAM,cAAc,SAAS,MAAM;wBAEnC,IAAI,iBAAiB;+BAAI;yBAAS;wBAClC,eAAe,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;wBAE7D,IAAI,YAAY,KAAK,IAAI,CAAC,iBAAiB,OAAO,GAAG;wBACrD,YAAY,KAAK,GAAG,CAAC,WAAW;wBAChC,iBAAiB,eAAe,KAAK,CAAC,GAAG;wBAEzC,MAAM,IAAI,eAAe,MAAM;wBAC/B,IAAI,IAAI,GAAG;4BACT,MAAM,UAAU;4BAEhB,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;gCAC1B,MAAM,cAAc,KAAK,GAAG,CAAC,GAAG,UAAU,IAAI;gCAC9C,cAAc,CAAC,EAAE,GAAG;oCAClB,GAAG,cAAc,CAAC,EAAE;oCACpB,cAAc;oCACd,gBAAgB;gCAClB;4BACF;wBACF;wBAEA,eAAe,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;wBAC7D,iBAAiB,IAAA,iIAAmB,EAAC,gBAAgB;wBAErD,cAAc,OAAO,GAAG;wBACxB,iBAAiB,OAAO,GAAG;wBAC3B,kBAAkB,OAAO,GAAG,iBAAiB,OAAO;wBACpD,gBAAgB,OAAO,GAAG,eAAe,MAAM;wBAC/C,IAAA,0HAAc,EAAC;wBACf,OAAO;4BAAE,GAAG,IAAI;4BAAE,OAAO;4BAAgB,OAAO;wBAAE;oBACpD;oBAEA,MAAM,mBAAmB,SAAS,MAAM;oBACxC,MAAM,qBAAqB,SAAS,MAAM,GAAG,IAAI,KAAK,GAAG,IAAI,SAAS,GAAG,CAAC,CAAA,IAAK,EAAE,YAAY,KAAK;oBAElG,MAAM,WAAW,KAAK,KAAK,GAAG;oBAC9B,aAAa,CAAC,mBAAmB,EAAE,iBAAiB,kBAAkB,EAAE,CAAC,qBAAqB,GAAG,EAAE,OAAO,CAAC,GAAG,oBAAoB,EAAE,SAAS,CAAC,CAAC;oBAE/I,IAAI,YAAY,GAAG;wBACjB,MAAM,sBAAsB,cAAc,OAAO,GAAG,kBAAkB,OAAO;wBAE7E,IAAI,sBAAsB,GAAG;4BAC3B,kBAAkB,OAAO,IAAI;4BAC7B,kBAAkB,CAAA,OAAQ,OAAO;4BAEjC,WAAW;gCACT,kBAAkB,OAAO;4BAC3B,GAAG;4BAEH,MAAM,UAAU,yHAAW,CAAC,KAAK,CAAC,OAAO;4BAEzC,IAAI,iBAAiB;mCAAI;6BAAS;4BAClC,eAAe,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;4BAE7D,IAAI,YAAY,KAAK,IAAI,CAAC,mBAAmB;4BAC7C,YAAY,KAAK,GAAG,CAAC,WAAW;4BAChC,iBAAiB,eAAe,KAAK,CAAC,GAAG;4BAEzC,MAAM,IAAI,eAAe,MAAM;4BAC/B,IAAI,IAAI,GAAG;gCACT,MAAM,UAAU;gCAEhB,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;oCAC1B,MAAM,cAAc,KAAK,GAAG,CAAC,GAAG,UAAU,IAAI;oCAC9C,cAAc,CAAC,EAAE,GAAG;wCAClB,GAAG,cAAc,CAAC,EAAE;wCACpB,cAAc;wCACd,gBAAgB;oCAClB;gCACF;4BACF;4BAEA,eAAe,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;4BAC7D,iBAAiB,IAAA,iIAAmB,EAAC,gBAAgB;4BAErD,cAAc,OAAO,GAAG;4BACxB,iBAAiB,OAAO,GAAG;4BAC3B,kBAAkB,OAAO,GAAG,iBAAiB,OAAO,EAAE,6CAA6C;4BACnG,gBAAgB,OAAO,GAAG,eAAe,MAAM;4BAE/C,aAAa,CAAC,mCAAmC,EAAE,iBAAiB,WAAW,EAAE,eAAe,MAAM,CAAC,aAAa,EAAE,kBAAkB,OAAO,GAAG,eAAe,MAAM,EAAE;4BACzK,IAAA,0HAAc,EAAC;4BACf,IAAA,2HAAiB;4BACjB,OAAO;gCAAE,GAAG,IAAI;gCAAE,OAAO;gCAAgB,OAAO;gCAAG,OAAO;4BAAE;wBAC9D;wBAEA,aAAa,OAAO,GAAG;wBACvB;wBACA,MAAM,WAAW,KAAK,KAAK,CAAC,CAAC,KAAK,GAAG,KAAK,iBAAiB,OAAO,IAAI;wBACtE,MAAM,aAAa;4BAAE,GAAG,IAAI;4BAAE,OAAO;4BAAU,OAAO;4BAAG,WAAW;4BAAO,YAAY;4BAAM,KAAK;4BAAO,UAAU;wBAAS;wBAC5H,WAAW;4BACT,aAAa,OAAO,GAAG;4BACvB,IAAA,0HAAc,EAAC;4BACf,IAAA,2HAAiB;wBACnB,GAAG;wBACH,OAAO;oBACT;oBAEA,MAAM,UAAU,yHAAW,CAAC,KAAK,CAAC,OAAO;oBAEzC,IAAI,iBAAiB;2BAAI;qBAAS;oBAClC,eAAe,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;oBAE7D,IAAI,YAAY,KAAK,IAAI,CAAC,mBAAmB;oBAC7C,YAAY,KAAK,GAAG,CAAC,WAAW;oBAChC,iBAAiB,eAAe,KAAK,CAAC,GAAG;oBAEzC,MAAM,IAAI,eAAe,MAAM;oBAC/B,IAAI,IAAI,GAAG;wBACT,MAAM,UAAU;wBAEhB,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;4BAC1B,MAAM,cAAc,KAAK,GAAG,CAAC,GAAG,UAAU,IAAI;4BAC9C,cAAc,CAAC,EAAE,GAAG;gCAClB,GAAG,cAAc,CAAC,EAAE;gCACpB,cAAc;gCACd,gBAAgB;4BAClB;wBACF;oBACF;oBAEA,eAAe,IAAI,CAAC,CAAC,GAAG,IAAM,EAAE,YAAY,GAAG,EAAE,YAAY;oBAC7D,iBAAiB,IAAA,iIAAmB,EAAC,gBAAgB;oBAErD,cAAc,OAAO,GAAG;oBACxB,iBAAiB,OAAO,GAAG;oBAC3B,kBAAkB,OAAO,GAAG,iBAAiB,OAAO,EAAE,6CAA6C;oBACnG,gBAAgB,OAAO,GAAG,eAAe,MAAM;oBAE/C,aAAa,CAAC,oBAAoB,EAAE,iBAAiB,iBAAiB,EAAE,eAAe,MAAM,CAAC,aAAa,EAAE,kBAAkB,OAAO,GAAG,eAAe,MAAM,EAAE;oBAChK,IAAA,0HAAc,EAAC;oBACf,IAAA,2HAAiB;oBACjB,OAAO;wBAAE,GAAG,IAAI;wBAAE,OAAO;wBAAgB,OAAO;wBAAU,OAAO;oBAAE;gBACrE;gBAEA,OAAO;oBAAE,GAAG,IAAI;oBAAE,OAAO;gBAAS;YACpC;YAEA,cAAc,CAAA;gBACZ,IAAI,CAAC,QAAQ,aAAa,OAAO,EAAE,OAAO;gBAE1C,MAAM,OAAO,cAAc,OAAO;gBAClC,MAAM,OAAO,KAAK,CAAC,GAAG,KAAK,EAAE;gBAC7B,MAAM,OAAO,KAAK,CAAC,GAAG,KAAK,EAAE;gBAE7B,IAAI,OAAO,KAAK,OAAO,KAAK,KAAK,IAAI,OAAO,KAAK,OAAO,KAAK,MAAM,EAAE;oBACnE,OAAO;gBACT;gBAEA,OAAO;oBAAE,GAAG,IAAI;oBAAE,OAAO,KAAK,CAAC;oBAAE,OAAO,KAAK,CAAC;oBAAE,GAAG;oBAAM,GAAG;gBAAK;YACnE;YAEA,YAAY,OAAO,GAAG,sBAAsB;QAC9C;QAEA,YAAY,OAAO,GAAG,sBAAsB;QAE5C,eAAe,OAAO,GAAG,YAAY;YACnC,IAAI,aAAa,OAAO,EAAE;YAC1B,eAAe,KAAK,KAAK,CAAC,CAAC,KAAK,GAAG,KAAK,iBAAiB,OAAO,IAAI;QACtE,GAAG;QAEH,IAAA,0HAAc,EAAC;IACjB,GAAG;QAAC;QAAe;KAAM;IAEzB,MAAM,gBAAgB,UAAU,KAAK,CAAC,MAAM;IAC5C,MAAM,aAAa,iBAAiB,OAAO;IAC3C,MAAM,eAAe,gBAAgB,OAAO;IAC5C,MAAM,iBAAiB,aAAa,eAAe;IACnD,MAAM,iBAAiB,kBAAkB,OAAO;IAEhD,MAAM,cAAc,IAAA,kHAAW,EAAC;QAC9B,aAAa,CAAA;YACX,MAAM,gBAAgB,IAAA,+HAAiB,EAAC,KAAK,KAAK,EAAE;YACpD,MAAM,eAAe,IAAA,iIAAmB,EAAC,eAAe,QAAQ,OAAO;YACvE,OAAO;gBAAE,GAAG,IAAI;gBAAE,OAAO;YAAa;QACxC;QACA,IAAA,0HAAc,EAAC;IACjB,GAAG,EAAE;IAEL,2DAA2D;IAC3D,MAAM,eAAe,IAAA,kHAAW,EAAC,CAAC;QAChC,WAAW;YAAE,gBAAgB;QAAK;IACpC,GAAG;QAAC;KAAW;IAEf,MAAM,cAAc,IAAA,kHAAW,EAAC;QAC9B,YAAY,OAAO,GAAG,CAAC,YAAY,OAAO;QAC1C,YAAY,YAAY,OAAO;QAC/B,aAAa,CAAC,aAAa,EAAE,YAAY,OAAO,GAAG,WAAW,WAAW;IAC3E,GAAG,EAAE;IAEL,MAAM,YAAY,IAAA,kHAAW,EAAC;QAC5B,IAAI,YAAY,OAAO,EAAE;YACvB,aAAa,OAAO,GAAG;YACvB,aAAa,CAAC,0BAA0B,CAAC;QAC3C;IACF,GAAG,EAAE;IAEL,OAAO;QACL;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACF;AACF"}},
    {"offset": {"line": 3961, "column": 0}, "map": {"version":3,"sources":["file:///D:/BeadsLine/contexts/UserContext.tsx"],"sourcesContent":["import { createContext, useContext, useEffect, useState, type ReactNode } from 'react';\nimport type { User } from '@shared/schema';\nimport { getTelegramUser, initTelegramApp, isTelegramWebApp, getStartParam } from '@/lib/telegram';\nimport { apiRequest } from '@/lib/queryClient';\n\ninterface UserContextType {\n  user: User | null;\n  isLoading: boolean;\n  error: string | null;\n  refreshUser: () => Promise<void>;\n}\n\nconst UserContext = createContext<UserContextType>({\n  user: null,\n  isLoading: true,\n  error: null,\n  refreshUser: async () => {},\n});\n\nexport function UserProvider({ children }: { children: ReactNode }) {\n  const [user, setUser] = useState<User | null>(null);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const initUser = async () => {\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      if (isTelegramWebApp()) {\n        initTelegramApp();\n      }\n\n      // Проверяем, есть ли параметр forceAdmin в URL\n      const urlParams = typeof window !== 'undefined'\n        ? new URLSearchParams(window.location.search)\n        : new URLSearchParams();\n      const isAdminForced = urlParams.get('forceAdmin') === 'true' || urlParams.get('forceAdmin') === '1';\n\n      // Если forceAdmin=true, сначала устанавливаем сессию на сервере\n      if (process.env.NODE_ENV === 'development' && isAdminForced) {\n        await fetch('/api/auth/me?forceAdmin=true', {\n          method: 'GET',\n          credentials: 'include'\n        });\n      }\n\n      // First check if there's an existing session (e.g., admin login)\n      try {\n        const meResponse = await fetch('/api/auth/me', { credentials: 'include' });\n        if (meResponse.ok) {\n          const existingUser = await meResponse.json();\n          setUser(existingUser);\n          return;\n        }\n      } catch {\n        // No existing session, continue with normal auth\n      }\n\n      const telegramUser = getTelegramUser();\n      const startParam = getStartParam();\n\n      if (telegramUser) {\n        const response = await apiRequest('POST', '/api/auth/telegram', {\n          telegramId: telegramUser.id.toString(),\n          username: telegramUser.username || `user_${telegramUser.id}`,\n          firstName: telegramUser.first_name,\n          lastName: telegramUser.last_name,\n          photoUrl: telegramUser.photo_url,\n          startParam: startParam || undefined,\n        });\n\n        const data = await response.json();\n        setUser(data);\n      } else {\n        // Попробуем получить данные пользователя без Telegram, если сессия существует\n        try {\n          const meResponse = await fetch('/api/auth/me', { credentials: 'include' });\n          if (meResponse.ok) {\n            const userData = await meResponse.json();\n            setUser(userData);\n          } else {\n            // Для локальной разработки создаем фейкового пользователя, если нет сессии\n            if (process.env.NODE_ENV === 'development') {\n              const fakeUser = {\n                id: 'dev-user-12345',\n                telegramId: '123456789',\n                username: 'dev_tester',\n                firstName: 'Dev',\n                lastName: 'Tester',\n                photoUrl: null,\n                totalPoints: 5000,\n                gamesPlayed: 10,\n                bestScore: 1500,\n                btcBalance: 0.001,\n                ethBalance: 0.01,\n                usdtBalance: 10.5,\n                btcBalanceSats: 100000,\n                btcTodaySats: 0,\n                ethBalanceWei: 10000000000000000,\n                ethTodayWei: 0,\n                usdtToday: \"0.00\",\n                referralCode: 'DEVTEST',\n                referredBy: null,\n                directReferralsCount: 0,\n                completedLevels: [1, 2, 3, 4, 5],\n                signupBonusReceived: true,\n                ratingScore: 1200,\n                totalScore: 5000,\n                totalWins: 5,\n                currentWinStreak: 2,\n                bestWinStreak: 5,\n                totalCombo5Plus: 10,\n                characterGender: 'male',\n                characterName: 'Dev Player',\n                characterEnergy: 100,\n                characterHealthState: 'normal',\n                characterMood: 'happy',\n                bonusLives: 0,\n                btcTodayDate: new Date().toISOString().split('T')[0], // Добавляем отсутствующее поле\n                ethTodayDate: new Date().toISOString().split('T')[0], // Добавляем отсутствующее поле\n                usdtTodayDate: new Date().toISOString().split('T')[0], // Добавляем отсутствующее поле\n                lastActivityAt: new Date(),\n                createdAt: new Date(),\n                deletedAt: null,\n                isAdmin: isAdminForced // Устанавливаем isAdmin в true, если forceAdmin=true\n              };\n              setUser(fakeUser);\n            } else {\n              // Если не в разработке, оставляем пользователя как null, но не устанавливаем ошибку\n              setUser(null);\n            }\n          }\n        } catch (err) {\n          console.error('Error fetching user without Telegram:', err);\n          // Для локальной разработки создаем фейкового пользователя при ошибке\n          if (process.env.NODE_ENV === 'development') {\n            const fakeUser = {\n              id: 'dev-user-12345',\n              telegramId: '123456789',\n              username: 'dev_tester',\n              firstName: 'Dev',\n              lastName: 'Tester',\n              photoUrl: null,\n              totalPoints: 5000,\n              gamesPlayed: 10,\n              bestScore: 1500,\n              btcBalance: 0.001,\n              ethBalance: 0.01,\n              usdtBalance: 10.5,\n              btcBalanceSats: 100000,\n              btcTodaySats: 0,\n              ethBalanceWei: 10000000000000000,\n              ethTodayWei: 0,\n              usdtToday: \"0.00\",\n              referralCode: 'DEVTEST',\n              referredBy: null,\n              directReferralsCount: 0,\n              completedLevels: [1, 2, 3, 4, 5],\n              signupBonusReceived: true,\n              btcTodayDate: new Date().toISOString().split('T')[0], // Добавляем отсутствующее поле\n              ethTodayDate: new Date().toISOString().split('T')[0], // Добавляем отсутствующее поле\n              usdtTodayDate: new Date().toISOString().split('T')[0], // Добавляем отсутствующее поле\n              lastActivityAt: new Date(),\n              createdAt: new Date(),\n              ratingScore: 1200,\n              totalScore: 5000,\n              totalWins: 5,\n              currentWinStreak: 2,\n              bestWinStreak: 5,\n              totalCombo5Plus: 10,\n              characterGender: 'male',\n              characterName: 'Dev Player',\n              characterEnergy: 100,\n              characterHealthState: 'normal',\n              characterMood: 'happy',\n              bonusLives: 0,\n              deletedAt: null,\n              isAdmin: isAdminForced // Устанавливаем isAdmin в true, если forceAdmin=true\n            };\n            setUser(fakeUser);\n          } else {\n            setUser(null);\n          }\n        }\n      }\n    } catch (err) {\n      console.error('Failed to initialize user:', err);\n      setError('Failed to initialize user');\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const refreshUser = async () => {\n    try {\n      // Проверяем, есть ли параметр forceAdmin в URL\n      const urlParams = typeof window !== 'undefined'\n        ? new URLSearchParams(window.location.search)\n        : new URLSearchParams();\n      const isAdminForced = urlParams.get('forceAdmin') === 'true' || urlParams.get('forceAdmin') === '1';\n\n      // Если forceAdmin=true и мы в режиме разработки, сначала устанавливаем сессию на сервере\n      if (process.env.NODE_ENV === 'development' && isAdminForced) {\n        await fetch('/api/auth/me?forceAdmin=true', {\n          method: 'GET',\n          credentials: 'include'\n        });\n      }\n\n      // Use /api/auth/me endpoint which checks session and returns current user data including admin status\n      const response = await fetch('/api/auth/me', { credentials: 'include' });\n      if (response.ok) {\n        const data = await response.json();\n        setUser(data);\n      } else {\n        // Если /api/auth.me возвращает 401, это может означать, что сессия была сброшена\n        // В этом случае не пытаемся получить данные по старому user.id\n        // Вместо этого, если в режиме разработки и есть forceAdmin, создаем фейкового администратора\n        if (process.env.NODE_ENV === 'development' && isAdminForced) {\n          const fakeUser = {\n            id: 'dev-user-12345',\n            telegramId: '123456789',\n            username: 'dev_tester',\n            firstName: 'Dev',\n            lastName: 'Tester',\n            photoUrl: null,\n            totalPoints: 5000,\n            gamesPlayed: 10,\n            bestScore: 1500,\n            btcBalance: 0.001,\n            ethBalance: 0.01,\n            usdtBalance: 10.5,\n            btcBalanceSats: 100000,\n            btcTodaySats: 0,\n            ethBalanceWei: 10000000000000000,\n            ethTodayWei: 0,\n            usdtToday: \"0.00\",\n            referralCode: 'DEVTEST',\n            referredBy: null,\n            directReferralsCount: 0,\n            completedLevels: [1, 2, 3, 4, 5],\n            signupBonusReceived: true,\n            ratingScore: 1200,\n            totalScore: 5000,\n            totalWins: 5,\n            currentWinStreak: 2,\n            bestWinStreak: 5,\n            totalCombo5Plus: 10,\n            characterGender: 'male',\n            characterName: 'Dev Player',\n            characterEnergy: 100,\n            characterHealthState: 'normal',\n            characterMood: 'happy',\n            bonusLives: 0,\n            btcTodayDate: new Date().toISOString().split('T')[0], // Добавляем отсутствующее поле\n            ethTodayDate: new Date().toISOString().split('T')[0], // Добавляем отсутствующее поле\n            usdtTodayDate: new Date().toISOString().split('T')[0], // Добавляем отсутствующее поле\n            lastActivityAt: new Date(),\n            createdAt: new Date(),\n            deletedAt: null,\n            isAdmin: true // Устанавливаем isAdmin в true, если forceAdmin=true\n          };\n          setUser(fakeUser);\n        }\n      }\n    } catch (err) {\n      console.error('Failed to refresh user:', err);\n    }\n  };\n\n  useEffect(() => {\n    initUser();\n  }, []);\n\n  return (\n    <UserContext.Provider value={{ user, isLoading, error, refreshUser }}>\n      {children}\n    </UserContext.Provider>\n  );\n}\n\nexport function useUser() {\n  return useContext(UserContext);\n}\n"],"names":[],"mappings":"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"}}]
}