{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///D:/BeadsLine/hooks/use-toast.ts"],"sourcesContent":["import * as React from \"react\"\r\n\r\nimport type {\r\n  ToastActionElement,\r\n  ToastProps,\r\n} from \"@/components/ui/toast\"\r\n\r\nconst TOAST_LIMIT = 1\r\nconst TOAST_REMOVE_DELAY = 1000000\r\n\r\ntype ToasterToast = ToastProps & {\r\n  id: string\r\n  title?: React.ReactNode\r\n  description?: React.ReactNode\r\n  action?: ToastActionElement\r\n}\r\n\r\nconst actionTypes = {\r\n  ADD_TOAST: \"ADD_TOAST\",\r\n  UPDATE_TOAST: \"UPDATE_TOAST\",\r\n  DISMISS_TOAST: \"DISMISS_TOAST\",\r\n  REMOVE_TOAST: \"REMOVE_TOAST\",\r\n} as const\r\n\r\nlet count = 0\r\n\r\nfunction genId() {\r\n  count = (count + 1) % Number.MAX_SAFE_INTEGER\r\n  return count.toString()\r\n}\r\n\r\ntype ActionType = typeof actionTypes\r\n\r\ntype Action =\r\n  | {\r\n      type: ActionType[\"ADD_TOAST\"]\r\n      toast: ToasterToast\r\n    }\r\n  | {\r\n      type: ActionType[\"UPDATE_TOAST\"]\r\n      toast: Partial<ToasterToast>\r\n    }\r\n  | {\r\n      type: ActionType[\"DISMISS_TOAST\"]\r\n      toastId?: ToasterToast[\"id\"]\r\n    }\r\n  | {\r\n      type: ActionType[\"REMOVE_TOAST\"]\r\n      toastId?: ToasterToast[\"id\"]\r\n    }\r\n\r\ninterface State {\r\n  toasts: ToasterToast[]\r\n}\r\n\r\nconst toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()\r\n\r\nconst addToRemoveQueue = (toastId: string) => {\r\n  if (toastTimeouts.has(toastId)) {\r\n    return\r\n  }\r\n\r\n  const timeout = setTimeout(() => {\r\n    toastTimeouts.delete(toastId)\r\n    dispatch({\r\n      type: \"REMOVE_TOAST\",\r\n      toastId: toastId,\r\n    })\r\n  }, TOAST_REMOVE_DELAY)\r\n\r\n  toastTimeouts.set(toastId, timeout)\r\n}\r\n\r\nexport const reducer = (state: State, action: Action): State => {\r\n  switch (action.type) {\r\n    case \"ADD_TOAST\":\r\n      return {\r\n        ...state,\r\n        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),\r\n      }\r\n\r\n    case \"UPDATE_TOAST\":\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.map((t) =>\r\n          t.id === action.toast.id ? { ...t, ...action.toast } : t\r\n        ),\r\n      }\r\n\r\n    case \"DISMISS_TOAST\": {\r\n      const { toastId } = action\r\n\r\n      // ! Side effects ! - This could be extracted into a dismissToast() action,\r\n      // but I'll keep it here for simplicity\r\n      if (toastId) {\r\n        addToRemoveQueue(toastId)\r\n      } else {\r\n        state.toasts.forEach((toast) => {\r\n          addToRemoveQueue(toast.id)\r\n        })\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.map((t) =>\r\n          t.id === toastId || toastId === undefined\r\n            ? {\r\n                ...t,\r\n                open: false,\r\n              }\r\n            : t\r\n        ),\r\n      }\r\n    }\r\n    case \"REMOVE_TOAST\":\r\n      if (action.toastId === undefined) {\r\n        return {\r\n          ...state,\r\n          toasts: [],\r\n        }\r\n      }\r\n      return {\r\n        ...state,\r\n        toasts: state.toasts.filter((t) => t.id !== action.toastId),\r\n      }\r\n  }\r\n}\r\n\r\nconst listeners: Array<(state: State) => void> = []\r\n\r\nlet memoryState: State = { toasts: [] }\r\n\r\nfunction dispatch(action: Action) {\r\n  memoryState = reducer(memoryState, action)\r\n  listeners.forEach((listener) => {\r\n    listener(memoryState)\r\n  })\r\n}\r\n\r\ntype Toast = Omit<ToasterToast, \"id\">\r\n\r\nfunction toast({ ...props }: Toast) {\r\n  const id = genId()\r\n\r\n  const update = (props: ToasterToast) =>\r\n    dispatch({\r\n      type: \"UPDATE_TOAST\",\r\n      toast: { ...props, id },\r\n    })\r\n  const dismiss = () => dispatch({ type: \"DISMISS_TOAST\", toastId: id })\r\n\r\n  dispatch({\r\n    type: \"ADD_TOAST\",\r\n    toast: {\r\n      ...props,\r\n      id,\r\n      open: true,\r\n      onOpenChange: (open) => {\r\n        if (!open) dismiss()\r\n      },\r\n    },\r\n  })\r\n\r\n  return {\r\n    id: id,\r\n    dismiss,\r\n    update,\r\n  }\r\n}\r\n\r\nfunction useToast() {\r\n  const [state, setState] = React.useState<State>(memoryState)\r\n\r\n  React.useEffect(() => {\r\n    listeners.push(setState)\r\n    return () => {\r\n      const index = listeners.indexOf(setState)\r\n      if (index > -1) {\r\n        listeners.splice(index, 1)\r\n      }\r\n    }\r\n  }, [state])\r\n\r\n  return {\r\n    ...state,\r\n    toast,\r\n    dismiss: (toastId?: string) => dispatch({ type: \"DISMISS_TOAST\", toastId }),\r\n  }\r\n}\r\n\r\nexport { useToast, toast }\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///D:/BeadsLine/hooks/useGameState.ts"],"sourcesContent":["import { useState, useCallback, useRef, useEffect } from 'react';\r\nimport type { GameState, Ball } from '@shared/schema';\r\nimport {\r\n  createInitialGameState,\r\n  createRandomBall,\r\n  createBallFromChain,\r\n  generatePathForLevel,\r\n  getShooterPosition,\r\n  updateBallPositions,\r\n  moveBallsForward,\r\n  processRollback,\r\n  findMatchingBalls,\r\n  findAllMatches,\r\n  calculatePoints,\r\n  insertBallInChain,\r\n  removeBalls,\r\n  checkCollision,\r\n  checkPathCollision,\r\n  checkGameOver,\r\n  checkWin,\r\n  setAvailableCrypto,\r\n  setUsdtFundEnabled,\r\n  setEconomyConfig,\r\n  setGameplayConfig,\r\n  getGameplayConfig,\r\n  getBallSpacing,\r\n  resetCryptoSpawnedCount,\r\n  setCurrentLevel,\r\n  updateBoostTimers,\r\n  consumeBomb,\r\n  applyBombEffect,\r\n  consumeRainbow,\r\n  consumeRewind,\r\n  applyRewindEffect,\r\n  consumeShield,\r\n  consumeMagnet,\r\n  applyMagnetEffect,\r\n  consumeLaser,\r\n  applyLaserEffect,\r\n  SHOOTER_BALL_SPEED,\r\n  debugLog,\r\n  activateRollback,\r\n  isRollbackActive,\r\n  type PathPoint,\r\n} from '@/lib/gameEngine';\r\nimport { GAME_CONFIG } from '@/lib/gameConfig';\r\nimport { hapticFeedback } from '@/lib/telegram';\r\nimport { \r\n  playShootSound, \r\n  playMatchSound, \r\n  playCryptoMatchSound, \r\n  playComboSound,\r\n  playLifeLostSound,\r\n  playWinSound,\r\n  playGameOverSound,\r\n  initSounds\r\n} from '@/lib/sounds';\r\nimport type { LevelConfig } from '@/lib/levelConfig';\r\n\r\ninterface UseGameStateProps {\r\n  canvasWidth: number;\r\n  canvasHeight: number;\r\n  onGameEnd?: (state: GameState) => void;\r\n  level: LevelConfig;\r\n  bonusLives?: number;\r\n  onUseBonusLife?: () => void;\r\n}\r\n\r\ninterface Projectile {\r\n  x: number;\r\n  y: number;\r\n  prevX: number;\r\n  prevY: number;\r\n  vx: number;\r\n  vy: number;\r\n  ball: Ball;\r\n}\r\n\r\ninterface GapContext {\r\n  leftBallId: string | null;\r\n  rightBallId: string | null;\r\n}\r\n\r\ninterface PendingChainReaction {\r\n  matchedBallIds: string[];\r\n  newLeftBallId: string | null;\r\n  newRightBallId: string | null;\r\n  combo: number;\r\n}\r\n\r\nconst CHAIN_REACTION_DELAY = 150;\r\n\r\n// Debug log buffer - accumulates logs and sends them in batches\r\nconst debugLogBuffer: string[] = [];\r\nlet debugLogTimeout: ReturnType<typeof setTimeout> | null = null;\r\n\r\nfunction sendDebugLog(message: string) {\r\n  const timestamp = new Date().toISOString().slice(11, 23);\r\n  debugLogBuffer.push(`[${timestamp}] ${message}`);\r\n  \r\n  // Debounce sending - wait 500ms after last log before sending batch\r\n  if (debugLogTimeout) clearTimeout(debugLogTimeout);\r\n  debugLogTimeout = setTimeout(() => {\r\n    if (debugLogBuffer.length > 0) {\r\n      const logsToSend = [...debugLogBuffer];\r\n      debugLogBuffer.length = 0;\r\n      fetch('/api/debug-logs', {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({ logs: logsToSend }),\r\n      }).catch(() => {}); // Ignore errors\r\n    }\r\n  }, 500);\r\n}\r\n\r\nexport function useGameState({ canvasWidth, canvasHeight, onGameEnd, level, bonusLives = 0, onUseBonusLife }: UseGameStateProps) {\r\n  const [gameState, setGameState] = useState<GameState>(createInitialGameState);\r\n  const [path, setPath] = useState<PathPoint[]>([]);\r\n  const [projectile, setProjectile] = useState<Projectile | null>(null);\r\n  const [shooterAngle, setShooterAngle] = useState(-Math.PI / 2);\r\n  const [elapsedTime, setElapsedTime] = useState(0);\r\n  const [usedBonusLives, setUsedBonusLives] = useState(0);\r\n  const [isPaused, setIsPaused] = useState(false);\r\n  \r\n  const isPausedRef = useRef(false);\r\n  const stepFrameRef = useRef(false);\r\n  const gameLoopRef = useRef<number | null>(null);\r\n  const timeTrackerRef = useRef<ReturnType<typeof setInterval> | null>(null);\r\n  const lastTimeRef = useRef<number>(0);\r\n  const pathRef = useRef<PathPoint[]>([]);\r\n  const onGameEndRef = useRef(onGameEnd);\r\n  const gameEndedRef = useRef(false);\r\n  const dimensionsRef = useRef({ width: canvasWidth, height: canvasHeight });\r\n  const gameStartTimeRef = useRef<number>(0);\r\n  const spawnAccumRef = useRef<number>(0);\r\n  const totalSpawnedRef = useRef<number>(0);\r\n  const spawnFinishedRef = useRef<boolean>(false);\r\n  const gapContextRef = useRef<GapContext | null>(null);\r\n  const maxTotalBallsRef = useRef<number>(100);\r\n  const currentLifeMaxRef = useRef<number>(100); // Лимит шаров на текущую жизнь\r\n  const pendingChainReactionRef = useRef<PendingChainReaction | null>(null);\r\n  const bonusLivesRef = useRef(bonusLives);\r\n  const usedBonusLivesRef = useRef(0);\r\n  const onUseBonusLifeRef = useRef(onUseBonusLife);\r\n  const shooterBallRef = useRef(gameState.shooterBall);\r\n  \r\n  useEffect(() => {\r\n    shooterBallRef.current = gameState.shooterBall;\r\n  }, [gameState.shooterBall]);\r\n  \r\n  useEffect(() => {\r\n    bonusLivesRef.current = bonusLives;\r\n  }, [bonusLives]);\r\n  \r\n  useEffect(() => {\r\n    onUseBonusLifeRef.current = onUseBonusLife;\r\n  }, [onUseBonusLife]);\r\n  const chainReactionTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\r\n  \r\n  onGameEndRef.current = onGameEnd;\r\n  pathRef.current = path;\r\n  dimensionsRef.current = { width: canvasWidth, height: canvasHeight };\r\n  \r\n  const shooterPosition = getShooterPosition(canvasWidth, canvasHeight);\r\n\r\n  useEffect(() => {\r\n    if (canvasWidth > 0 && canvasHeight > 0) {\r\n      setCurrentLevel(level);\r\n      const newPath = generatePathForLevel(canvasWidth, canvasHeight, level);\r\n      setPath(newPath);\r\n      pathRef.current = newPath;\r\n    }\r\n  }, [canvasWidth, canvasHeight, level]);\r\n\r\n  const stopAllTimers = useCallback(() => {\r\n    if (gameLoopRef.current !== null) {\r\n      cancelAnimationFrame(gameLoopRef.current);\r\n      gameLoopRef.current = null;\r\n    }\r\n    if (timeTrackerRef.current !== null) {\r\n      clearInterval(timeTrackerRef.current);\r\n      timeTrackerRef.current = null;\r\n    }\r\n    if (chainReactionTimeoutRef.current !== null) {\r\n      clearTimeout(chainReactionTimeoutRef.current);\r\n      chainReactionTimeoutRef.current = null;\r\n    }\r\n    pendingChainReactionRef.current = null;\r\n  }, []);\r\n\r\n  const startGame = useCallback(async () => {\r\n    if (timeTrackerRef.current !== null) {\r\n      console.warn('Game already running, ignoring startGame call');\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      const [economyRes, gameplayRes, cryptoAvailRes] = await Promise.all([\r\n        fetch('/api/game-economy'),\r\n        fetch('/api/gameplay-config'),\r\n        fetch('/api/crypto-availability', { credentials: 'include' }),\r\n      ]);\r\n      \r\n      // Default to crypto disabled for safety\r\n      let cryptoAvailable = { btc: false, eth: false, usdt: false };\r\n      \r\n      if (economyRes.ok) {\r\n        const economyData = await economyRes.json();\r\n        setEconomyConfig(economyData);\r\n        // Get crypto availability from economy config (respects cryptoFundEnabled toggle)\r\n        cryptoAvailable = economyData.cryptoAvailable || { btc: false, eth: false, usdt: false };\r\n        setUsdtFundEnabled(economyData.usdtFundEnabled === true);\r\n      }\r\n      \r\n      if (cryptoAvailRes.ok) {\r\n        const cryptoAvail = await cryptoAvailRes.json();\r\n        // Only override if crypto-availability returns explicit values\r\n        // This endpoint also respects cryptoFundEnabled, so use AND logic\r\n        cryptoAvailable = {\r\n          btc: cryptoAvailable.btc && (cryptoAvail.btcEnabled === true),\r\n          eth: cryptoAvailable.eth && (cryptoAvail.ethEnabled === true),\r\n          usdt: cryptoAvailable.usdt && (cryptoAvail.usdtEnabled === true),\r\n        };\r\n      }\r\n      \r\n      setAvailableCrypto(cryptoAvailable);\r\n      \r\n      if (gameplayRes.ok) {\r\n        const gameplayData = await gameplayRes.json();\r\n        // Override with level-specific spawn period if available\r\n        if (level?.spawnPeriod) {\r\n          gameplayData.spawn = { ...gameplayData.spawn, period: level.spawnPeriod };\r\n        }\r\n        setGameplayConfig(gameplayData);\r\n        maxTotalBallsRef.current = gameplayData.balls?.maxTotalBalls || 100;\r\n        currentLifeMaxRef.current = maxTotalBallsRef.current; // Изначально = максимум\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to fetch game config:', error);\r\n      // Default to crypto disabled for safety when API fails\r\n      setAvailableCrypto({ btc: false, eth: false, usdt: false });\r\n      setUsdtFundEnabled(false);\r\n    }\r\n    \r\n    stopAllTimers();\r\n    gameEndedRef.current = false;\r\n    gameStartTimeRef.current = Date.now();\r\n    setElapsedTime(0);\r\n    \r\n    resetCryptoSpawnedCount();\r\n    \r\n    const dims = dimensionsRef.current;\r\n    setCurrentLevel(level);\r\n    const newPath = generatePathForLevel(dims.width, dims.height, level);\r\n    setPath(newPath);\r\n    pathRef.current = newPath;\r\n    \r\n    const initialState = createInitialGameState();\r\n    const ballsWithPositions = updateBallPositions(initialState.balls, newPath);\r\n    \r\n    setGameState({\r\n      ...initialState,\r\n      balls: ballsWithPositions,\r\n      isPlaying: true,\r\n      timeLeft: 0,\r\n    });\r\n    setProjectile(null);\r\n    setShooterAngle(-Math.PI / 2);\r\n    lastTimeRef.current = 0;\r\n    spawnAccumRef.current = 0;\r\n    totalSpawnedRef.current = getGameplayConfig().balls.initialCount;\r\n    spawnFinishedRef.current = false;\r\n    gapContextRef.current = null;\r\n    \r\n    // Track frame count for debug logging\r\n    let frameCount = 0;\r\n    \r\n    const runLoop = (timestamp: number) => {\r\n      if (gameEndedRef.current) return;\r\n\r\n      if (isPausedRef.current && !stepFrameRef.current) {\r\n        lastTimeRef.current = timestamp; // Keep time up to date to avoid jump\r\n        gameLoopRef.current = requestAnimationFrame(runLoop);\r\n        return;\r\n      }\r\n      if (stepFrameRef.current) {\r\n        stepFrameRef.current = false; // Consume step signal\r\n      }\r\n      \r\n      frameCount++;\r\n      \r\n      const deltaTime = lastTimeRef.current ? timestamp - lastTimeRef.current : 16;\r\n      lastTimeRef.current = timestamp;\r\n      const currentPath = pathRef.current;\r\n      \r\n      updateBoostTimers();\r\n      \r\n      if (pendingChainReactionRef.current) {\r\n        gameLoopRef.current = requestAnimationFrame(runLoop);\r\n        return;\r\n      }\r\n      \r\n      // Log gap context state every 60 frames (roughly once per second)\r\n      if (gapContextRef.current && Math.random() < 0.02) {\r\n        sendDebugLog(`[LOOP] gap exists: L:${gapContextRef.current.leftBallId?.slice(-6)} R:${gapContextRef.current.rightBallId?.slice(-6)}`);\r\n      }\r\n      \r\n      setGameState(prev => {\r\n        if (!prev.isPlaying || gameEndedRef.current) return prev;\r\n        \r\n        // During rollback, pause forward movement to let chain close gaps properly\r\n        let newBalls = isRollbackActive() \r\n          ? prev.balls \r\n          : moveBallsForward(prev.balls, deltaTime);\r\n        \r\n        newBalls = processRollback(newBalls, deltaTime, spawnFinishedRef.current);\r\n        \r\n        let updatedState = prev;\r\n        \r\n        const gap = gapContextRef.current;\r\n        // Debug: log gap status every check\r\n        if (gap) {\r\n          const leftIdx = gap.leftBallId ? newBalls.findIndex(b => b.id === gap.leftBallId) : -1;\r\n          const rightIdx = gap.rightBallId ? newBalls.findIndex(b => b.id === gap.rightBallId) : -1;\r\n          const isAdj = rightIdx === leftIdx + 1;\r\n          // Only log when adjacent or first time\r\n          if (isAdj) {\r\n            sendDebugLog(`[GAP-FOUND] L:${leftIdx} R:${rightIdx} adj:${isAdj} len:${newBalls.length}`);\r\n          }\r\n        }\r\n        if (gap && newBalls.length >= 3) {\r\n          const leftIdx = gap.leftBallId ? newBalls.findIndex(b => b.id === gap.leftBallId) : -1;\r\n          const rightIdx = gap.rightBallId ? newBalls.findIndex(b => b.id === gap.rightBallId) : -1;\r\n          \r\n          // Log every frame when gap context exists (only log when adjacent to reduce spam)\r\n          if (rightIdx === leftIdx + 1 || leftIdx < 0 || rightIdx < 0) {\r\n            sendDebugLog(`[GAP] leftIdx:${leftIdx} rightIdx:${rightIdx} adj:${rightIdx === leftIdx + 1} left:${gap.leftBallId?.slice(-6)} right:${gap.rightBallId?.slice(-6)}`);\r\n          }\r\n          \r\n          let foundMatch = false;\r\n          let matchesToProcess: number[] | null = null;\r\n          \r\n          if (leftIdx >= 0 && rightIdx >= 0 && rightIdx === leftIdx + 1) {\r\n            const leftBall = newBalls[leftIdx];\r\n            const rightBall = newBalls[rightIdx];\r\n            \r\n            // Check if balls match: crypto balls match by crypto type, regular balls by color\r\n            const ballsDoMatch = (leftBall.crypto && rightBall.crypto) \r\n              ? leftBall.crypto === rightBall.crypto \r\n              : (!leftBall.crypto && !rightBall.crypto && leftBall.color === rightBall.color);\r\n            \r\n            sendDebugLog(`[CHECK] L:${leftBall.id.slice(-6)} ${leftBall.color}/${leftBall.crypto || 'reg'} R:${rightBall.id.slice(-6)} ${rightBall.color}/${rightBall.crypto || 'reg'} match:${ballsDoMatch}`);\r\n            \r\n            if (ballsDoMatch) {\r\n              // Boundary balls match - check for 3+ chain that includes both\r\n              const matches = findMatchingBalls(newBalls, leftIdx, leftBall);\r\n              sendDebugLog(`[MATCH] found:${matches.length} both:${matches.includes(leftIdx) && matches.includes(rightIdx)}`);\r\n              \r\n              if (matches.length >= 3 && matches.includes(leftIdx) && matches.includes(rightIdx)) {\r\n                foundMatch = true;\r\n                matchesToProcess = matches;\r\n              }\r\n            } else {\r\n              // Boundary balls DON'T match - check each side independently for 3+ chains\r\n              // Check LEFT side: leftBall and its left neighbors\r\n              const leftMatches = findMatchingBalls(newBalls, leftIdx, leftBall);\r\n              sendDebugLog(`[LEFT] matches:${leftMatches.length} hasLeft:${leftMatches.includes(leftIdx)}`);\r\n              if (leftMatches.length >= 3 && leftMatches.includes(leftIdx)) {\r\n                foundMatch = true;\r\n                matchesToProcess = leftMatches;\r\n              }\r\n              \r\n              // Check RIGHT side: rightBall and its right neighbors (only if left didn't match)\r\n              if (!foundMatch) {\r\n                const rightMatches = findMatchingBalls(newBalls, rightIdx, rightBall);\r\n                sendDebugLog(`[RIGHT] matches:${rightMatches.length} hasRight:${rightMatches.includes(rightIdx)}`);\r\n                if (rightMatches.length >= 3 && rightMatches.includes(rightIdx)) {\r\n                  foundMatch = true;\r\n                  matchesToProcess = rightMatches;\r\n                }\r\n              }\r\n            }\r\n          } else if (leftIdx >= 0 && rightIdx < 0) {\r\n            sendDebugLog(`[EDGE] Only left exists, checking`);\r\n            const matches = findMatchingBalls(newBalls, leftIdx, newBalls[leftIdx]);\r\n            if (matches.length >= 3 && matches.includes(leftIdx)) {\r\n              foundMatch = true;\r\n              matchesToProcess = matches;\r\n            }\r\n          } else if (rightIdx >= 0 && leftIdx < 0) {\r\n            sendDebugLog(`[EDGE] Only right exists, checking`);\r\n            const matches = findMatchingBalls(newBalls, rightIdx, newBalls[rightIdx]);\r\n            if (matches.length >= 3 && matches.includes(rightIdx)) {\r\n              foundMatch = true;\r\n              matchesToProcess = matches;\r\n            }\r\n          } else if (leftIdx < 0 || rightIdx < 0) {\r\n            sendDebugLog(`[CLEAR] Ball not found! left:${leftIdx} right:${rightIdx}`);\r\n            gapContextRef.current = null;\r\n          }\r\n          \r\n          if (foundMatch && matchesToProcess) {\r\n            const matchedBalls = matchesToProcess.map(i => newBalls[i]);\r\n            const matchedBallIds = matchedBalls.map(b => b.id);\r\n            \r\n            sendDebugLog(`[CHAIN] Triggering chain reaction! Removing ${matchesToProcess.length} balls`);\r\n            \r\n            const minIdx = matchesToProcess[0];\r\n            const maxIdx = matchesToProcess[matchesToProcess.length - 1];\r\n            const newLeftBall = minIdx > 0 ? newBalls[minIdx - 1] : null;\r\n            const newRightBall = maxIdx < newBalls.length - 1 ? newBalls[maxIdx + 1] : null;\r\n            \r\n            pendingChainReactionRef.current = {\r\n              matchedBallIds,\r\n              newLeftBallId: newLeftBall?.id || null,\r\n              newRightBallId: newRightBall?.id || null,\r\n              combo: prev.combo\r\n            };\r\n            \r\n            chainReactionTimeoutRef.current = setTimeout(() => {\r\n              setGameState(currentState => {\r\n                if (!currentState.isPlaying || gameEndedRef.current) {\r\n                  pendingChainReactionRef.current = null;\r\n                  return currentState;\r\n                }\r\n                \r\n                const pending = pendingChainReactionRef.current;\r\n                if (!pending) return currentState;\r\n                \r\n                const ballIndicesToRemove = pending.matchedBallIds\r\n                  .map(id => currentState.balls.findIndex(b => b.id === id))\r\n                  .filter(idx => idx >= 0)\r\n                  .sort((a, b) => a - b);\r\n                \r\n                pendingChainReactionRef.current = null;\r\n                \r\n                if (ballIndicesToRemove.length < 3) {\r\n                  gapContextRef.current = null;\r\n                  return currentState;\r\n                }\r\n                \r\n                const matchedBalls = ballIndicesToRemove.map(i => currentState.balls[i]);\r\n                const chainCombo = pending.combo;\r\n                const newCombo = chainCombo + 1;\r\n                const { points, cryptoCollected, usdtFundCollected } = calculatePoints(matchedBalls, chainCombo);\r\n                \r\n                const processedBalls = removeBalls(currentState.balls, ballIndicesToRemove);\r\n                // Only arm portal retreat if very early in game (< 10 balls spawned)\r\n                const isEarlyGame = totalSpawnedRef.current < 10;\r\n                activateRollback(isEarlyGame);\r\n                \r\n                if (pending.newLeftBallId || pending.newRightBallId) {\r\n                  gapContextRef.current = { \r\n                    leftBallId: pending.newLeftBallId, \r\n                    rightBallId: pending.newRightBallId \r\n                  };\r\n                } else {\r\n                  gapContextRef.current = null;\r\n                }\r\n                \r\n                hapticFeedback('medium');\r\n                \r\n                const hasCrypto = matchedBalls.some(b => b.crypto || b.isUsdtFund);\r\n                if (hasCrypto) {\r\n                  playCryptoMatchSound();\r\n                } else {\r\n                  playMatchSound(newCombo);\r\n                }\r\n                if (newCombo > 1) {\r\n                  playComboSound(newCombo);\r\n                }\r\n                \r\n                const ballsWithPositions = updateBallPositions(processedBalls, pathRef.current);\r\n                \r\n                return {\r\n                  ...currentState,\r\n                  balls: ballsWithPositions,\r\n                  score: currentState.score + points,\r\n                  combo: newCombo,\r\n                  maxCombo: Math.max(currentState.maxCombo, newCombo),\r\n                  cryptoCollected: {\r\n                    btc: currentState.cryptoCollected.btc + cryptoCollected.btc,\r\n                    eth: currentState.cryptoCollected.eth + cryptoCollected.eth,\r\n                    usdt: currentState.cryptoCollected.usdt + cryptoCollected.usdt,\r\n                  },\r\n                  usdtFundCollected: currentState.usdtFundCollected + usdtFundCollected,\r\n                };\r\n              });\r\n            }, CHAIN_REACTION_DELAY);\r\n            \r\n            newBalls = updateBallPositions(newBalls, currentPath);\r\n            return { ...prev, balls: newBalls };\r\n          }\r\n          \r\n          if (!foundMatch) {\r\n            gapContextRef.current = null;\r\n          }\r\n        }\r\n        \r\n        const gameplayConfig = getGameplayConfig();\r\n        const { period } = gameplayConfig.spawn;\r\n        const buffer = GAME_CONFIG.spawn.buffer;\r\n        const { targetCount } = gameplayConfig.balls;\r\n        \r\n        spawnAccumRef.current += deltaTime;\r\n        \r\n        // Используем currentLifeMaxRef - лимит на текущую жизнь\r\n        const canSpawn = !spawnFinishedRef.current && \r\n                         newBalls.length < targetCount && \r\n                         totalSpawnedRef.current < currentLifeMaxRef.current;\r\n        \r\n        if (spawnAccumRef.current >= period && canSpawn) {\r\n          const spacing = getBallSpacing();\r\n          \r\n          // Find tail ball (lowest progress)\r\n          const tailBall = newBalls.length > 0 \r\n            ? newBalls.reduce((min, b) => b.pathProgress < min.pathProgress ? b : min, newBalls[0])\r\n            : null;\r\n          const tailProgress = tailBall?.pathProgress ?? spacing;\r\n          \r\n          // Spawn at correct logical position (adjacent to tail) for chain cohesion\r\n          const spawnPosition = Math.max(0, tailProgress - spacing);\r\n          \r\n          sendDebugLog(`[SPAWN] accum=${spawnAccumRef.current.toFixed(0)}ms, balls=${newBalls.length}, tailProg=${tailProgress.toFixed(4)}, spawnPos=${spawnPosition.toFixed(4)}`);\r\n          \r\n          spawnAccumRef.current = 0;\r\n          \r\n          // Create ball at correct position with spawn animation for visual portal emergence\r\n          const rawBall = createRandomBall(`spawn-${Date.now()}-${Math.random().toString(36).slice(2)}`, spawnPosition, newBalls);\r\n          const newBall = { ...rawBall, spawnAnimStart: Date.now() };\r\n          \r\n          sendDebugLog(`[SPAWN] Created ball at pos=${spawnPosition.toFixed(4)} with portal anim, id=${newBall.id.slice(0,10)}, color=${newBall.color}`);\r\n          \r\n          newBalls = [newBall, ...newBalls];\r\n          totalSpawnedRef.current++;\r\n          \r\n          if (totalSpawnedRef.current >= currentLifeMaxRef.current) {\r\n            spawnFinishedRef.current = true;\r\n          }\r\n        }\r\n        \r\n        newBalls = updateBallPositions(newBalls, currentPath);\r\n        \r\n        // Победа: все шары уничтожены И спавн завершён\r\n        if (checkWin(newBalls) && spawnFinishedRef.current) {\r\n          gameEndedRef.current = true;\r\n          stopAllTimers();\r\n          const duration = Math.floor((Date.now() - gameStartTimeRef.current) / 1000);\r\n          const finalState = { ...updatedState, balls: newBalls, isPlaying: false, isGameOver: true, won: true, timeLeft: duration };\r\n          setTimeout(() => {\r\n            onGameEndRef.current?.(finalState);\r\n            hapticFeedback('success');\r\n            playWinSound();\r\n          }, 0);\r\n          return finalState;\r\n        }\r\n        \r\n        if (checkGameOver(newBalls)) {\r\n          if (consumeShield()) {\r\n            const spacing = GAME_CONFIG.balls.spacing;\r\n            const beforeCount = newBalls.length;\r\n            \r\n            // FIX: Лимит шаров на следующую жизнь = сколько было на экране\r\n            currentLifeMaxRef.current = beforeCount;\r\n            sendDebugLog(`[ЩИТ] Сработал. Было ${beforeCount} шаров. Новый лимит: ${currentLifeMaxRef.current}`);\r\n            \r\n            let respawnedBalls = [...newBalls];\r\n            respawnedBalls.sort((a, b) => b.pathProgress - a.pathProgress);\r\n            \r\n            // FIX: keepCount = половина от того, что БЫЛО на экране\r\n            let keepCount = Math.ceil(beforeCount / 2);\r\n            keepCount = Math.min(keepCount, beforeCount);\r\n            respawnedBalls = respawnedBalls.slice(0, keepCount);\r\n            \r\n            const n = respawnedBalls.length;\r\n            if (n > 0) {\r\n              const headPos = 0.5; // Голова на 50%\r\n              \r\n              for (let i = 0; i < n; i++) {\r\n                const newProgress = Math.max(0, headPos - i * spacing);\r\n                respawnedBalls[i] = { \r\n                  ...respawnedBalls[i], \r\n                  pathProgress: newProgress,\r\n                  spawnAnimStart: undefined // Без анимации - сразу на позицию\r\n                };\r\n              }\r\n            }\r\n            \r\n            respawnedBalls.sort((a, b) => a.pathProgress - b.pathProgress);\r\n            respawnedBalls = updateBallPositions(respawnedBalls, currentPath);\r\n            \r\n            gapContextRef.current = null;\r\n            spawnFinishedRef.current = false;\r\n            // currentLifeMaxRef уже установлен\r\n            totalSpawnedRef.current = respawnedBalls.length;\r\n\r\n            sendDebugLog(`[ЩИТ] После: осталось ${respawnedBalls.length}, ещё выедут ${currentLifeMaxRef.current - respawnedBalls.length}`);\r\n            hapticFeedback('medium');\r\n            return { ...updatedState, balls: respawnedBalls, combo: 0 };\r\n          }\r\n          \r\n          const beforeLossCount = newBalls.length;\r\n          const maxProgressBefore = newBalls.length > 0 ? Math.max(...newBalls.map(b => b.pathProgress)) : 0;\r\n          \r\n          const newLives = updatedState.lives - 1;\r\n          sendDebugLog(`[ПОТЕРЯ ЖИЗНИ] До: ${beforeLossCount} шаров, голова на ${(maxProgressBefore * 100).toFixed(0)}%, осталось жизней: ${newLives}.`);\r\n          \r\n          if (newLives <= 0) {\r\n            // Проверяем есть ли бонусные жизни из BEADS BOX\r\n            const availableBonusLives = bonusLivesRef.current - usedBonusLivesRef.current;\r\n            \r\n            if (availableBonusLives > 0) {\r\n              // Используем бонусную жизнь\r\n              usedBonusLivesRef.current += 1;\r\n              setUsedBonusLives(prev => prev + 1);\r\n              \r\n              // Вызываем callback для списания бонусной жизни с сервера\r\n              setTimeout(() => {\r\n                onUseBonusLifeRef.current?.();\r\n              }, 0);\r\n              \r\n              // Сбрасываем шарики в начало (как при обычной потере жизни)\r\n              const spacing = GAME_CONFIG.balls.spacing;\r\n              \r\n              let respawnedBalls = [...newBalls];\r\n              respawnedBalls.sort((a, b) => b.pathProgress - a.pathProgress);\r\n              \r\n              let keepCount = Math.ceil(beforeLossCount / 2);\r\n              keepCount = Math.min(keepCount, beforeLossCount);\r\n              respawnedBalls = respawnedBalls.slice(0, keepCount);\r\n              \r\n              const n = respawnedBalls.length;\r\n              if (n > 0) {\r\n                const headPos = 0.5; // Голова на 50%\r\n                \r\n                for (let i = 0; i < n; i++) {\r\n                  const newProgress = Math.max(0, headPos - i * spacing);\r\n                  respawnedBalls[i] = { \r\n                    ...respawnedBalls[i], \r\n                    pathProgress: newProgress,\r\n                    spawnAnimStart: undefined // Без анимации - сразу на позицию\r\n                  };\r\n                }\r\n              }\r\n              \r\n              respawnedBalls.sort((a, b) => a.pathProgress - b.pathProgress);\r\n              respawnedBalls = updateBallPositions(respawnedBalls, currentPath);\r\n              \r\n              gapContextRef.current = null;\r\n              spawnFinishedRef.current = false;\r\n              currentLifeMaxRef.current = maxTotalBallsRef.current; // FIX: Лимит всегда сбрасывается на максимум\r\n              totalSpawnedRef.current = respawnedBalls.length;\r\n              \r\n              sendDebugLog(`[ПОТЕРЯ ЖИЗНИ] После (бонус): было ${beforeLossCount}, осталось ${respawnedBalls.length}, ещё выедут ${currentLifeMaxRef.current - respawnedBalls.length}`);\r\n              hapticFeedback('warning');\r\n              playLifeLostSound();\r\n              return { ...updatedState, balls: respawnedBalls, lives: 1, combo: 0 };\r\n            }\r\n            \r\n            // Нет бонусных жизней - конец игры\r\n            gameEndedRef.current = true;\r\n            stopAllTimers();\r\n            const duration = Math.floor((Date.now() - gameStartTimeRef.current) / 1000);\r\n            const finalState = { ...updatedState, balls: newBalls, lives: 0, isPlaying: false, isGameOver: true, won: false, timeLeft: duration };\r\n            setTimeout(() => {\r\n              onGameEndRef.current?.(finalState);\r\n              hapticFeedback('error');\r\n              playGameOverSound();\r\n            }, 0);\r\n            return finalState;\r\n          }\r\n          \r\n          const spacing = GAME_CONFIG.balls.spacing;\r\n          \r\n          let respawnedBalls = [...newBalls];\r\n          respawnedBalls.sort((a, b) => b.pathProgress - a.pathProgress);\r\n          \r\n          let keepCount = Math.ceil(beforeLossCount / 2);\r\n          keepCount = Math.min(keepCount, beforeLossCount);\r\n          respawnedBalls = respawnedBalls.slice(0, keepCount);\r\n          \r\n          const n = respawnedBalls.length;\r\n          if (n > 0) {\r\n            const headPos = 0.5; // Голова на 50%\r\n            \r\n            for (let i = 0; i < n; i++) {\r\n              const newProgress = Math.max(0, headPos - i * spacing);\r\n              respawnedBalls[i] = { \r\n                ...respawnedBalls[i], \r\n                pathProgress: newProgress,\r\n                spawnAnimStart: undefined // Без анимации - сразу на позицию\r\n              };\r\n            }\r\n          }\r\n          \r\n          respawnedBalls.sort((a, b) => a.pathProgress - b.pathProgress);\r\n          respawnedBalls = updateBallPositions(respawnedBalls, currentPath);\r\n          \r\n          gapContextRef.current = null;\r\n          spawnFinishedRef.current = false;\r\n          currentLifeMaxRef.current = maxTotalBallsRef.current; // FIX: Лимит всегда сбрасывается на максимум\r\n          totalSpawnedRef.current = respawnedBalls.length;\r\n          \r\n          sendDebugLog(`[ПОТЕРЯ ЖИЗНИ] Было ${beforeLossCount} шаров, осталось ${respawnedBalls.length}, ещё выедут ${currentLifeMaxRef.current - respawnedBalls.length}`);\r\n          hapticFeedback('warning');\r\n          playLifeLostSound();\r\n          return { ...updatedState, balls: respawnedBalls, lives: newLives, combo: 0 };\r\n        }\r\n        \r\n        return { ...updatedState, balls: newBalls };\r\n      });\r\n      \r\n      setProjectile(prev => {\r\n        if (!prev || gameEndedRef.current) return prev;\r\n        \r\n        const dims = dimensionsRef.current;\r\n        const newX = prev.x + prev.vx;\r\n        const newY = prev.y + prev.vy;\r\n        \r\n        if (newX < 0 || newX > dims.width || newY < 0 || newY > dims.height) {\r\n          return null;\r\n        }\r\n        \r\n        return { ...prev, prevX: prev.x, prevY: prev.y, x: newX, y: newY };\r\n      });\r\n      \r\n      gameLoopRef.current = requestAnimationFrame(runLoop);\r\n    };\r\n    \r\n    gameLoopRef.current = requestAnimationFrame(runLoop);\r\n    \r\n    timeTrackerRef.current = setInterval(() => {\r\n      if (gameEndedRef.current) return;\r\n      setElapsedTime(Math.floor((Date.now() - gameStartTimeRef.current) / 1000));\r\n    }, 1000);\r\n    \r\n    hapticFeedback('medium');\r\n  }, [stopAllTimers]);\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      stopAllTimers();\r\n    };\r\n  }, [stopAllTimers]);\r\n\r\n  useEffect(() => {\r\n    if (!projectile || gameEndedRef.current) return;\r\n    \r\n    setGameState(prev => {\r\n      if (!prev.isPlaying || gameEndedRef.current) return prev;\r\n      \r\n      const collision = checkPathCollision(\r\n        projectile.x, projectile.y,\r\n        projectile.prevX, projectile.prevY,\r\n        prev.balls, pathRef.current\r\n      );\r\n      \r\n      if (collision) {\r\n        const insertIndex = collision.insertBefore ? collision.index : collision.index + 1;\r\n        \r\n        // Check if laser boost is active - pierces through balls without inserting\r\n        const laserResult = consumeLaser();\r\n        if (laserResult.active) {\r\n          const hitIndices: number[] = [];\r\n          for (let i = 0; i < Math.min(laserResult.pierceCount, prev.balls.length); i++) {\r\n            const idx = collision.index + i;\r\n            if (idx >= 0 && idx < prev.balls.length) {\r\n              hitIndices.push(idx);\r\n            }\r\n          }\r\n          \r\n          if (hitIndices.length > 0) {\r\n            const { newBalls: laserBalls, removedBalls } = applyLaserEffect(prev.balls, hitIndices);\r\n            const updatedBalls = updateBallPositions(laserBalls, pathRef.current);\r\n            \r\n            const { points, cryptoCollected, usdtFundCollected } = calculatePoints(removedBalls, 0);\r\n            \r\n            hapticFeedback('heavy');\r\n            playComboSound(removedBalls.length);\r\n            \r\n            const hasCrypto = removedBalls.some(b => b.crypto || b.isUsdtFund);\r\n            if (hasCrypto) {\r\n              playCryptoMatchSound();\r\n            } else {\r\n              playMatchSound();\r\n            }\r\n            \r\n            gapContextRef.current = null;\r\n            setProjectile(null);\r\n            \r\n            return {\r\n              ...prev,\r\n              balls: updatedBalls,\r\n              score: prev.score + points,\r\n              combo: removedBalls.length,\r\n              maxCombo: Math.max(prev.maxCombo, removedBalls.length),\r\n              cryptoCollected: {\r\n                btc: prev.cryptoCollected.btc + cryptoCollected.btc,\r\n                eth: prev.cryptoCollected.eth + cryptoCollected.eth,\r\n                usdt: prev.cryptoCollected.usdt + cryptoCollected.usdt,\r\n              },\r\n              usdtFundCollected: prev.usdtFundCollected + usdtFundCollected,\r\n              shooterBall: prev.nextBall,\r\n              nextBall: createRandomBall('next-' + Date.now(), 0, prev.balls, true),\r\n            };\r\n          }\r\n        }\r\n        \r\n        let newBalls = insertBallInChain(prev.balls, projectile.ball, insertIndex);\r\n        newBalls = updateBallPositions(newBalls, pathRef.current);\r\n        \r\n        // Check if magnet boost is active - attracts same color balls closer\r\n        const magnetResult = consumeMagnet();\r\n        if (magnetResult.active) {\r\n          newBalls = applyMagnetEffect(newBalls, insertIndex, magnetResult.radius);\r\n          newBalls = updateBallPositions(newBalls, pathRef.current);\r\n          hapticFeedback('medium');\r\n        }\r\n        \r\n        // Check if bomb boost is active\r\n        if (consumeBomb()) {\r\n          const { newBalls: bombedBalls, removedBalls } = applyBombEffect(newBalls, insertIndex, 5);\r\n          newBalls = bombedBalls;\r\n          \r\n          if (removedBalls.length > 0) {\r\n            const { points, cryptoCollected, usdtFundCollected } = calculatePoints(removedBalls, 0);\r\n            \r\n            hapticFeedback('heavy');\r\n            playComboSound(2);\r\n            \r\n            const hasCrypto = removedBalls.some(b => b.crypto || b.isUsdtFund);\r\n            if (hasCrypto) {\r\n              playCryptoMatchSound();\r\n            } else {\r\n              playMatchSound();\r\n            }\r\n            \r\n            gapContextRef.current = null;\r\n            setProjectile(null);\r\n            \r\n            return {\r\n              ...prev,\r\n              balls: newBalls,\r\n              score: prev.score + points,\r\n              combo: 2,\r\n              maxCombo: Math.max(prev.maxCombo, 2),\r\n              cryptoCollected: {\r\n                btc: prev.cryptoCollected.btc + cryptoCollected.btc,\r\n                eth: prev.cryptoCollected.eth + cryptoCollected.eth,\r\n                usdt: prev.cryptoCollected.usdt + cryptoCollected.usdt,\r\n              },\r\n              usdtFundCollected: prev.usdtFundCollected + usdtFundCollected,\r\n              shooterBall: prev.nextBall,\r\n              nextBall: createRandomBall('next-' + Date.now(), 0, newBalls, true),\r\n            };\r\n          }\r\n        }\r\n        \r\n        const matches = findMatchingBalls(newBalls, insertIndex, projectile.ball);\r\n        \r\n        if (matches.length >= 3) {\r\n          const matchedBalls = matches.map(i => newBalls[i]);\r\n          const { points, cryptoCollected, usdtFundCollected } = calculatePoints(matchedBalls, 0);\r\n          \r\n          const minIdx = matches[0];\r\n          const maxIdx = matches[matches.length - 1];\r\n          const leftBall = minIdx > 0 ? newBalls[minIdx - 1] : null;\r\n          const rightBall = maxIdx < newBalls.length - 1 ? newBalls[maxIdx + 1] : null;\r\n          \r\n          newBalls = removeBalls(newBalls, matches);\r\n          // Only arm portal retreat if very early in game (< 10 balls spawned)\r\n          const isEarlyGame = totalSpawnedRef.current < 10;\r\n          activateRollback(isEarlyGame);\r\n          \r\n          let totalPoints = points;\r\n          let totalCryptoCollected = { ...cryptoCollected };\r\n          let totalUsdtFundCollected = usdtFundCollected;\r\n          let currentCombo = 1;\r\n          let currentLeftBall = leftBall;\r\n          let currentRightBall = rightBall;\r\n          \r\n          // Check for immediate chain reaction (balls are already adjacent after removal)\r\n          while (currentLeftBall && currentRightBall && newBalls.length >= 3) {\r\n            const leftIdx = newBalls.findIndex(b => b.id === currentLeftBall!.id);\r\n            const rightIdx = newBalls.findIndex(b => b.id === currentRightBall!.id);\r\n            \r\n            if (leftIdx < 0 || rightIdx < 0 || rightIdx !== leftIdx + 1) {\r\n              sendDebugLog(`[CHAIN-BREAK] L:${leftIdx} R:${rightIdx} adj:${rightIdx === leftIdx + 1}`);\r\n              break;\r\n            }\r\n            \r\n            // Check if boundary balls match\r\n            const leftB = newBalls[leftIdx];\r\n            const rightB = newBalls[rightIdx];\r\n            const ballsDoMatch = (leftB.crypto && rightB.crypto) \r\n              ? leftB.crypto === rightB.crypto \r\n              : (!leftB.crypto && !rightB.crypto && leftB.color === rightB.color);\r\n            \r\n            if (!ballsDoMatch) {\r\n              sendDebugLog(`[CHAIN-NOMATCH] L:${leftB.color}/${leftB.crypto || 'reg'} R:${rightB.color}/${rightB.crypto || 'reg'}`);\r\n              break;\r\n            }\r\n            \r\n            // Find matching balls starting from left\r\n            const chainMatches = findMatchingBalls(newBalls, leftIdx, leftB);\r\n            \r\n            if (chainMatches.length < 3 || !chainMatches.includes(leftIdx) || !chainMatches.includes(rightIdx)) {\r\n              sendDebugLog(`[CHAIN-SHORT] found:${chainMatches.length} hasLeft:${chainMatches.includes(leftIdx)} hasRight:${chainMatches.includes(rightIdx)}`);\r\n              break;\r\n            }\r\n            \r\n            // Chain reaction found!\r\n            currentCombo++;\r\n            sendDebugLog(`[CHAIN-REACT] combo:${currentCombo} removing:${chainMatches.length} balls`);\r\n            \r\n            const chainMatchedBalls = chainMatches.map(i => newBalls[i]);\r\n            const chainResult = calculatePoints(chainMatchedBalls, currentCombo - 1);\r\n            totalPoints += chainResult.points;\r\n            totalCryptoCollected.btc += chainResult.cryptoCollected.btc;\r\n            totalCryptoCollected.eth += chainResult.cryptoCollected.eth;\r\n            totalCryptoCollected.usdt += chainResult.cryptoCollected.usdt;\r\n            totalUsdtFundCollected += chainResult.usdtFundCollected;\r\n            \r\n            // Get new boundary balls before removal\r\n            const newMinIdx = chainMatches[0];\r\n            const newMaxIdx = chainMatches[chainMatches.length - 1];\r\n            currentLeftBall = newMinIdx > 0 ? newBalls[newMinIdx - 1] : null;\r\n            currentRightBall = newMaxIdx < newBalls.length - 1 ? newBalls[newMaxIdx + 1] : null;\r\n            \r\n            newBalls = removeBalls(newBalls, chainMatches);\r\n            // Keep same early game state for chain reactions\r\n            activateRollback(isEarlyGame);\r\n            \r\n            // Play combo sound\r\n            const hasChainCrypto = chainMatchedBalls.some(b => b.crypto || b.isUsdtFund);\r\n            if (hasChainCrypto) {\r\n              playCryptoMatchSound();\r\n            }\r\n            playComboSound(currentCombo);\r\n            hapticFeedback('heavy');\r\n          }\r\n          \r\n          // Clear gap context since we processed chain reactions synchronously\r\n          gapContextRef.current = null;\r\n          sendDebugLog(`[CHAIN-END] combo:${currentCombo} points:${totalPoints}`);\r\n          \r\n          hapticFeedback('medium');\r\n          \r\n          const hasCrypto = matchedBalls.some(b => b.crypto || b.isUsdtFund);\r\n          if (hasCrypto) {\r\n            playCryptoMatchSound();\r\n          } else {\r\n            playMatchSound(currentCombo);\r\n          }\r\n          const newScore = prev.score + totalPoints;\r\n          \r\n          setProjectile(null);\r\n          \r\n          // Победа: все шары уничтожены И спавн завершён\r\n          if (checkWin(newBalls) && spawnFinishedRef.current) {\r\n            gameEndedRef.current = true;\r\n            stopAllTimers();\r\n            const duration = Math.floor((Date.now() - gameStartTimeRef.current) / 1000);\r\n            const finalState = {\r\n              ...prev,\r\n              balls: newBalls,\r\n              score: newScore,\r\n              combo: currentCombo,\r\n              maxCombo: Math.max(prev.maxCombo, currentCombo),\r\n              cryptoCollected: {\r\n                btc: prev.cryptoCollected.btc + totalCryptoCollected.btc,\r\n                eth: prev.cryptoCollected.eth + totalCryptoCollected.eth,\r\n                usdt: prev.cryptoCollected.usdt + totalCryptoCollected.usdt,\r\n              },\r\n              usdtFundCollected: prev.usdtFundCollected + totalUsdtFundCollected,\r\n              shotsHit: prev.shotsHit + 1,\r\n              isPlaying: false,\r\n              isGameOver: true,\r\n              won: true,\r\n              timeLeft: duration,\r\n            };\r\n            setTimeout(() => {\r\n              onGameEndRef.current?.(finalState);\r\n              hapticFeedback('success');\r\n            }, 100);\r\n            return finalState;\r\n          }\r\n          \r\n          return {\r\n            ...prev,\r\n            balls: newBalls,\r\n            score: newScore,\r\n            combo: currentCombo,\r\n            maxCombo: Math.max(prev.maxCombo, currentCombo),\r\n            cryptoCollected: {\r\n              btc: prev.cryptoCollected.btc + totalCryptoCollected.btc,\r\n              eth: prev.cryptoCollected.eth + totalCryptoCollected.eth,\r\n              usdt: prev.cryptoCollected.usdt + totalCryptoCollected.usdt,\r\n            },\r\n            usdtFundCollected: prev.usdtFundCollected + totalUsdtFundCollected,\r\n            shotsHit: prev.shotsHit + 1,\r\n          };\r\n        } else {\r\n          setProjectile(null);\r\n          if (gapContextRef.current) {\r\n            sendDebugLog(`[RESET] Gap context cleared by non-matching shot!`);\r\n          }\r\n          gapContextRef.current = null;\r\n          \r\n          return {\r\n            ...prev,\r\n            balls: newBalls,\r\n            combo: 0,\r\n            shotsHit: prev.shotsHit + 1,\r\n          };\r\n        }\r\n      }\r\n      \r\n      return prev;\r\n    });\r\n  }, [projectile, stopAllTimers]);\r\n\r\n  const shoot = useCallback((targetX: number, targetY: number) => {\r\n    // Use ref to get current shooterBall to avoid stale closure issues\r\n    const currentShooterBall = shooterBallRef.current;\r\n    if (!gameState.isPlaying || projectile || !currentShooterBall) return;\r\n    \r\n    const dx = targetX - shooterPosition.x;\r\n    const dy = targetY - shooterPosition.y;\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    \r\n    if (distance === 0) return;\r\n    \r\n    const vx = (dx / distance) * SHOOTER_BALL_SPEED;\r\n    const vy = (dy / distance) * SHOOTER_BALL_SPEED;\r\n    \r\n    // Apply rainbow boost to the shooting ball if active\r\n    let ballToShoot = currentShooterBall;\r\n    if (consumeRainbow()) {\r\n      ballToShoot = { ...ballToShoot, isRainbow: true };\r\n    }\r\n    \r\n    setProjectile({\r\n      x: shooterPosition.x,\r\n      y: shooterPosition.y,\r\n      prevX: shooterPosition.x,\r\n      prevY: shooterPosition.y,\r\n      vx,\r\n      vy,\r\n      ball: ballToShoot,\r\n    });\r\n    \r\n    setGameState(prev => ({\r\n      ...prev,\r\n      shooterBall: prev.nextBall,\r\n      nextBall: createRandomBall('next-' + Date.now(), 0, prev.balls, true),\r\n      shotsTotal: prev.shotsTotal + 1,\r\n    }));\r\n    \r\n    hapticFeedback('light');\r\n    playShootSound();\r\n  }, [gameState.isPlaying, projectile, shooterPosition]);\r\n\r\n  const updateAim = useCallback((targetX: number, targetY: number) => {\r\n    if (!gameState.isPlaying) return;\r\n    \r\n    const dx = targetX - shooterPosition.x;\r\n    const dy = targetY - shooterPosition.y;\r\n    const angle = Math.atan2(dy, dx);\r\n    \r\n    setShooterAngle(angle);\r\n  }, [gameState.isPlaying, shooterPosition]);\r\n\r\n  // resumeGame принимает опцию incrementLives для addExtraLife\r\n  const resumeGame = useCallback((options?: { incrementLives?: boolean }) => {\r\n    const shouldIncrementLives = options?.incrementLives ?? false;\r\n    stopAllTimers();\r\n    gameEndedRef.current = false;\r\n    lastTimeRef.current = 0;\r\n    spawnAccumRef.current = 0;\r\n    \r\n    setGameState(prev => {\r\n      let currentPath = pathRef.current;\r\n      if (currentPath.length === 0) {\r\n        console.warn(\"Path not initialized in resumeGame, regenerating...\");\r\n        currentPath = generatePathForLevel(dimensionsRef.current.width, dimensionsRef.current.height, level);\r\n        pathRef.current = currentPath;\r\n        setPath(currentPath);\r\n      }\r\n      \r\n      const beforeCount = prev.balls.length;\r\n      \r\n      if (prev.balls.length === 0) {\r\n        spawnFinishedRef.current = true;\r\n        totalSpawnedRef.current = 0;\r\n        currentLifeMaxRef.current = 0;\r\n        const logType = shouldIncrementLives ? 'ПОКУПКА ЖИЗНИ' : 'ПРОДОЛЖИТЬ ИГРУ';\r\n        sendDebugLog(`[${logType}] Цепочка: 0 → 0 шаров, спавн завершён.`);\r\n        return {\r\n          ...prev,\r\n          lives: shouldIncrementLives ? prev.lives + 1 : 1,\r\n          isPlaying: true,\r\n          isGameOver: false,\r\n          won: false,\r\n          extraLivesBought: prev.extraLivesBought + 1,\r\n        };\r\n      }\r\n      \r\n      // FIX: Логика, аналогичная потере жизни\r\n      const spacing = GAME_CONFIG.balls.spacing;\r\n      let respawnedBalls = [...prev.balls].sort((a, b) => b.pathProgress - a.pathProgress);\r\n\r\n      currentLifeMaxRef.current = beforeCount; // Лимит = сколько было\r\n\r\n      let keepCount = Math.ceil(beforeCount / 2);\r\n      keepCount = Math.min(keepCount, beforeCount);\r\n      respawnedBalls = respawnedBalls.slice(0, keepCount);\r\n      \r\n      const n = respawnedBalls.length;\r\n      if (n > 0) {\r\n        const headPos = 0.5; // Голова на 50%\r\n        for (let i = 0; i < n; i++) {\r\n          const newProgress = Math.max(0, headPos - i * spacing);\r\n          respawnedBalls[i] = { \r\n            ...respawnedBalls[i], \r\n            pathProgress: newProgress,\r\n            spawnAnimStart: undefined\r\n          };\r\n        }\r\n      }\r\n      \r\n      respawnedBalls.sort((a, b) => a.pathProgress - b.pathProgress);\r\n      respawnedBalls = updateBallPositions(respawnedBalls, currentPath);\r\n      \r\n      gapContextRef.current = null;\r\n      spawnFinishedRef.current = false;\r\n      totalSpawnedRef.current = respawnedBalls.length;\r\n      \r\n      const logType = shouldIncrementLives ? 'ПОКУПКА ЖИЗНИ' : 'ПРОДОЛЖИТЬ ИГРУ';\r\n      sendDebugLog(`[${logType}] Было ${beforeCount}, осталось ${respawnedBalls.length}, ещё выедут ${currentLifeMaxRef.current - respawnedBalls.length}`);\r\n      \r\n      return {\r\n        ...prev,\r\n        balls: respawnedBalls,\r\n        lives: shouldIncrementLives ? prev.lives + 1 : 1,\r\n        isPlaying: true,\r\n        isGameOver: false,\r\n        won: false,\r\n        extraLivesBought: prev.extraLivesBought + 1,\r\n      };\r\n    });\r\n    \r\n    const currentPath = pathRef.current;\r\n    \r\n    const runLoop = (timestamp: number) => {\r\n      if (gameEndedRef.current) return;\r\n      \r\n      const deltaTime = lastTimeRef.current ? timestamp - lastTimeRef.current : 16;\r\n      lastTimeRef.current = timestamp;\r\n      \r\n      updateBoostTimers();\r\n      \r\n      setGameState(prev => {\r\n        if (!prev.isPlaying || gameEndedRef.current) return prev;\r\n        \r\n        let newBalls = isRollbackActive() \r\n          ? prev.balls \r\n          : moveBallsForward(prev.balls, deltaTime);\r\n        newBalls = processRollback(newBalls, deltaTime, spawnFinishedRef.current);\r\n        \r\n        const gameplayConfig = getGameplayConfig();\r\n        const { period } = gameplayConfig.spawn;\r\n        const { targetCount } = gameplayConfig.balls;\r\n        \r\n        spawnAccumRef.current += deltaTime;\r\n        \r\n        const canSpawn = !spawnFinishedRef.current && \r\n                         newBalls.length < targetCount && \r\n                         totalSpawnedRef.current < currentLifeMaxRef.current;\r\n        \r\n        if (spawnAccumRef.current >= period && canSpawn) {\r\n          const spacing = getBallSpacing();\r\n          \r\n          const tailBall = newBalls.length > 0 \r\n            ? newBalls.reduce((min, b) => b.pathProgress < min.pathProgress ? b : min, newBalls[0])\r\n            : null;\r\n          const tailProgress = tailBall?.pathProgress ?? spacing;\r\n          const spawnPosition = Math.max(0, tailProgress - spacing);\r\n          \r\n          spawnAccumRef.current = 0;\r\n          \r\n          const rawBall = createRandomBall(`spawn-${Date.now()}-${Math.random().toString(36).slice(2)}`, spawnPosition, newBalls);\r\n          const newBall = { ...rawBall, spawnAnimStart: Date.now() };\r\n          \r\n          newBalls = [newBall, ...newBalls];\r\n          totalSpawnedRef.current++;\r\n          \r\n          if (totalSpawnedRef.current >= currentLifeMaxRef.current) {\r\n            spawnFinishedRef.current = true;\r\n          }\r\n        }\r\n        \r\n        newBalls = updateBallPositions(newBalls, currentPath);\r\n        \r\n        if (checkWin(newBalls) && spawnFinishedRef.current) {\r\n          gameEndedRef.current = true;\r\n          stopAllTimers();\r\n          const duration = Math.floor((Date.now() - gameStartTimeRef.current) / 1000);\r\n          const finalState = { ...prev, balls: newBalls, isPlaying: false, isGameOver: true, won: true, timeLeft: duration };\r\n          setTimeout(() => {\r\n            onGameEndRef.current?.(finalState);\r\n            hapticFeedback('success');\r\n            playWinSound();\r\n          }, 0);\r\n          return finalState;\r\n        }\r\n        \r\n        if (checkGameOver(newBalls)) {\r\n          if (consumeShield()) {\r\n            const spacing = GAME_CONFIG.balls.spacing;\r\n            const beforeCount = newBalls.length;\r\n            \r\n            let respawnedBalls = [...newBalls];\r\n            respawnedBalls.sort((a, b) => b.pathProgress - a.pathProgress);\r\n            \r\n            let keepCount = Math.ceil(maxTotalBallsRef.current / 2);\r\n            keepCount = Math.min(keepCount, beforeCount);\r\n            respawnedBalls = respawnedBalls.slice(0, keepCount);\r\n            \r\n            const n = respawnedBalls.length;\r\n            if (n > 0) {\r\n              const headPos = 0.5;\r\n              \r\n              for (let i = 0; i < n; i++) {\r\n                const newProgress = Math.max(0, headPos - i * spacing);\r\n                respawnedBalls[i] = { \r\n                  ...respawnedBalls[i], \r\n                  pathProgress: newProgress,\r\n                  spawnAnimStart: undefined\r\n                };\r\n              }\r\n            }\r\n            \r\n            respawnedBalls.sort((a, b) => a.pathProgress - b.pathProgress);\r\n            respawnedBalls = updateBallPositions(respawnedBalls, currentPath);\r\n            \r\n            gapContextRef.current = null;\r\n            spawnFinishedRef.current = false;\r\n            currentLifeMaxRef.current = maxTotalBallsRef.current;\r\n            totalSpawnedRef.current = respawnedBalls.length;\r\n            hapticFeedback('medium');\r\n            return { ...prev, balls: respawnedBalls, combo: 0 };\r\n          }\r\n          \r\n          const beforeLossCount2 = newBalls.length;\r\n          const maxProgressBefore2 = newBalls.length > 0 ? Math.max(...newBalls.map(b => b.pathProgress)) : 0;\r\n\r\n          const newLives = prev.lives - 1;\r\n          sendDebugLog(`[ПОТЕРЯ ЖИЗНИ] До: ${beforeLossCount2} шаров, голова на ${(maxProgressBefore2 * 100).toFixed(0)}%, осталось жизней: ${newLives}.`);\r\n          \r\n          if (newLives <= 0) {\r\n            const availableBonusLives = bonusLivesRef.current - usedBonusLivesRef.current;\r\n            \r\n            if (availableBonusLives > 0) {\r\n              usedBonusLivesRef.current += 1;\r\n              setUsedBonusLives(prev => prev + 1);\r\n              \r\n              setTimeout(() => {\r\n                onUseBonusLifeRef.current?.();\r\n              }, 0);\r\n              \r\n              const spacing = GAME_CONFIG.balls.spacing;\r\n              \r\n              let respawnedBalls = [...newBalls];\r\n              respawnedBalls.sort((a, b) => b.pathProgress - a.pathProgress);\r\n              \r\n              let keepCount = Math.ceil(beforeLossCount2 / 2);\r\n              keepCount = Math.min(keepCount, beforeLossCount2);\r\n              respawnedBalls = respawnedBalls.slice(0, keepCount);\r\n              \r\n              const n = respawnedBalls.length;\r\n              if (n > 0) {\r\n                const headPos = 0.5;\r\n                \r\n                for (let i = 0; i < n; i++) {\r\n                  const newProgress = Math.max(0, headPos - i * spacing);\r\n                  respawnedBalls[i] = { \r\n                    ...respawnedBalls[i], \r\n                    pathProgress: newProgress,\r\n                    spawnAnimStart: undefined\r\n                  };\r\n                }\r\n              }\r\n              \r\n              respawnedBalls.sort((a, b) => a.pathProgress - b.pathProgress);\r\n              respawnedBalls = updateBallPositions(respawnedBalls, currentPath);\r\n              \r\n              gapContextRef.current = null;\r\n              spawnFinishedRef.current = false;\r\n              currentLifeMaxRef.current = maxTotalBallsRef.current; // FIX: Лимит всегда сбрасывается на максимум\r\n              totalSpawnedRef.current = respawnedBalls.length;\r\n              \r\n              sendDebugLog(`[ПОТЕРЯ ЖИЗНИ] После (бонус): было ${beforeLossCount2}, осталось ${respawnedBalls.length}, ещё выедут ${currentLifeMaxRef.current - respawnedBalls.length}`);\r\n              hapticFeedback('warning');\r\n              playLifeLostSound();\r\n              return { ...prev, balls: respawnedBalls, lives: 1, combo: 0 };\r\n            }\r\n            \r\n            gameEndedRef.current = true;\r\n            stopAllTimers();\r\n            const duration = Math.floor((Date.now() - gameStartTimeRef.current) / 1000);\r\n            const finalState = { ...prev, balls: newBalls, lives: 0, isPlaying: false, isGameOver: true, won: false, timeLeft: duration };\r\n            setTimeout(() => {\r\n              onGameEndRef.current?.(finalState);\r\n              hapticFeedback('error');\r\n              playGameOverSound();\r\n            }, 0);\r\n            return finalState;\r\n          }\r\n          \r\n          const spacing = GAME_CONFIG.balls.spacing;\r\n          \r\n          let respawnedBalls = [...newBalls];\r\n          respawnedBalls.sort((a, b) => b.pathProgress - a.pathProgress);\r\n          \r\n          let keepCount = Math.ceil(beforeLossCount2 / 2);\r\n          keepCount = Math.min(keepCount, beforeLossCount2);\r\n          respawnedBalls = respawnedBalls.slice(0, keepCount);\r\n          \r\n          const n = respawnedBalls.length;\r\n          if (n > 0) {\r\n            const headPos = 0.5;\r\n            \r\n            for (let i = 0; i < n; i++) {\r\n              const newProgress = Math.max(0, headPos - i * spacing);\r\n              respawnedBalls[i] = { \r\n                ...respawnedBalls[i], \r\n                pathProgress: newProgress,\r\n                spawnAnimStart: undefined\r\n              };\r\n            }\r\n          }\r\n          \r\n          respawnedBalls.sort((a, b) => a.pathProgress - b.pathProgress);\r\n          respawnedBalls = updateBallPositions(respawnedBalls, currentPath);\r\n          \r\n          gapContextRef.current = null;\r\n          spawnFinishedRef.current = false;\r\n          currentLifeMaxRef.current = maxTotalBallsRef.current; // FIX: Лимит всегда сбрасывается на максимум\r\n          totalSpawnedRef.current = respawnedBalls.length;\r\n          \r\n          sendDebugLog(`[ПОТЕРЯ ЖИЗНИ] Было ${beforeLossCount2} шаров, осталось ${respawnedBalls.length}, ещё выедут ${currentLifeMaxRef.current - respawnedBalls.length}`);\r\n          hapticFeedback('warning');\r\n          playLifeLostSound();\r\n          return { ...prev, balls: respawnedBalls, lives: newLives, combo: 0 };\r\n        }\r\n        \r\n        return { ...prev, balls: newBalls };\r\n      });\r\n      \r\n      setProjectile(prev => {\r\n        if (!prev || gameEndedRef.current) return prev;\r\n        \r\n        const dims = dimensionsRef.current;\r\n        const newX = prev.x + prev.vx;\r\n        const newY = prev.y + prev.vy;\r\n        \r\n        if (newX < 0 || newX > dims.width || newY < 0 || newY > dims.height) {\r\n          return null;\r\n        }\r\n        \r\n        return { ...prev, prevX: prev.x, prevY: prev.y, x: newX, y: newY };\r\n      });\r\n      \r\n      gameLoopRef.current = requestAnimationFrame(runLoop);\r\n    };\r\n    \r\n    gameLoopRef.current = requestAnimationFrame(runLoop);\r\n    \r\n    timeTrackerRef.current = setInterval(() => {\r\n      if (gameEndedRef.current) return;\r\n      setElapsedTime(Math.floor((Date.now() - gameStartTimeRef.current) / 1000));\r\n    }, 1000);\r\n    \r\n    hapticFeedback('success');\r\n  }, [stopAllTimers, level]);\r\n\r\n  const ballsOnScreen = gameState.balls.length;\r\n  const totalBalls = maxTotalBallsRef.current;\r\n  const totalSpawned = totalSpawnedRef.current;\r\n  const ballsRemaining = totalBalls - totalSpawned + ballsOnScreen;\r\n  const currentLifeMax = currentLifeMaxRef.current;\r\n\r\n  const applyRewind = useCallback(() => {\r\n    setGameState(prev => {\r\n      const rewindedBalls = applyRewindEffect(prev.balls, 0.2);\r\n      const updatedBalls = updateBallPositions(rewindedBalls, pathRef.current);\r\n      return { ...prev, balls: updatedBalls };\r\n    });\r\n    hapticFeedback('medium');\r\n  }, []);\r\n\r\n  // addExtraLife вызывает resumeGame с флагом incrementLives\r\n  const addExtraLife = useCallback((extraSeconds: number) => {\r\n    resumeGame({ incrementLives: true });\r\n  }, [resumeGame]);\r\n\r\n  const togglePause = useCallback(() => {\r\n    isPausedRef.current = !isPausedRef.current;\r\n    setIsPaused(isPausedRef.current);\r\n    sendDebugLog(`[DEBUG] Game ${isPausedRef.current ? 'Paused' : 'Resumed'}`);\r\n  }, []);\r\n\r\n  const stepFrame = useCallback(() => {\r\n    if (isPausedRef.current) {\r\n      stepFrameRef.current = true;\r\n      sendDebugLog(`[DEBUG] Stepping one frame`);\r\n    }\r\n  }, []);\r\n\r\n  return {\r\n    gameState,\r\n    path,\r\n    projectile,\r\n    shooterAngle,\r\n    shooterPosition,\r\n    elapsedTime,\r\n    ballsOnScreen,\r\n    ballsRemaining,\r\n    totalBalls,\r\n    totalSpawned,\r\n    currentLifeMax,\r\n    isPaused,\r\n    startGame,\r\n    shoot,\r\n    updateAim,\r\n    addExtraLife,\r\n    resumeGame,\r\n    applyRewind,\r\n    togglePause,\r\n    stepFrame,\r\n  };\r\n}\r\n"],"names":[],"mappings":"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"}}]
}